{"version":3,"file":"js.cjs.production.min.js","sources":["../src/api/numeric.ts","../node_modules/regenerator-runtime/runtime.js","../src/api/serialize.ts","../src/cryptography/conversions.ts","../src/cryptography/publicKey.ts","../src/cryptography/signature.ts","../src/cryptography/privateKey.ts","../src/cryptography/key.ts","../src/cryptography/jsSignatureProvider.ts","../src/api/index.ts","../src/rpc/error.ts","../src/rpc/proton.ts","../src/rpc/index.ts","../src/cryptography/webauthn.ts","../src/index.ts"],"sourcesContent":["/**\n * @module Numeric\n */\n import { sha256 } from 'hash.js';\n import RIPEMD160 from 'ripemd-ts'\n \n const ripemd160 = RIPEMD160.hash as (a: Uint8Array) => ArrayBuffer;\n const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n \n const create_base58_map = (): number[] => {\n    const base58M = Array(256).fill(-1) as number[];\n     for (let i = 0; i < base58Chars.length; ++i) {\n         base58M[base58Chars.charCodeAt(i)] = i;\n     }\n     return base58M;\n };\n \n const base58Map = create_base58_map();\n \n const create_base64_map = (): number[] => {\n    const base64M = Array(256).fill(-1) as number[];\n     for (let i = 0; i < base64Chars.length; ++i) {\n         base64M[base64Chars.charCodeAt(i)] = i;\n     }\n     base64M['='.charCodeAt(0)] = 0;\n     return base64M;\n };\n \n const base64Map = create_base64_map();\n \n /** Is `bignum` a negative number? */\n export const isNegative = (bignum: Uint8Array): boolean => {\n    return (bignum[bignum.length - 1] & 0x80) !== 0;\n };\n \n /** Negate `bignum` */\n export const negate = (bignum: Uint8Array): void => {\n    let carry = 1;\n     for (let i = 0; i < bignum.length; ++i) {\n         const x = (~bignum[i] & 0xff) + carry;\n         bignum[i] = x;\n         carry = x >> 8;\n     }\n };\n \n /**\n  * Convert an unsigned decimal number in `s` to a bignum\n  *\n  * @param size bignum size (bytes)\n  */\nexport const decimalToBinary = (size: number, s: string): Uint8Array => {\n    const result = new Uint8Array(size);\n     for (let i = 0; i < s.length; ++i) {\n         const srcDigit = s.charCodeAt(i);\n         if (srcDigit < '0'.charCodeAt(0) || srcDigit > '9'.charCodeAt(0)) {\n             throw new Error('invalid number');\n         }\n         let carry = srcDigit - '0'.charCodeAt(0);\n         for (let j = 0; j < size; ++j) {\n             const x = result[j] * 10 + carry;\n             result[j] = x;\n             carry = x >> 8;\n         }\n         if (carry) {\n             throw new Error('number is out of range');\n         }\n     }\n     return result;\n };\n \n /**\n  * Convert a signed decimal number in `s` to a bignum\n  *\n  * @param size bignum size (bytes)\n  */\nexport const signedDecimalToBinary = (size: number, s: string): Uint8Array => {\n    const negative = s[0] === '-';\n     if (negative) {\n         s = s.substr(1);\n     }\n     const result = decimalToBinary(size, s);\n     if (negative) {\n         negate(result);\n         if (!isNegative(result)) {\n             throw new Error('number is out of range');\n         }\n     } else if (isNegative(result)) {\n         throw new Error('number is out of range');\n     }\n     return result;\n };\n \n /**\n  * Convert `bignum` to an unsigned decimal number\n  *\n  * @param minDigits 0-pad result to this many digits\n  */\nexport const binaryToDecimal = (bignum: Uint8Array, minDigits = 1): string => {\n    const result = Array(minDigits).fill('0'.charCodeAt(0)) as number[];\n    for (let i = bignum.length - 1; i >= 0; --i) {\n        let carry = bignum[i];\n        for (let j = 0; j < result.length; ++j) {\n            const x = ((result[j] - '0'.charCodeAt(0)) << 8) + carry;\n            result[j] = '0'.charCodeAt(0) + x % 10;\n            carry = (x / 10) | 0;\n        }\n        while (carry) {\n            result.push('0'.charCodeAt(0) + carry % 10);\n            carry = (carry / 10) | 0;\n        }\n     }\n     result.reverse();\n     return String.fromCharCode(...result);\n };\n \n /**\n  * Convert `bignum` to a signed decimal number\n  *\n  * @param minDigits 0-pad result to this many digits\n  */\nexport const signedBinaryToDecimal = (bignum: Uint8Array, minDigits = 1): string => {\n    if (isNegative(bignum)) {\n         const x = bignum.slice();\n         negate(x);\n         return '-' + binaryToDecimal(x, minDigits);\n     }\n     return binaryToDecimal(bignum, minDigits);\n };\n \nconst base58ToBinaryVarSize = (s: string): Uint8Array => {\n    const result = [] as number[];\n    for (let i = 0; i < s.length; ++i) {\n        let carry = base58Map[s.charCodeAt(i)];\n        if (carry < 0) {\n            throw new Error('invalid base-58 value');\n        }\n        for (let j = 0; j < result.length; ++j) {\n            const x = result[j] * 58 + carry;\n            result[j] = x & 0xff;\n            carry = x >> 8;\n        }\n        if (carry) {\n            result.push(carry);\n        }\n    }\n    for (const ch of s) {\n        if (ch === '1') {\n            result.push(0);\n        } else {\n            break;\n        }\n    }\n    result.reverse();\n    return new Uint8Array(result);\n };\n \n /**\n  * Convert an unsigned base-58 number in `s` to a bignum\n  *\n  * @param size bignum size (bytes)\n  */\nexport const base58ToBinary = (size: number, s: string): Uint8Array => {\n    if (!size) {\n        return base58ToBinaryVarSize(s);\n    }\n    const result = new Uint8Array(size);\n    for (let i = 0; i < s.length; ++i) {\n        let carry = base58Map[s.charCodeAt(i)];\n        if (carry < 0) {\n            throw new Error('invalid base-58 value');\n        }\n        for (let j = 0; j < size; ++j) {\n            const x = result[j] * 58 + carry;\n            result[j] = x;\n            carry = x >> 8;\n        }\n        if (carry) {\n            throw new Error('base-58 value is out of range');\n        }\n    }\n    result.reverse();\n    return result;\n };\n \n /**\n  * Convert `bignum` to a base-58 number\n  *\n  * @param minDigits 0-pad result to this many digits\n  */\nexport const binaryToBase58 = (bignum: Uint8Array): string => {\n    const result = [] as number[];\n    for (const byte of bignum) {\n        let carry = byte;\n        for (let j = 0; j < result.length; ++j) {\n            const x = (base58Map[result[j]] << 8) + carry;\n            result[j] = base58Chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry) {\n            result.push(base58Chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bignum) {\n        if (byte) {\n            break;\n        } else {\n            result.push('1'.charCodeAt(0));\n        }\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n };\n \n /** Convert an unsigned base-64 number in `s` to a bignum */\nexport const base64ToBinary = (s: string): Uint8Array => {\n     let len = s.length;\n     if ((len & 3) === 1 && s[len - 1] === '=') {\n         len -= 1;\n     } // fc appends an extra '='\n     if ((len & 3) !== 0) {\n         throw new Error('base-64 value is not padded correctly');\n     }\n     const groups = len >> 2;\n     let bytes = groups * 3;\n     if (len > 0 && s[len - 1] === '=') {\n         if (s[len - 2] === '=') {\n             bytes -= 2;\n         } else {\n             bytes -= 1;\n         }\n     }\n     const result = new Uint8Array(bytes);\n \n     for (let group = 0; group < groups; ++group) {\n         const digit0 = base64Map[s.charCodeAt(group * 4 + 0)];\n         const digit1 = base64Map[s.charCodeAt(group * 4 + 1)];\n         const digit2 = base64Map[s.charCodeAt(group * 4 + 2)];\n         const digit3 = base64Map[s.charCodeAt(group * 4 + 3)];\n         result[group * 3 + 0] = (digit0 << 2) | (digit1 >> 4);\n         if (group * 3 + 1 < bytes) {\n             result[group * 3 + 1] = ((digit1 & 15) << 4) | (digit2 >> 2);\n         }\n         if (group * 3 + 2 < bytes) {\n             result[group * 3 + 2] = ((digit2 & 3) << 6) | digit3;\n         }\n     }\n     return result;\n };\n \n /** Key types this library supports */\n export enum KeyType {\n     k1 = 0,\n     r1 = 1,\n     wa = 2,\n     rsa = 100,\n     eth = 101\n }\n \n /** Public key data size, excluding type field */\n export const publicKeyDataSize = 33;\n \n /** Private key data size, excluding type field */\n export const privateKeyDataSize = 32;\n \n /** Signature data size, excluding type field */\n export const signatureDataSize = 65;\n \n /** Public key, private key, or signature in binary form */\n export interface Key {\n     type: KeyType;\n     data: Uint8Array;\n }\n \nconst digestSuffixRipemd160 = (data: Uint8Array, suffix: string): ArrayBuffer => {\n    const d = new Uint8Array(data.length + suffix.length);\n    for (let i = 0; i < data.length; ++i) {\n        d[i] = data[i];\n    }\n    for (let i = 0; i < suffix.length; ++i) {\n        d[data.length + i] = suffix.charCodeAt(i);\n    }\n    return ripemd160(d);\n};\n \n const stringToKey = (s: string, type: KeyType, size: number, suffix: string): Key => {\n     const whole = base58ToBinary(size ? size + 4 : 0, s);\n     const result = { type, data: new Uint8Array(whole.buffer, 0, whole.length - 4) };\n     const digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));\n     if (\n        digest[0] !== whole[whole.length - 4] ||\n        digest[1] !== whole[whole.length - 3] ||\n        digest[2] !== whole[whole.length - 2] ||\n        digest[3] !== whole[whole.length - 1]\n     ) {\n        throw new Error('checksum doesn\\'t match');\n     }\n     return result;\n };\n \nconst keyToString = (key: Key, suffix: string, prefix: string): string => {\n    const digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));\n    const whole = new Uint8Array(key.data.length + 4);\n    for (let i = 0; i < key.data.length; ++i) {\n        whole[i] = key.data[i];\n    }\n    for (let i = 0; i < 4; ++i) {\n        whole[i + key.data.length] = digest[i];\n    }\n    return prefix + binaryToBase58(whole);\n};\n \n /** Convert key in `s` to binary form */\n export const stringToPublicKey = (s: string, prefix = 'EOS'): Key => {\n     if (typeof s !== 'string') {\n         throw new Error('expected string containing public key');\n     }\n     if (s.substr(0, 3) === prefix) {\n         const whole = base58ToBinary(publicKeyDataSize + 4, s.substr(3));\n         const key = { type: KeyType.k1, data: new Uint8Array(publicKeyDataSize) };\n         for (let i = 0; i < publicKeyDataSize; ++i) {\n             key.data[i] = whole[i];\n         }\n         const digest = new Uint8Array(ripemd160(key.data));\n         if (digest[0] !== whole[publicKeyDataSize] || digest[1] !== whole[34]\n             || digest[2] !== whole[35] || digest[3] !== whole[36]) {\n             throw new Error('checksum doesn\\'t match');\n         }\n         return key;\n     } else if (s.substr(0, 7) === 'PUB_K1_') {\n         return stringToKey(s.substr(7), KeyType.k1, publicKeyDataSize, 'K1');\n     } else if (s.substr(0, 7) === 'PUB_R1_') {\n         return stringToKey(s.substr(7), KeyType.r1, publicKeyDataSize, 'R1');\n     } else if (s.substr(0, 7) === 'PUB_WA_') {\n         return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** Convert public `key` to legacy string (base-58) form */\n export const publicKeyToLegacyString = (key: Key, prefix: string = 'EOS') => {\n     if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {\n         return keyToString(key, '', prefix);\n     } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {\n         throw new Error('Key format not supported in legacy conversion');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** Convert `key` to string (base-58) form */\n export const publicKeyToString = (key: Key): string => {\n    if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {\n         return keyToString(key, 'K1', 'PUB_K1_');\n     } else if (key.type === KeyType.r1 && key.data.length === publicKeyDataSize) {\n         return keyToString(key, 'R1', 'PUB_R1_');\n     } else if (key.type === KeyType.wa) {\n         return keyToString(key, 'WA', 'PUB_WA_');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n  * Leaves other formats untouched\n  */\n export const convertLegacyPublicKey = (s: string, prefix = 'EOS'): string => {\n     if (s.substr(0, 3) === prefix) {\n         return publicKeyToString(stringToPublicKey(s, prefix));\n     }\n     return s;\n };\n \n /** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n  * Leaves other formats untouched\n  */\n export const convertLegacyPublicKeys = (keys: string[], prefix = 'EOS'): string[] => {\n     return keys.map((key: string) => convertLegacyPublicKey(key, prefix));\n };\n \n /** Convert key in `s` to binary form */\n export const stringToPrivateKey = (s: string): Key => {\n     if (typeof s !== 'string') {\n         throw new Error('expected string containing private key');\n     }\n     if (s.substr(0, 7) === 'PVT_R1_') {\n         return stringToKey(s.substr(7), KeyType.r1, privateKeyDataSize, 'R1');\n     } else if (s.substr(0, 7) === 'PVT_K1_') {\n         return stringToKey(s.substr(7), KeyType.k1, privateKeyDataSize, 'K1');\n     } else {\n         // todo: Verify checksum: sha256(sha256(key.data)).\n         //       Not critical since a bad key will fail to produce a\n         //       valid signature anyway.\n         const whole = base58ToBinary(privateKeyDataSize + 5, s);\n         const key = { type: KeyType.k1, data: new Uint8Array(privateKeyDataSize) };\n         if (whole[0] !== 0x80) {\n             throw new Error('unrecognized private key type');\n         }\n         for (let i = 0; i < privateKeyDataSize; ++i) {\n             key.data[i] = whole[i + 1];\n         }\n         return key;\n     }\n };\n \n /** Convert private `key` to legacy string (base-58) form */\n export const privateKeyToLegacyString = (key: Key): string => {\n     if (key.type === KeyType.k1 && key.data.length === privateKeyDataSize) {\n         const whole = [] as number[];\n         whole.push(128);\n         key.data.forEach((byte) => whole.push(byte));\n         const digest = new Uint8Array(\n             sha256().update(\n                 sha256().update(whole).digest()\n             ).digest()\n         );\n \n         const result = new Uint8Array(privateKeyDataSize + 5);\n         for (let i = 0; i < whole.length; i++) {\n             result[i] = whole[i];\n         }\n         for (let i = 0; i < 4; i++) {\n             result[i + whole.length] = digest[i];\n         }\n         return binaryToBase58(result);\n     } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {\n         throw new Error('Key format not supported in legacy conversion');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** Convert `key` to string (base-58) form */\n export const privateKeyToString = (key: Key): string => {\n     if (key.type === KeyType.r1) {\n         return keyToString(key, 'R1', 'PVT_R1_');\n     } else if (key.type === KeyType.k1) {\n         return keyToString(key, 'K1', 'PVT_K1_');\n     } else {\n         throw new Error('unrecognized private key format');\n     }\n };\n \n /** Convert key in `s` to binary form */\n export const stringToSignature = (s: string): Key => {\n     if (typeof s !== 'string') {\n         throw new Error('expected string containing signature');\n     }\n     if (s.substr(0, 7) === 'SIG_K1_') {\n         return stringToKey(s.substr(7), KeyType.k1, signatureDataSize, 'K1');\n     } else if (s.substr(0, 7) === 'SIG_R1_') {\n         return stringToKey(s.substr(7), KeyType.r1, signatureDataSize, 'R1');\n     } else if (s.substr(0, 7) === 'SIG_WA_') {\n         return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');\n     } else {\n         throw new Error('unrecognized signature format');\n     }\n };\n \n /** Convert `signature` to string (base-58) form */\n export const signatureToString = (signature: Key): string => {\n     if (signature.type === KeyType.k1) {\n         return keyToString(signature, 'K1', 'SIG_K1_');\n     } else if (signature.type === KeyType.r1) {\n         return keyToString(signature, 'R1', 'SIG_R1_');\n     } else if (signature.type === KeyType.wa) {\n         return keyToString(signature, 'WA', 'SIG_WA_');\n     } else {\n         throw new Error('unrecognized signature format');\n     }\n };\n ","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","/**\n * @module Serialize\n */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable jsdoc/check-indentation */\n\nimport * as numeric from './numeric';\nimport { Abi, BlockTaposInfo } from '../rpc/types';\nimport { Query, TransactionHeader } from './types';\nimport 'fast-text-encoding';\n\n/** A field in an abi */\nexport interface Field {\n    /** Field name */\n    name: string;\n\n    /** Type name in string form */\n    typeName: string;\n\n    /** Type of the field */\n    type?: Type;\n}\n\n/** Options for serialize() and deserialize() */\nexport interface SerializerOptions {\n    bytesAsUint8Array?: boolean;\n}\n\n/** State for serialize() and deserialize() */\nexport class SerializerState {\n    public options: SerializerOptions;\n\n    /** Have any binary extensions been skipped? */\n    public skippedBinaryExtension = false;\n\n    constructor(options: SerializerOptions = {}) {\n        this.options = options;\n    }\n}\n\n/**\n * An Anyvar (non-short form) may be any of the following:\n *  * null\n *  * string\n *  * number\n *    * Caution: assumes number is int32. Use {type, value} form for other numeric types\n *  * an array of anyvar\n *  * {type, value}\n *      * type is a string matching one of the predefined types in anyvarDefs\n *      * value:\n *          * If type === 'any_object', then value is an object. The values within the object are anyvar.\n *          * If type === 'any_array', then value is an array of anyvar.\n *          * Else, value must be eosjs-compatible with the specified type (e.g. uint64 should be a string\n *            containing the value in decimal).\n *  * Other object. The values within the object are anyvar.\n *\n * The short form is more convenient, but it can't be converted back to binary (serialized).\n * Wherever the anyvar would have {type, value}, it has just the value instead.\n */\nexport type Anyvar = null | string | number | Anyvar[] | { type: string, value: any } | Record<string, unknown>;\n\ninterface AnyvarDef {\n    index: number;\n    useShortForm: boolean;\n    type: {\n        name: string,\n        serialize(buffer: SerialBuffer, value: any): void,\n        deserialize(buffer: SerialBuffer, state?: SerializerState): any,\n    };\n}\n\n/** A type in an abi */\nexport interface Type {\n    /** Type name */\n    name: string;\n\n    /** Type name this is an alias of, if any */\n    aliasOfName: string;\n\n    /** Type this is an array of, if any */\n    arrayOf?: Type;\n\n    /** Type this is an optional of, if any */\n    optionalOf?: Type;\n\n    /** Marks binary extension fields */\n    extensionOf?: Type;\n\n    /** Base name of this type, if this is a struct */\n    baseName: string;\n\n    /** Base of this type, if this is a struct */\n    base?: Type;\n\n    /** Contained fields, if this is a struct */\n    fields: Field[];\n\n    /** Convert `data` to binary form and store in `buffer` */\n    serialize: (buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean) => void;\n\n    /** Convert data in `buffer` from binary form */\n    deserialize: (buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) => any;\n}\n\n/** Structural representation of a symbol */\nexport interface Symbol {\n    /** Name of the symbol, not including precision */\n    name: string;\n\n    /** Number of digits after the decimal point */\n    precision: number;\n}\n\nexport interface Contract {\n    actions: Map<string, Type>;\n    types: Map<string, Type>;\n}\n\nexport interface Authorization {\n    actor: string;\n    permission: string;\n}\n\n/** Action with data in structured form */\nexport interface Action {\n    account: string;\n    name: string;\n    authorization: Authorization[];\n    data: any;\n    hex_data?: string;\n}\n\n/** Action with data in serialized hex form */\nexport interface SerializedAction {\n    account: string;\n    name: string;\n    authorization: Authorization[];\n    data: string;\n}\n\n/** Serialize and deserialize data */\nexport class SerialBuffer {\n    /** Amount of valid data in `array` */\n    public length: number;\n\n    /** Data in serialized (binary) form */\n    public array: Uint8Array;\n\n    /** Current position while reading (deserializing) */\n    public readPos = 0;\n\n    public textEncoder: TextEncoder;\n    public textDecoder: TextDecoder;\n\n    /**\n     * @param __namedParameters\n     * `array`: `null` if serializing, or binary data to deserialize\n     * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser\n     * `textDecoder`: `TextDecider` instance to use. Pass in `null` if running in a browser\n     */\n    constructor({ array, textEncoder, textDecoder } = {} as { array?: Uint8Array, textEncoder?: TextEncoder, textDecoder?: TextDecoder }) {\n        this.array = array || new Uint8Array(1024);\n        this.length = array ? array.length : 0;\n        this.textEncoder = textEncoder || new TextEncoder()\n        this.textDecoder = textDecoder || new TextDecoder('utf-8')\n    }\n\n    /** Resize `array` if needed to have at least `size` bytes free */\n    public reserve(size: number): void {\n        if (this.length + size <= this.array.length) {\n            return;\n        }\n        let l = this.array.length;\n        while (this.length + size > l) {\n            l = Math.ceil(l * 1.5);\n        }\n        const newArray = new Uint8Array(l);\n        newArray.set(this.array);\n        this.array = newArray;\n    }\n\n    /** Is there data available to read? */\n    public haveReadData(): boolean {\n        return this.readPos < this.length;\n    }\n\n    /** Restart reading from the beginning */\n    public restartRead(): void {\n        this.readPos = 0;\n    }\n\n    /** Return data with excess storage trimmed away */\n    public asUint8Array(): Uint8Array {\n        return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);\n    }\n\n    /** Append bytes */\n    public pushArray(v: number[] | Uint8Array): void {\n        this.reserve(v.length);\n        this.array.set(v, this.length);\n        this.length += v.length;\n    }\n\n    /** Append bytes */\n    public push(...v: number[]): void {\n        this.pushArray(v);\n    }\n\n    /** Get a single byte */\n    public get(): number {\n        if (this.readPos < this.length) {\n            return this.array[this.readPos++];\n        }\n        throw new Error('Read past end of buffer');\n    }\n\n    /** Append bytes in `v`. Throws if `len` doesn't match `v.length` */\n    public pushUint8ArrayChecked(v: Uint8Array, len: number): void {\n        if (v.length !== len) {\n            throw new Error('Binary data has incorrect size');\n        }\n        this.pushArray(v);\n    }\n\n    /** Get `len` bytes */\n    public getUint8Array(len: number): Uint8Array {\n        if (this.readPos + len > this.length) {\n            throw new Error('Read past end of buffer');\n        }\n        const result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);\n        this.readPos += len;\n        return result;\n    }\n\n    /** Skip `len` bytes */\n    public skip(len: number): void {\n        if (this.readPos + len > this.length) {\n            throw new Error('Read past end of buffer');\n        }\n        this.readPos += len;\n    }\n\n    /** Append a `uint16` */\n    public pushUint16(v: number): void {\n        this.push((v >> 0) & 0xff, (v >> 8) & 0xff);\n    }\n\n    /** Get a `uint16` */\n    public getUint16(): number {\n        let v = 0;\n        v |= this.get() << 0;\n        v |= this.get() << 8;\n        return v;\n    }\n\n    /** Append a `uint32` */\n    public pushUint32(v: number): void {\n        this.push((v >> 0) & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff);\n    }\n\n    /** Get a `uint32` */\n    public getUint32(): number {\n        let v = 0;\n        v |= this.get() << 0;\n        v |= this.get() << 8;\n        v |= this.get() << 16;\n        v |= this.get() << 24;\n        return v >>> 0;\n    }\n\n    /** Append a `uint64`. *Caution*: `number` only has 53 bits of precision */\n    public pushNumberAsUint64(v: number): void {\n        this.pushUint32(v >>> 0);\n        this.pushUint32(Math.floor(v / 0x10000_0000) >>> 0);\n    }\n\n    /**\n     * Get a `uint64` as a `number`. *Caution*: `number` only has 53 bits of precision; some values will change.\n     * `numeric.binaryToDecimal(serialBuffer.getUint8Array(8))` recommended instead\n     */\n    public getUint64AsNumber(): number {\n        const low = this.getUint32();\n        const high = this.getUint32();\n        return (high >>> 0) * 0x10000_0000 + (low >>> 0);\n    }\n\n    /** Append a `varuint32` */\n    public pushVaruint32(v: number): void {\n        while (true) {\n            if (v >>> 7) {\n                this.push(0x80 | (v & 0x7f));\n                v = v >>> 7;\n            } else {\n                this.push(v);\n                break;\n            }\n        }\n    }\n\n    /** Get a `varuint32` */\n    public getVaruint32(): number {\n        let v = 0;\n        let bit = 0;\n        while (true) {\n            const b = this.get();\n            v |= (b & 0x7f) << bit;\n            bit += 7;\n            if (!(b & 0x80)) {\n                break;\n            }\n        }\n        return v >>> 0;\n    }\n\n    /** Append a `varint32` */\n    public pushVarint32(v: number): void {\n        this.pushVaruint32((v << 1) ^ (v >> 31));\n    }\n\n    /** Get a `varint32` */\n    public getVarint32(): number {\n        const v = this.getVaruint32();\n        if (v & 1) {\n            return ((~v) >> 1) | 0x8000_0000;\n        } else {\n            return v >>> 1;\n        }\n    }\n\n    /** Append a `float32` */\n    public pushFloat32(v: number): void {\n        this.pushArray(new Uint8Array((new Float32Array([v])).buffer));\n    }\n\n    /** Get a `float32` */\n    public getFloat32(): number {\n        return new Float32Array(this.getUint8Array(4).slice().buffer)[0];\n    }\n\n    /** Append a `float64` */\n    public pushFloat64(v: number): void {\n        this.pushArray(new Uint8Array((new Float64Array([v])).buffer));\n    }\n\n    /** Get a `float64` */\n    public getFloat64(): number {\n        return new Float64Array(this.getUint8Array(8).slice().buffer)[0];\n    }\n\n    /** Append a `name` */\n    public pushName(s: string): void {\n        if (typeof s !== 'string') {\n            throw new Error('Expected string containing name');\n        }\n        const regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);\n        if (!regex.test(s)) {\n            throw new Error('Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz'); // eslint-disable-line\n        }\n        const charToSymbol = (c: number): number => {\n            if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {\n                return (c - 'a'.charCodeAt(0)) + 6;\n            }\n            if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {\n                return (c - '1'.charCodeAt(0)) + 1;\n            }\n            return 0;\n        };\n        const a = new Uint8Array(8);\n        let bit = 63;\n        for (let i = 0; i < s.length; ++i) {\n            let c = charToSymbol(s.charCodeAt(i));\n            if (bit < 5) {\n                c = c << 1;\n            }\n            for (let j = 4; j >= 0; --j) {\n                if (bit >= 0) {\n                    a[Math.floor(bit / 8)] |= ((c >> j) & 1) << (bit % 8);\n                    --bit;\n                }\n            }\n        }\n        this.pushArray(a);\n    }\n\n    /** Get a `name` */\n    public getName(): string {\n        const a = this.getUint8Array(8);\n        let result = '';\n        for (let bit = 63; bit >= 0;) {\n            let c = 0;\n            for (let i = 0; i < 5; ++i) {\n                if (bit >= 0) {\n                    c = (c << 1) | ((a[Math.floor(bit / 8)] >> (bit % 8)) & 1);\n                    --bit;\n                }\n            }\n            if (c >= 6) {\n                result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);\n            } else if (c >= 1) {\n                result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);\n            } else {\n                result += '.';\n            }\n        }\n        while (result.endsWith('.')) {\n            result = result.substr(0, result.length - 1);\n        }\n        return result;\n    }\n\n    /** Append length-prefixed binary data */\n    public pushBytes(v: number[] | Uint8Array): void {\n        this.pushVaruint32(v.length);\n        this.pushArray(v);\n    }\n\n    /** Get length-prefixed binary data */\n    public getBytes(): Uint8Array {\n        return this.getUint8Array(this.getVaruint32());\n    }\n\n    /** Append a string */\n    public pushString(v: string): void {\n        this.pushBytes(this.textEncoder.encode(v));\n    }\n\n    /** Get a string */\n    public getString(): string {\n        return this.textDecoder.decode(this.getBytes());\n    }\n\n    /** Append a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n    public pushSymbolCode(name: string): void {\n        if (typeof name !== 'string') {\n            throw new Error('Expected string containing symbol_code');\n        }\n        const a = [];\n        a.push(...this.textEncoder.encode(name));\n        while (a.length < 8) {\n            a.push(0);\n        }\n        this.pushArray(a.slice(0, 8));\n    }\n\n    /** Get a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n    public getSymbolCode(): string {\n        const a = this.getUint8Array(8);\n        let len;\n        for (len = 0; len < a.length; ++len) {\n            if (!a[len]) {\n                break;\n            }\n        }\n        const name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n        return name;\n    }\n\n    /** Append a `symbol` */\n    public pushSymbol({ name, precision }: { name: string, precision: number }): void {\n        if (!/^[A-Z]{1,7}$/.test(name)) {\n            throw new Error('Expected symbol to be A-Z and between one and seven characters');\n        }\n        const a = [precision & 0xff];\n        a.push(...this.textEncoder.encode(name));\n        while (a.length < 8) {\n            a.push(0);\n        }\n        this.pushArray(a.slice(0, 8));\n    }\n\n    /** Get a `symbol` */\n    public getSymbol(): { name: string, precision: number } {\n        const precision = this.get();\n        const a = this.getUint8Array(7);\n        let len;\n        for (len = 0; len < a.length; ++len) {\n            if (!a[len]) {\n                break;\n            }\n        }\n        const name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n        return { name, precision };\n    }\n\n    /** Append an asset */\n    public pushAsset(s: string): void {\n        if (typeof s !== 'string') {\n            throw new Error('Expected string containing asset');\n        }\n        s = s.trim();\n        let pos = 0;\n        let amount = '';\n        let precision = 0;\n        if (s[pos] === '-') {\n            amount += '-';\n            ++pos;\n        }\n        let foundDigit = false;\n        while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n            foundDigit = true;\n            amount += s[pos];\n            ++pos;\n        }\n        if (!foundDigit) {\n            throw new Error('Asset must begin with a number');\n        }\n        if (s[pos] === '.') {\n            ++pos;\n            while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n                amount += s[pos];\n                ++precision;\n                ++pos;\n            }\n        }\n        const name = s.substr(pos).trim();\n        this.pushArray(numeric.signedDecimalToBinary(8, amount));\n        this.pushSymbol({ name, precision });\n    }\n\n    /** Get an asset */\n    public getAsset(): string {\n        const amount = this.getUint8Array(8);\n        const { name, precision } = this.getSymbol();\n        let s = numeric.signedBinaryToDecimal(amount, precision + 1);\n        if (precision) {\n            s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);\n        }\n        return s + ' ' + name;\n    }\n\n    /** Append a public key */\n    public pushPublicKey(s: string): void {\n        const key = numeric.stringToPublicKey(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a public key */\n    public getPublicKey(): string {\n        const type = this.get();\n        let data: Uint8Array;\n        if (type === numeric.KeyType.wa) {\n            const begin = this.readPos;\n            this.skip(34);\n            this.skip(this.getVaruint32());\n            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);\n        } else {\n            data = this.getUint8Array(numeric.publicKeyDataSize);\n        }\n        return numeric.publicKeyToString({ type, data });\n    }\n\n    /** Append a private key */\n    public pushPrivateKey(s: string): void {\n        const key = numeric.stringToPrivateKey(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a private key */\n    public getPrivateKey(): string {\n        const type = this.get();\n        const data = this.getUint8Array(numeric.privateKeyDataSize);\n        return numeric.privateKeyToString({ type, data });\n    }\n\n    /** Append a signature */\n    public pushSignature(s: string): void {\n        const key = numeric.stringToSignature(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a signature */\n    public getSignature(): string {\n        const type = this.get();\n        let data: Uint8Array;\n        if (type === numeric.KeyType.wa) {\n            const begin = this.readPos;\n            this.skip(65);\n            this.skip(this.getVaruint32());\n            this.skip(this.getVaruint32());\n            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);\n        } else {\n            data = this.getUint8Array(numeric.signatureDataSize);\n        }\n        return numeric.signatureToString({ type, data });\n    }\n} // SerialBuffer\n\n/** Is this a supported ABI version? */\nexport const supportedAbiVersion = (version: string): boolean => {\n    return version.startsWith('eosio::abi/1.');\n};\n\nconst checkDateParse = (date: string): number => {\n    const result = Date.parse(date);\n    if (Number.isNaN(result)) {\n        throw new Error('Invalid time format');\n    }\n    return result;\n};\n\n/** Convert date in ISO format to `time_point` (miliseconds since epoch) */\nexport const dateToTimePoint = (date: string): number => {\n    return Math.round(checkDateParse(date + 'Z') * 1000);\n};\n\n/** Convert `time_point` (miliseconds since epoch) to date in ISO format */\nexport const timePointToDate = (us: number): string => {\n    const s = (new Date(us / 1000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert date in ISO format to `time_point_sec` (seconds since epoch) */\nexport const dateToTimePointSec = (date: string): number => {\n    return Math.round(checkDateParse(date + 'Z') / 1000);\n};\n\n/** Convert `time_point_sec` (seconds since epoch) to to date in ISO format */\nexport const timePointSecToDate = (sec: number): string => {\n    const s = (new Date(sec * 1000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert date in ISO format to `block_timestamp_type` (half-seconds since a different epoch) */\nexport const dateToBlockTimestamp = (date: string): number => {\n    return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);\n};\n\n/** Convert `block_timestamp_type` (half-seconds since a different epoch) to to date in ISO format */\nexport const blockTimestampToDate = (slot: number): string => {\n    const s = (new Date(slot * 500 + 946684800000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert `string` to `Symbol`. format: `precision,NAME`. */\nexport const stringToSymbol = (s: string): { name: string, precision: number } => {\n    if (typeof s !== 'string') {\n        throw new Error('Expected string containing symbol');\n    }\n    const m = s.match(/^([0-9]+),([A-Z]+)$/);\n    if (!m) {\n        throw new Error('Invalid symbol');\n    }\n    return { name: m[2], precision: +m[1] };\n};\n\n/** Convert `Symbol` to `string`. format: `precision,NAME`. */\nexport const symbolToString = ({ name, precision }: { name: string, precision: number }): string => {\n    return precision + ',' + name;\n};\n\n/** Convert binary data to hex */\nexport const arrayToHex = (data: Uint8Array): string => {\n    let result = '';\n    for (const x of data) {\n        result += ('00' + x.toString(16)).slice(-2);\n    }\n    return result.toUpperCase();\n};\n\n/** Convert hex to binary data */\nexport const hexToUint8Array = (hex: string): Uint8Array => {\n    if (typeof hex !== 'string') {\n        throw new Error('Expected string containing hex digits');\n    }\n    if (hex.length % 2) {\n        throw new Error('Odd number of hex digits');\n    }\n    const l = hex.length / 2;\n    const result = new Uint8Array(l);\n    for (let i = 0; i < l; ++i) {\n        const x = parseInt(hex.substr(i * 2, 2), 16);\n        if (Number.isNaN(x)) {\n            throw new Error('Expected hex string');\n        }\n        result[i] = x;\n    }\n    return result;\n};\n\nfunction serializeUnknown(this: Type, _: SerialBuffer, __: any): SerialBuffer {\n    throw new Error('Don\\'t know how to serialize ' + this.name);\n}\n\nfunction deserializeUnknown(this: Type, _: SerialBuffer): SerialBuffer {\n    throw new Error('Don\\'t know how to deserialize ' + this.name);\n}\n\nfunction serializeStruct(\n    this: Type, buffer: SerialBuffer, data: any, state = new SerializerState(), allowExtensions = true\n): void {\n    if (typeof data !== 'object') {\n        throw new Error('expected object containing data: ' + JSON.stringify(data));\n    }\n    if (this.base) {\n        this.base.serialize(buffer, data, state, allowExtensions);\n    }\n    for (const field of this.fields) {\n        if (field.name in data) {\n            if (state.skippedBinaryExtension) {\n                throw new Error('unexpected ' + this.name + '.' + field.name);\n            }\n            field.type!.serialize(\n                buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);\n        } else {\n            if (allowExtensions && field.type!.extensionOf) {\n                state.skippedBinaryExtension = true;\n            } else {\n                throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type!.name + ')');\n            }\n        }\n    }\n}\n\nfunction deserializeStruct(this: Type, buffer: SerialBuffer, state = new SerializerState(), allowExtensions = true): any {\n    let result;\n    if (this.base) {\n        result = this.base.deserialize(buffer, state, allowExtensions);\n    } else {\n        result = {};\n    }\n    for (const field of this.fields) {\n        if (allowExtensions && field.type!.extensionOf && !buffer.haveReadData()) {\n            state.skippedBinaryExtension = true;\n        } else {\n            result[field.name] = field.type!.deserialize(buffer, state, allowExtensions);\n        }\n    }\n    return result;\n}\n\nfunction serializeVariant(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== 'string') {\n        throw new Error('expected variant: [\"type\", value]');\n    }\n    const i = this.fields.findIndex((field: Field) => field.name === data[0]);\n    if (i < 0) {\n        throw new Error(`type \"${data[0]}\" is not valid for variant`);\n    }\n    buffer.pushVaruint32(i);\n    this.fields[i].type!.serialize(buffer, data[1], state, allowExtensions);\n}\n\nfunction deserializeVariant(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any[] {\n    const i = buffer.getVaruint32();\n    if (i >= this.fields.length) {\n        throw new Error(`type index ${i} is not valid for variant`);\n    }\n    const field = this.fields[i];\n    return [field.name, field.type!.deserialize(buffer, state, allowExtensions)];\n}\n\nfunction serializeArray(\n    this: Type, buffer: SerialBuffer, data: any[], state?: SerializerState, _?: boolean\n): void {\n    buffer.pushVaruint32(data.length);\n    for (const item of data) {\n        this.arrayOf!.serialize(buffer, item, state, false);\n    }\n}\n\nfunction deserializeArray(this: Type, buffer: SerialBuffer, state?: SerializerState, _?: boolean): any[] {\n    const len = buffer.getVaruint32();\n    const result = [];\n    for (let i = 0; i < len; ++i) {\n        result.push(this.arrayOf!.deserialize(buffer, state, false));\n    }\n    return result;\n}\n\nfunction serializeOptional(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    if (data === null || data === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.push(1);\n        this.optionalOf!.serialize(buffer, data, state, allowExtensions);\n    }\n}\n\nfunction deserializeOptional(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    if (buffer.get()) {\n        return this.optionalOf!.deserialize(buffer, state, allowExtensions);\n    } else {\n        return null;\n    }\n}\n\nfunction serializeExtension(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    this.extensionOf!.serialize(buffer, data, state, allowExtensions);\n}\n\nfunction deserializeExtension(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    return this.extensionOf!.deserialize(buffer, state, allowExtensions);\n}\n\nfunction serializeObject(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n    ): void {\n    const entries = Object.entries(data);\n    buffer.pushVaruint32(entries.length);\n    for (const [key, value] of entries) {\n        const keyType = this.fields[0].type;\n        const dataType = this.fields[1].type;\n        keyType!.serialize(buffer, key, state, allowExtensions);\n        dataType!.serialize(buffer, value, state, allowExtensions);\n    }\n}\n\nfunction deserializeObject(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    const len = buffer.getVaruint32();\n    const result = {} as any;\n    for (let i = 0; i < len; ++i) {\n        const keyType = this.fields[0].type;\n        const dataType = this.fields[1].type;\n        const key = keyType!.deserialize(buffer, state, allowExtensions);\n        (result as any)[key] = dataType!.deserialize(buffer, state, allowExtensions);\n    }\n    return result;\n}\n\nfunction serializePair(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    buffer.pushVaruint32(data.length);\n    data.forEach((item: [number, string]) => {\n        this.fields[0].type!.serialize(buffer, item[0], state, allowExtensions);\n        this.fields[1].type!.serialize(buffer, item[1], state, allowExtensions);\n    });\n}\n\nfunction deserializePair(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    const result = [] as any;\n    const len = buffer.getVaruint32();\n    for (let i = 0; i < len; ++i) {\n        result.push(this.fields[0].type!.deserialize(buffer, state, allowExtensions));\n        result.push(this.fields[1].type!.deserialize(buffer, state, allowExtensions));\n    }\n    return result;\n}\n\ninterface CreateTypeArgs {\n    name?: string;\n    aliasOfName?: string;\n    arrayOf?: Type;\n    optionalOf?: Type;\n    extensionOf?: Type;\n    baseName?: string;\n    base?: Type;\n    fields?: Field[];\n    serialize?: (buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean) => void;\n    deserialize?: (buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) => any;\n}\n\nconst createType = (attrs: CreateTypeArgs): Type => {\n    return {\n        name: '<missing name>',\n        aliasOfName: '',\n        arrayOf: undefined,\n        optionalOf: undefined,\n        extensionOf: undefined,\n        baseName: '',\n        base: undefined,\n        fields: [],\n        serialize: serializeUnknown,\n        deserialize: deserializeUnknown,\n        ...attrs,\n    };\n};\n\nconst checkRange = (orig: number, converted: number) => {\n    if (Number.isNaN(+orig) || Number.isNaN(+converted) || (typeof orig !== 'number' && typeof orig !== 'string')) {\n        throw new Error('Expected number');\n    }\n    if (+orig !== +converted) {\n        throw new Error('Number is out of range');\n    }\n    return +orig;\n};\n\n/** Create the set of types built-in to the abi format */\nexport const createInitialTypes = (): Map<string, Type> => {\n    const result: Map<string, Type> = new Map(Object.entries({\n        bool: createType({\n            name: 'bool',\n            serialize: (buffer: SerialBuffer, data: boolean) => {\n                if ( !(typeof data === 'boolean' || typeof data === 'number' && ( data === 1 || data === 0))) {\n                    throw new Error('Expected boolean or number equal to 1 or 0');\n                }\n                buffer.push(data ? 1 : 0);\n            },\n            deserialize: (buffer: SerialBuffer) => { return !!buffer.get(); },\n        }),\n        uint8: createType({\n            name: 'uint8',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.push(checkRange(data, data & 0xff)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.get(); },\n        }),\n        int8: createType({\n            name: 'int8',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.push(checkRange(data, data << 24 >> 24)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.get() << 24 >> 24; },\n        }),\n        uint16: createType({\n            name: 'uint16',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint16(checkRange(data, data & 0xffff)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint16(); },\n        }),\n        int16: createType({\n            name: 'int16',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint16(checkRange(data, data << 16 >> 16)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint16() << 16 >> 16; },\n        }),\n        uint32: createType({\n            name: 'uint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint32(checkRange(data, data >>> 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint32(); },\n        }),\n        uint64: createType({\n            name: 'uint64',\n            serialize: (buffer: SerialBuffer, data: string | number) => {\n                buffer.pushArray(numeric.decimalToBinary(8, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.binaryToDecimal(buffer.getUint8Array(8)); },\n        }),\n        int64: createType({\n            name: 'int64',\n            serialize: (buffer: SerialBuffer, data: string | number) => {\n                buffer.pushArray(numeric.signedDecimalToBinary(8, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.signedBinaryToDecimal(buffer.getUint8Array(8)); },\n        }),\n        int32: createType({\n            name: 'int32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint32(checkRange(data, data | 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint32() | 0; },\n        }),\n        varuint32: createType({\n            name: 'varuint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushVaruint32(checkRange(data, data >>> 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getVaruint32(); },\n        }),\n        varint32: createType({\n            name: 'varint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushVarint32(checkRange(data, data | 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getVarint32(); },\n        }),\n        uint128: createType({\n            name: 'uint128',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushArray(numeric.decimalToBinary(16, '' + data)); },\n            deserialize: (buffer: SerialBuffer) => { return numeric.binaryToDecimal(buffer.getUint8Array(16)); },\n        }),\n        int128: createType({\n            name: 'int128',\n            serialize: (buffer: SerialBuffer, data: string) => {\n                buffer.pushArray(numeric.signedDecimalToBinary(16, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.signedBinaryToDecimal(buffer.getUint8Array(16)); },\n        }),\n        float32: createType({\n            name: 'float32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushFloat32(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getFloat32(); },\n        }),\n        float64: createType({\n            name: 'float64',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushFloat64(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getFloat64(); },\n        }),\n        float128: createType({\n            name: 'float128',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(16)); },\n        }),\n\n        bytes: createType({\n            name: 'bytes',\n            serialize: (buffer: SerialBuffer, data: string | Uint8Array | number[]) => {\n                if (data instanceof Uint8Array || Array.isArray(data)) {\n                    buffer.pushBytes(data);\n                } else {\n                    buffer.pushBytes(hexToUint8Array(data));\n                }\n            },\n            deserialize: (buffer: SerialBuffer, state?: SerializerState) => {\n                if (state && state.options.bytesAsUint8Array) {\n                    return buffer.getBytes();\n                } else {\n                    return arrayToHex(buffer.getBytes());\n                }\n            },\n        }),\n        string: createType({\n            name: 'string',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushString(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getString(); },\n        }),\n        name: createType({\n            name: 'name',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushName(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getName(); },\n        }),\n        time_point: createType({\n            name: 'time_point',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushNumberAsUint64(dateToTimePoint(data)); },\n            deserialize: (buffer: SerialBuffer) => { return timePointToDate(buffer.getUint64AsNumber()); },\n        }),\n        time_point_sec: createType({\n            name: 'time_point_sec',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint32(dateToTimePointSec(data)); },\n            deserialize: (buffer: SerialBuffer) => { return timePointSecToDate(buffer.getUint32()); },\n        }),\n        block_timestamp_type: createType({\n            name: 'block_timestamp_type',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint32(dateToBlockTimestamp(data)); },\n            deserialize: (buffer: SerialBuffer) => { return blockTimestampToDate(buffer.getUint32()); },\n        }),\n        symbol_code: createType({\n            name: 'symbol_code',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSymbolCode(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getSymbolCode(); },\n        }),\n        symbol: createType({\n            name: 'symbol',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSymbol(stringToSymbol(data)); },\n            deserialize: (buffer: SerialBuffer) => { return symbolToString(buffer.getSymbol()); },\n        }),\n        asset: createType({\n            name: 'asset',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushAsset(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getAsset(); },\n        }),\n        checksum160: createType({\n            name: 'checksum160',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(20)); },\n        }),\n        checksum256: createType({\n            name: 'checksum256',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(32)); },\n        }),\n        checksum512: createType({\n            name: 'checksum512',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(64)); },\n        }),\n        public_key: createType({\n            name: 'public_key',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushPublicKey(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getPublicKey(); },\n        }),\n        private_key: createType({\n            name: 'private_key',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushPrivateKey(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getPrivateKey(); },\n        }),\n        signature: createType({\n            name: 'signature',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSignature(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getSignature(); },\n        }),\n    }));\n\n    result.set('extended_asset', createType({\n        name: 'extended_asset',\n        baseName: '',\n        fields: [\n            { name: 'quantity', typeName: 'asset', type: result.get('asset') },\n            { name: 'contract', typeName: 'name', type: result.get('name') },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n\n    return result;\n}; // createInitialTypes()\n\nexport const createAbiTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('extensions_entry', createType({\n        name: 'extensions_entry',\n        baseName: '',\n        fields: [\n            { name: 'tag', typeName: 'uint16', type: undefined },\n            { name: 'value', typeName: 'bytes', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('type_def', createType({\n        name: 'type_def',\n        baseName: '',\n        fields: [\n            { name: 'new_type_name', typeName: 'string', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('field_def', createType({\n        name: 'field_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('struct_def', createType({\n        name: 'struct_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'base', typeName: 'string', type: undefined },\n            { name: 'fields', typeName: 'field_def[]', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action_def', createType({\n        name: 'action_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined },\n            { name: 'ricardian_contract', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('table_def', createType({\n        name: 'table_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'index_type', typeName: 'string', type: undefined },\n            { name: 'key_names', typeName: 'string[]', type: undefined },\n            { name: 'key_types', typeName: 'string[]', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('clause_pair', createType({\n        name: 'clause_pair',\n        baseName: '',\n        fields: [\n            { name: 'id', typeName: 'string', type: undefined },\n            { name: 'body', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('error_message', createType({\n        name: 'error_message',\n        baseName: '',\n        fields: [\n            { name: 'error_code', typeName: 'uint64', type: undefined },\n            { name: 'error_msg', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('variant_def', createType({\n        name: 'variant_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'types', typeName: 'string[]', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action_result', createType({\n        name: 'action_result',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'result_type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('primary_key_index_def', createType({\n        name: 'primary_key_index_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('secondary_index_def', createType({\n        name: 'secondary_index_def',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'string', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('secondary_indices', createType({\n        name: 'secondary_indices',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'secondary_index_def', typeName: 'secondary_index_def', type: undefined }\n        ],\n        serialize: serializeObject,\n        deserialize: deserializeObject,\n    }));\n    initialTypes.set('kv_table_entry_def', createType({\n        name: 'kv_table_entry_def',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'string', type: undefined },\n            { name: 'primary_index', typeName: 'primary_key_index_def', type: undefined },\n            { name: 'secondary_indices', typeName: 'secondary_indices', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('kv_table', createType({\n        name: 'kv_table',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'kv_table_entry_def', typeName: 'kv_table_entry_def', type: undefined }\n        ],\n        serialize: serializeObject,\n        deserialize: deserializeObject\n    }));\n    initialTypes.set('abi_def', createType({\n        name: 'abi_def',\n        baseName: '',\n        fields: [\n            { name: 'version', typeName: 'string', type: undefined },\n            { name: 'types', typeName: 'type_def[]', type: undefined },\n            { name: 'structs', typeName: 'struct_def[]', type: undefined },\n            { name: 'actions', typeName: 'action_def[]', type: undefined },\n            { name: 'tables', typeName: 'table_def[]', type: undefined },\n            { name: 'ricardian_clauses', typeName: 'clause_pair[]', type: undefined },\n            { name: 'error_messages', typeName: 'error_message[]', type: undefined },\n            { name: 'abi_extensions', typeName: 'extensions_entry[]', type: undefined },\n            { name: 'variants', typeName: 'variant_def[]$', type: undefined },\n            { name: 'action_results', typeName: 'action_result[]$', type: undefined },\n            { name: 'kv_tables', typeName: 'kv_table$', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    return initialTypes;\n};\n\n\nexport const createTransactionExtensionTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('resource_payer', createType({\n        name: 'resource_payer',\n        baseName: '',\n        fields: [\n            { name: 'payer', typeName: 'name', type: undefined },\n            { name: 'max_net_bytes', typeName: 'uint64', type: undefined },\n            { name: 'max_cpu_us', typeName: 'uint64', type: undefined },\n            { name: 'max_memory_bytes', typeName: 'uint64', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    return initialTypes;\n};\n\nexport const createTransactionTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('permission_level', createType({\n        name: 'permission_level',\n        baseName: '',\n        fields: [\n            { name: 'actor', typeName: 'name', type: undefined },\n            { name: 'permission', typeName: 'name', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action', createType({\n        name: 'action',\n        baseName: '',\n        fields: [\n            { name: 'account', typeName: 'name', type: undefined },\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'authorization', typeName: 'permission_level[]', type: undefined },\n            { name: 'data', typeName: 'bytes', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('extension', createType({\n        name: 'extension',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'uint16', type: undefined },\n            { name: 'data', typeName: 'bytes', type: undefined },\n        ],\n        serialize: serializePair,\n        deserialize: deserializePair,\n    }));\n  \n    initialTypes.set('transaction_header', createType({\n        name: 'transaction_header',\n        baseName: '',\n        fields: [\n            { name: 'expiration', typeName: 'time_point_sec', type: undefined },\n            { name: 'ref_block_num', typeName: 'uint16', type: undefined },\n            { name: 'ref_block_prefix', typeName: 'uint32', type: undefined },\n            { name: 'max_net_usage_words', typeName: 'varuint32', type: undefined },\n            { name: 'max_cpu_usage_ms', typeName: 'uint8', type: undefined },\n            { name: 'delay_sec', typeName: 'varuint32', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('transaction', createType({\n        name: 'transaction',\n        baseName: 'transaction_header',\n        fields: [\n            { name: 'context_free_actions', typeName: 'action[]', type: undefined },\n            { name: 'actions', typeName: 'action[]', type: undefined },\n            { name: 'transaction_extensions', typeName: 'extension', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    return initialTypes;\n};\n\n/** Get type from `types` */\nexport const getType = (types: Map<string, Type>, name: string): Type => {\n    const type = types.get(name);\n    if (type && type.aliasOfName) {\n        return getType(types, type.aliasOfName);\n    }\n    if (type) {\n        return type;\n    }\n    if (name.endsWith('[]')) {\n        return createType({\n            name,\n            arrayOf: getType(types, name.substr(0, name.length - 2)),\n            serialize: serializeArray,\n            deserialize: deserializeArray,\n        });\n    }\n    if (name.endsWith('?')) {\n        return createType({\n            name,\n            optionalOf: getType(types, name.substr(0, name.length - 1)),\n            serialize: serializeOptional,\n            deserialize: deserializeOptional,\n        });\n    }\n    if (name.endsWith('$')) {\n        return createType({\n            name,\n            extensionOf: getType(types, name.substr(0, name.length - 1)),\n            serialize: serializeExtension,\n            deserialize: deserializeExtension,\n        });\n    }\n    throw new Error('Unknown type: ' + name);\n};\n\n/**\n * Get types from abi\n *\n * @param initialTypes Set of types to build on.\n * In most cases, it's best to fill this from a fresh call to `getTypesFromAbi()`.\n */\n export const getTypesFromAbi = (initialTypes: Map<string, Type>, abi?: Abi): Map<string, Type> => {\n    const types = new Map(initialTypes);\n    if (abi && abi.types) {\n        for (const { new_type_name, type } of abi.types) {\n            types.set(new_type_name,\n                createType({ name: new_type_name, aliasOfName: type }));\n        }\n    }\n    if (abi && abi.structs) {\n        for (const { name, base, fields } of abi.structs) {\n            types.set(name, createType({\n                name,\n                baseName: base,\n                fields: fields.map(({ name: n, type }) => ({ name: n, typeName: type, type: undefined })),\n                serialize: serializeStruct,\n                deserialize: deserializeStruct,\n            }));\n        }\n    }\n    if (abi && abi.variants) {\n        for (const { name, types: t } of abi.variants) {\n            types.set(name, createType({\n                name,\n                fields: t.map((s) => ({ name: s, typeName: s, type: undefined })),\n                serialize: serializeVariant,\n                deserialize: deserializeVariant,\n            }));\n        }\n    }\n    for (const [/*name*/ _, type] of types) {\n        if (type.baseName) {\n            type.base = getType(types, type.baseName);\n        }\n        for (const field of type.fields) {\n            field.type = getType(types, field.typeName);\n        }\n    }\n    return types;\n}; // getTypesFromAbi\n\nconst reverseHex = (h: string): string => {\n    return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);\n};\n\n/** TAPoS: Return transaction fields which reference `refBlock` and expire `expireSeconds` after `timestamp` */\nexport const transactionHeader = (refBlock: BlockTaposInfo, expireSeconds: number): TransactionHeader => {\n    const timestamp = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;\n    const prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);\n\n    return {\n        expiration: timePointSecToDate(dateToTimePointSec(timestamp as string) + expireSeconds),\n        ref_block_num: refBlock.block_num & 0xffff,\n        ref_block_prefix: prefix,\n    };\n};\n\n/** Convert action data to serialized form (hex) */\nexport const serializeActionData = (\n    contract: Contract, account: string, name: string, data: any\n): string => {\n    const action = contract.actions.get(name);\n    if (!action) {\n        throw new Error(`Unknown action ${name} in contract ${account}`);\n    }\n    const buffer = new SerialBuffer();\n    action.serialize(buffer, data);\n    return arrayToHex(buffer.asUint8Array());\n};\n\n/** Return action in serialized form */\nexport const serializeAction = (\n    contract: Contract, account: string, name: string, authorization: Authorization[],\n    data: any\n): SerializedAction => {\n    return {\n        account,\n        name,\n        authorization,\n        data: serializeActionData(contract, account, name, data),\n    };\n};\n\n/** Deserialize action data. If `data` is a `string`, then it's assumed to be in hex. */\nexport const deserializeActionData = (\n    contract: Contract, account: string, name: string, data: string | Uint8Array | number[],\n): any => {\n    const action = contract.actions.get(name);\n    if (typeof data === 'string') {\n        data = hexToUint8Array(data);\n    }\n    if (!action) {\n        throw new Error(`Unknown action ${name} in contract ${account}`);\n    }\n    const buffer = new SerialBuffer();\n    buffer.pushArray(data);\n    return action.deserialize(buffer);\n};\n\n/** Deserialize action. If `data` is a `string`, then it's assumed to be in hex. */\nexport const deserializeAction = (\n    contract: Contract, account: string, name: string, authorization: Authorization[],\n    data: string | Uint8Array | number[]\n): Action => {\n    return {\n        account,\n        name,\n        authorization,\n        data: deserializeActionData(contract, account, name, data),\n    };\n};\n\nexport const serializeAnyvar = (buffer: SerialBuffer, anyvar: Anyvar): void => {\n    let def: AnyvarDef;\n    let value: any;\n    if (anyvar === null) {\n        [def, value] = [anyvarDefs.null_t, anyvar] as any;\n    } else if (typeof anyvar === 'string') {\n        [def, value] = [anyvarDefs.string, anyvar] as any;\n    } else if (typeof anyvar === 'number') {\n        [def, value] = [anyvarDefs.int32, anyvar] as any;\n    } else if (anyvar instanceof Uint8Array) {\n        [def, value] = [anyvarDefs.bytes, anyvar] as any;\n    } else if (Array.isArray(anyvar)) {\n        [def, value] = [anyvarDefs.any_array, anyvar] as any;\n    } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty('type') && anyvar.hasOwnProperty('value')) {\n        [def, value] = [(anyvarDefs as any)[(anyvar as any).type] as AnyvarDef, (anyvar as any).value];\n    } else {\n        [def, value] = [anyvarDefs.any_object, anyvar] as any;\n    }\n    buffer.pushVaruint32(def.index);\n    def.type.serialize(buffer, value);\n};\n\nexport const deserializeAnyvar = (buffer: SerialBuffer, state?: SerializerState): any => {\n    const defIndex = buffer.getVaruint32();\n    if (defIndex >= anyvarDefsByIndex.length) {\n        throw new Error('Tried to deserialize unknown anyvar type');\n    }\n    const def = anyvarDefsByIndex[defIndex];\n    const value = def.type!.deserialize(buffer, state);\n    if (state && (state.options as any).useShortForm || def.useShortForm) {\n        return value;\n    } else {\n        return { type: def.type!.name, value };\n    }\n};\n\nexport const deserializeAnyvarShort = (buffer: SerialBuffer): any => {\n    return deserializeAnyvar(buffer, new SerializerState({ useShortForm: true } as any));\n};\n\nexport const serializeAnyObject = (buffer: SerialBuffer, obj: any): void => {\n    const entries = Object.entries(obj);\n    buffer.pushVaruint32(entries.length);\n    for (const [key, value] of entries) {\n        buffer.pushString(key);\n        serializeAnyvar(buffer, value as Anyvar);\n    }\n};\n\nexport const deserializeAnyObject = (buffer: SerialBuffer, state?: SerializerState): any => {\n    const len = buffer.getVaruint32();\n    const result = {};\n    for (let i = 0; i < len; ++i) {\n        let key = buffer.getString();\n        if (key in result) {\n            let j = 1;\n            while (key + '_' + j in result) {\n                ++j;\n            }\n            key = key + '_' + j;\n        }\n        (result as any)[key] = deserializeAnyvar(buffer, state);\n    }\n    return result;\n};\n\nexport const serializeAnyArray = (buffer: SerialBuffer, arr: Anyvar[]): void => {\n    buffer.pushVaruint32(arr.length);\n    for (const x of arr) {\n        serializeAnyvar(buffer, x);\n    }\n};\n\nexport const deserializeAnyArray = (buffer: SerialBuffer, state?: SerializerState): any[] => {\n    const len = buffer.getVaruint32();\n    const result = [];\n    for (let i = 0; i < len; ++i) {\n        result.push(deserializeAnyvar(buffer, state));\n    }\n    return result;\n};\n\nconst addAdditionalTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('null_t', createType({\n        name: 'null_t',\n        serialize: (_: SerialBuffer, __: Anyvar) => {},\n        deserialize: (_: SerialBuffer, __?: SerializerState) => {}\n    }));\n    initialTypes.set('any_object', createType({\n        name: 'any_object',\n        serialize: serializeAnyObject,\n        deserialize: deserializeAnyObject\n    }));\n    initialTypes.set('any_array', createType({\n        name: 'any_array',\n        serialize: serializeAnyArray,\n        deserialize: deserializeAnyArray\n    }));\n    return initialTypes;\n};\n\nconst additionalTypes = addAdditionalTypes();\n\nconst anyvarDefs = {\n    null_t: { index: 0, useShortForm: true, type: additionalTypes.get('null_t') },\n    int64: { index: 1, useShortForm: false, type: additionalTypes.get('int64') },\n    uint64: { index: 2, useShortForm: false, type: additionalTypes.get('uint64') },\n    int32: { index: 3, useShortForm: true, type: additionalTypes.get('int32') },\n    uint32: { index: 4, useShortForm: false, type: additionalTypes.get('uint32') },\n    int16: { index: 5, useShortForm: false, type: additionalTypes.get('int16') },\n    uint16: { index: 6, useShortForm: false, type: additionalTypes.get('uint16') },\n    int8: { index: 7, useShortForm: false, type: additionalTypes.get('int8') },\n    uint8: { index: 8, useShortForm: false, type: additionalTypes.get('uint8') },\n    time_point: { index: 9, useShortForm: false, type: additionalTypes.get('time_point') },\n    checksum256: { index: 10, useShortForm: false, type: additionalTypes.get('checksum256') },\n    float64: { index: 11, useShortForm: false, type: additionalTypes.get('float64') },\n    string: { index: 12, useShortForm: true, type: additionalTypes.get('string') },\n    any_object: { index: 13, useShortForm: true, type: additionalTypes.get('any_object') },\n    any_array: { index: 14, useShortForm: true, type: additionalTypes.get('any_array') },\n    bytes: { index: 15, useShortForm: false, type: additionalTypes.get('bytes') },\n    symbol: { index: 16, useShortForm: false, type: additionalTypes.get('symbol') },\n    symbol_code: { index: 17, useShortForm: false, type: additionalTypes.get('symbol_code') },\n    asset: { index: 18, useShortForm: false, type: additionalTypes.get('asset') },\n};\n\nconst anyvarDefsByIndex = [\n    anyvarDefs.null_t,\n    anyvarDefs.int64,\n    anyvarDefs.uint64,\n    anyvarDefs.int32,\n    anyvarDefs.uint32,\n    anyvarDefs.int16,\n    anyvarDefs.uint16,\n    anyvarDefs.int8,\n    anyvarDefs.uint8,\n    anyvarDefs.time_point,\n    anyvarDefs.checksum256,\n    anyvarDefs.float64,\n    anyvarDefs.string,\n    anyvarDefs.any_object,\n    anyvarDefs.any_array,\n    anyvarDefs.bytes,\n    anyvarDefs.symbol,\n    anyvarDefs.symbol_code,\n    anyvarDefs.asset,\n];\n\nexport const serializeQuery = (buffer: SerialBuffer, query: Query): void => {\n    let method: string;\n    let arg: Anyvar;\n    let filter: Query[];\n    if (typeof query === 'string') {\n        method = query;\n    } else if (Array.isArray(query) && query.length === 2) {\n        [method, filter] = query;\n    } else if (Array.isArray(query) && query.length === 3) {\n        [method, arg, filter] = query;\n    } else {\n        [method, arg, filter] = [query.method, query.arg, query.filter] as any;\n    }\n    buffer.pushString(method);\n\n    // @ts-ignore\n    if (arg === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.push(1);\n        serializeAnyvar(buffer, arg);\n    }\n\n    // @ts-ignore\n    if (filter === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.pushVaruint32(filter.length);\n        for (const q of filter) {\n            serializeQuery(buffer, q);\n        }\n    }\n};\n\nexport function b64tob64u(a: string) {\n    a = a.replace(/\\=/g, '');\n    a = a.replace(/\\+/g, '-');\n    a = a.replace(/\\//g, '_');\n    return a;\n}\n\nexport function createBaseResolvedTransaction () {\n    return {\n      expiration: new Date().toISOString().slice(0, -1),\n      ref_block_num: 0,\n      ref_block_prefix: 0,\n      max_net_usage_words: 0,\n      max_cpu_usage_ms: 0,\n      delay_sec: 0,\n      context_free_actions: [],\n      actions: [],\n      transaction_extensions: []\n    }\n}","import {ec as EC} from 'elliptic';\nimport * as hash from 'hash.js';\nimport {KeyType} from '../api/numeric';\n\n/** Construct the elliptic curve object based on key type */\nexport const constructElliptic = (type: KeyType): EC => {\n    if (type === KeyType.k1) {\n        return new EC('secp256k1');\n    }\n    return new EC('p256');\n};\n\nexport const sha256 = (data: string|Buffer): string => {\n    return hash.sha256().update(data).digest('hex');\n};\n","import { ec as EC } from 'elliptic';\nimport {\n    Key,\n    KeyType,\n    publicKeyToLegacyString,\n    publicKeyToString,\n    stringToPublicKey,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\n\n/** Represents/stores a public key and provides easy conversion for use with `elliptic` lib */\nexport class PublicKey {\n    constructor(public key: Key, private ec: EC) {}\n\n    /** Instantiate public key from an EOSIO-format public key */\n    public static fromString(publicKeyStr: string, ec?: EC): PublicKey {\n        const key = stringToPublicKey(publicKeyStr);\n        if (!ec) {\n            ec = constructElliptic(key.type);\n        }\n        return new PublicKey(key, ec);\n    }\n\n    /** Instantiate public key from an `elliptic`-format public key */\n    public static fromElliptic(publicKey: EC.KeyPair, keyType: KeyType, ec?: EC): PublicKey {\n        const x = publicKey.getPublic().getX().toArray('be', 32);\n        const y = publicKey.getPublic().getY().toArray('be', 32);\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new PublicKey({\n            type: keyType,\n            data: new Uint8Array([(y[31] & 1) ? 3 : 2].concat(x)),\n        }, ec);\n    }\n\n    /** Export public key as EOSIO-format public key */\n    public toString(): string {\n        return publicKeyToString(this.key);\n    }\n\n    /** Export public key as Legacy EOSIO-format public key */\n    public toLegacyString(prefix?: string): string {\n        return publicKeyToLegacyString(this.key, prefix);\n    }\n\n    /** Export public key as `elliptic`-format public key */\n    public toElliptic(): EC.KeyPair {\n        return this.ec.keyPair({\n            pub: Buffer.from(this.key.data),\n        });\n    }\n\n    /** Get key type from key */\n    public getType(): KeyType {\n        return this.key.type;\n    }\n\n    /** Validate a public key */\n    public isValid(): boolean {\n        try {\n            const ellipticPublicKey = this.toElliptic();\n            const validationObj = ellipticPublicKey.validate();\n            return validationObj.result;\n        } catch {\n            return false;\n        }\n    }\n}\n","import { BNInput, ec as EC } from 'elliptic';\nconst BN = require('bn.js');\n\nimport {\n    Key,\n    KeyType,\n    signatureToString,\n    stringToSignature,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\nimport { PublicKey } from './publicKey'\n\n/** Represents/stores a Signature and provides easy conversion for use with `elliptic` lib */\nexport class Signature {\n    constructor(private signature: Key, private ec: EC) {}\n\n    /** Instantiate Signature from an EOSIO-format Signature */\n    public static fromString(sig: string, ec?: EC): Signature {\n        const signature = stringToSignature(sig);\n        if (!ec) {\n            ec = constructElliptic(signature.type);\n        }\n        return new Signature(signature, ec);\n    }\n\n    /** Instantiate Signature from an `elliptic`-format Signature */\n    public static fromElliptic(ellipticSig: EC.Signature, keyType: KeyType, ec?: EC): Signature {\n        if (!ellipticSig.recoveryParam) {\n            ellipticSig.recoveryParam = 0\n        }\n\n        const r = ellipticSig.r.toArray('be', 32);\n        const s = ellipticSig.s.toArray('be', 32);\n        let eosioRecoveryParam;\n        if (keyType === KeyType.k1 || keyType === KeyType.r1) {\n            eosioRecoveryParam = ellipticSig.recoveryParam + 27;\n            if (ellipticSig.recoveryParam <= 3) {\n                eosioRecoveryParam += 4;\n            }\n        } else if (keyType === KeyType.wa) {\n            eosioRecoveryParam = ellipticSig.recoveryParam;\n        }\n        const sigData = new Uint8Array([eosioRecoveryParam].concat(r, s) as any);\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new Signature({\n            type: keyType,\n            data: sigData,\n        }, ec);\n    }\n\n    /** Export Signature as `elliptic`-format Signature\n     * NOTE: This isn't an actual elliptic-format Signature, as ec.Signature is not exported by the library.\n     * That's also why the return type is `any`.  We're *actually* returning an object with the 3 params\n     * not an ec.Signature.\n     * Further NOTE: @types/elliptic shows ec.Signature as exported; it is *not*.  Hence the `any`.\n     */\n    public toElliptic(): any {\n        const lengthOfR = 32;\n        const lengthOfS = 32;\n        const r = new BN(this.signature.data.slice(1, lengthOfR + 1));\n        const s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));\n\n        let ellipticRecoveryBitField;\n        if (this.signature.type === KeyType.k1 || this.signature.type === KeyType.r1) {\n            ellipticRecoveryBitField = this.signature.data[0] - 27;\n            if (ellipticRecoveryBitField > 3) {\n                ellipticRecoveryBitField -= 4;\n            }\n        } else if (this.signature.type === KeyType.wa) {\n            ellipticRecoveryBitField = this.signature.data[0];\n        } else {\n            ellipticRecoveryBitField = 0\n        }\n        const recoveryParam = ellipticRecoveryBitField & 3;\n        return { r, s, recoveryParam };\n    }\n\n    /** Export Signature as EOSIO-format Signature */\n    public toString(): string {\n        return signatureToString(this.signature);\n    }\n\n    /** Export Signature in binary format */\n    public toBinary(): Uint8Array {\n        return this.signature.data;\n    }\n\n    /** Get key type from signature */\n    public getType(): KeyType {\n        return this.signature.type;\n    }\n\n    /** Verify a signature with a message or hashed message digest and public key */\n    public verify(data: BNInput, publicKey: PublicKey, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): boolean {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        const ellipticSignature = this.toElliptic();\n        const ellipticPublicKey = publicKey.toElliptic();\n        return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);\n    }\n\n    /** Recover a public key from a message or hashed message digest and signature */\n    public recover(data: BNInput, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): PublicKey {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        const ellipticSignature = this.toElliptic();\n        const recoveredPublicKey = this.ec.recoverPubKey(\n            data,\n            ellipticSignature,\n            ellipticSignature.recoveryParam,\n            encoding\n        );\n        const ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);\n        return PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);\n    }\n}\n","import { BNInput, ec as EC } from 'elliptic';\nimport {\n    Key,\n    KeyType,\n    privateKeyToLegacyString,\n    privateKeyToString,\n    stringToPrivateKey,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\nimport { PublicKey } from './publicKey'\nimport { Signature } from './signature'\n\n/** Represents/stores a private key and provides easy conversion for use with `elliptic` lib */\nexport class PrivateKey {\n    constructor(private key: Key, private ec: EC) {}\n\n    /** Instantiate private key from an `elliptic`-format private key */\n    public static fromElliptic(privKey: EC.KeyPair, keyType: KeyType, ec?: EC): PrivateKey {\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new PrivateKey({\n            type: keyType,\n            data: privKey.getPrivate().toArrayLike(Buffer, 'be', 32),\n        }, ec);\n    }\n\n    /** Instantiate private key from an EOSIO-format private key */\n    public static fromString(keyString: string, ec?: EC): PrivateKey {\n        const privateKey = stringToPrivateKey(keyString);\n        if (!ec) {\n            ec = constructElliptic(privateKey.type);\n        }\n        return new PrivateKey(privateKey, ec);\n    }\n\n    /** Export private key as `elliptic`-format private key */\n    public toElliptic(): EC.KeyPair {\n        return this.ec.keyFromPrivate(this.key.data);\n    }\n\n    public toLegacyString(): string {\n        return privateKeyToLegacyString(this.key);\n    }\n\n    /** Export private key as EOSIO-format private key */\n    public toString(): string {\n        return privateKeyToString(this.key);\n    }\n\n    /** Get key type from key */\n    public getType(): KeyType {\n        return this.key.type;\n    }\n\n    /** Retrieve the public key from a private key */\n    public getPublicKey(): PublicKey {\n        const ellipticPrivateKey = this.toElliptic();\n        return PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);\n    }\n\n    /** Sign a message or hashed message digest with private key */\n    public sign(data: BNInput, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): Signature {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        let tries = 0;\n        let signature: Signature;\n        const isCanonical = (sigData: Uint8Array): boolean =>\n            !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80))\n            && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));\n        const constructSignature = (options: EC.SignOptions): Signature => {\n            const ellipticPrivateKey = this.toElliptic();\n            const ellipticSignature = ellipticPrivateKey.sign(data, options);\n            return Signature.fromElliptic(ellipticSignature, this.getType(), this.ec);\n        };\n\n        if (this.key.type === KeyType.k1) {\n            do {\n                signature = constructSignature({canonical: true, pers: [++tries]});\n            } while (!isCanonical(signature.toBinary()));\n        } else {\n            signature = constructSignature({canonical: true});\n        }\n        return signature;\n    }\n\n    /** Validate a private key */\n    public isValid(): boolean {\n        try {\n            const ellipticPrivateKey = this.toElliptic();\n            const validationObj = ellipticPrivateKey.validate();\n            return validationObj.result;\n        } catch {\n            return false;\n        }\n    }\n}\n","import { PrivateKey } from './privateKey';\nimport { PublicKey } from './publicKey';\nimport { ec as EC } from 'elliptic';\nimport {KeyType} from '../api/numeric';\n\nexport { PrivateKey } from './privateKey';\nexport { PublicKey } from './publicKey';\nexport { Signature } from './signature';\nexport { constructElliptic } from './conversions';\n\nexport const generateKeyPair = (\n    type: KeyType, options: { secureEnv?: boolean, ecOptions?: EC.GenKeyPairOptions } = {}\n): { publicKey: PublicKey, privateKey: PrivateKey } => {\n    if (!options.secureEnv) {\n        throw new Error('Key generation is completely INSECURE in production environments in the browser. ' +\n            'If you are absolutely certain this does NOT describe your environment, set `secureEnv` in your ' +\n            'options to `true`.  If this does describe your environment and you set `secureEnv` to `true`, ' +\n            'YOU DO SO AT YOUR OWN RISK AND THE RISK OF YOUR USERS.');\n    }\n    let ec;\n    if (type === KeyType.k1) {\n        ec = new EC('secp256k1') as any;\n    } else {\n        ec = new EC('p256') as any;\n    }\n    const ellipticKeyPair = ec.genKeyPair(options.ecOptions);\n    const publicKey = PublicKey.fromElliptic(ellipticKeyPair, type, ec);\n    const privateKey = PrivateKey.fromElliptic(ellipticKeyPair, type, ec);\n    return {publicKey, privateKey};\n};","/**\n * @module JS-Sig\n */\n// copyright defined in eosjs/LICENSE.txt\n\nimport { ec } from 'elliptic';\n\nimport { SignatureProvider, SignatureProviderArgs } from '../api/types';\nimport {\n    PrivateKey,\n    PublicKey,\n    Signature,\n} from './key';\nimport { convertLegacyPublicKey } from '../api/numeric';\n\n/** expensive to construct; so we do it once and reuse it */\nconst defaultEc = new ec('secp256k1');\n\n/** Construct the digest from transaction details */\nconst digestFromSerializedData = (\n    chainId: string,\n    serializedTransaction: Uint8Array,\n    serializedContextFreeData?: Uint8Array,\n    e = defaultEc) => {\n    const signBuf = Buffer.concat([\n        Buffer.from(chainId, 'hex'),\n        Buffer.from(serializedTransaction),\n        Buffer.from(\n            serializedContextFreeData ?\n                new Uint8Array(e.hash().update(serializedContextFreeData).digest()) :\n                new Uint8Array(32)\n        ),\n    ]);\n    return e.hash().update(signBuf).digest();\n};\n\n/** Signs transactions using in-process private keys */\nclass JsSignatureProvider implements SignatureProvider {\n    /** map public to private keys */\n    public keys = new Map<string, ec.KeyPair>();\n\n    /** public keys */\n    public availableKeys = [] as string[];\n\n    /** @param privateKeys private keys to sign with */\n    constructor(privateKeys: string[]) {\n        for (const k of privateKeys) {\n            const priv = PrivateKey.fromString(k);\n            const privElliptic = priv.toElliptic();\n            const pubStr = priv.getPublicKey().toString();\n            this.keys.set(pubStr, privElliptic);\n            this.availableKeys.push(pubStr);\n        }\n    }\n\n    /** Public keys associated with the private keys that the `SignatureProvider` holds */\n    public async getAvailableKeys() {\n        return this.availableKeys;\n    }\n\n    /** Sign a transaction */\n    public async sign(\n        { chainId, requiredKeys, serializedTransaction, serializedContextFreeData }: SignatureProviderArgs,\n    ) {\n        const digest = digestFromSerializedData( chainId, serializedTransaction, serializedContextFreeData, defaultEc);\n\n        const signatures = [] as string[];\n        for (const key of requiredKeys) {\n            const publicKey = PublicKey.fromString(key);\n            const ellipticPrivateKey = this.keys.get(convertLegacyPublicKey(key));\n            if (ellipticPrivateKey) {\n                const privateKey = PrivateKey.fromElliptic(ellipticPrivateKey, publicKey.getType());\n                const signature = privateKey.sign(digest, false);\n                signatures.push(signature.toString());\n            }\n        }\n\n        return { signatures, serializedTransaction, serializedContextFreeData };\n    }\n}\n\nexport {\n    PrivateKey,\n    PublicKey,\n    Signature,\n    digestFromSerializedData,\n    JsSignatureProvider,\n};\n","/* eslint-disable max-classes-per-file */\n\nimport { inflate, deflate } from 'pako';\nimport { ec } from 'elliptic';\nimport base64url from 'base64url';\nimport {\n    AbiProvider,\n    ActionSerializerType,\n    AuthorityProvider,\n    BinaryAbi,\n    CachedAbi,\n    ContextFreeGroupCallback,\n    Query,\n    QueryConfig,\n    SignatureProvider,\n    TransactConfig,\n    Transaction,\n    TransactResult,\n} from './types';\nimport { JsonRpc } from '../rpc';\nimport {\n    Abi,\n    BlockTaposInfo,\n    GetInfoResult,\n    PushTransactionArgs,\n    GetBlockHeaderStateResult,\n    GetBlockInfoResult,\n    GetBlockResult,\n    ReadOnlyTransactResult,\n    RsaKey\n} from '../rpc/types';\nimport * as ser from './serialize';\nimport { digestFromSerializedData } from '../cryptography/jsSignatureProvider'\nimport { PublicKey, Signature } from '../cryptography/key' \nimport * as Numeric from './numeric';\nimport { b64tob64u } from './serialize';\nimport { sha256 } from '../cryptography/conversions';\nimport { ApiInterfaces } from '..';\nimport type { recoverPersonalSignature as RecoverPersonalSignature } from 'eth-sig-util'\n\nexport class Api {\n    /** Issues RPC calls */\n    public rpc: JsonRpc;\n\n    /** Get subset of `availableKeys` needed to meet authorities in a `transaction` */\n    public authorityProvider: AuthorityProvider;\n\n    /** Supplies ABIs in raw form (binary) */\n    public abiProvider: AbiProvider;\n\n    /** Signs transactions */\n    public signatureProvider?: SignatureProvider;\n\n    /** Converts abi files between binary and structured form (`abi.abi.json`) */\n    public abiTypes: Map<string, ser.Type>;\n\n    /** Converts transactions between binary and structured form (`transaction.abi.json`) */\n    public transactionTypes: Map<string, ser.Type>;\n\n    /** Holds information needed to serialize contract actions */\n    public contracts = new Map<string, ser.Contract>();\n\n    /** Fetched abis */\n    public cachedAbis = new Map<string, CachedAbi>();\n\n    /** Crypto */    \n    public crypto?: Crypto\n    public recoverPersonalSignature?: typeof RecoverPersonalSignature\n\n    /**\n     * @param args\n     *    * `rpc`: Issues RPC calls\n     *    * `authorityProvider`: Get public keys needed to meet authorities in a transaction\n     *    * `abiProvider`: Supplies ABIs in raw form (binary)\n     *    * `signatureProvider`: Signs transactions\n     */\n    constructor(args: {\n        rpc: JsonRpc,\n        authorityProvider?: AuthorityProvider,\n        abiProvider?: AbiProvider,\n        signatureProvider?: SignatureProvider,\n        crypto?: Crypto,\n        recoverPersonalSignature?: typeof RecoverPersonalSignature\n    }) {\n        this.rpc = args.rpc;\n        this.authorityProvider = args.authorityProvider || args.rpc;\n        this.abiProvider = args.abiProvider || args.rpc;\n        if (args.signatureProvider) {\n            this.signatureProvider = args.signatureProvider;\n        }\n\n        this.abiTypes = ser.getTypesFromAbi(ser.createAbiTypes());\n        this.transactionTypes = ser.getTypesFromAbi(ser.createTransactionTypes());\n\n        this.crypto = args.crypto || (typeof window !== \"undefined\" && window && window.crypto) || (global && global.crypto)\n        this.recoverPersonalSignature = args.recoverPersonalSignature\n    }\n\n    getCrypto() {\n        if (!this.crypto) {\n            throw new Error(`No 'crypto' module found. On nodejs, do const { Crypto } = require('@peculiar/webcrypto'); const crypto = new Crypto; new Api({ rpc, crypto });`)\n        }\n\n        return this.crypto\n    }\n\n    getRecoverPersonalSignature() {\n        if (!this.recoverPersonalSignature) {\n            throw new Error(`No 'recoverPersonalSignature' function found. Do const { recoverPersonalSignature } = require('eth-sig-util'); new Api({ rpc, recoverPersonalSignature });`)\n        }\n\n        return this.recoverPersonalSignature\n    }\n\n    /** Decodes an abi as Uint8Array into json. */\n    public rawAbiToJson(rawAbi: Uint8Array): Abi {\n        const buffer = new ser.SerialBuffer({\n            array: rawAbi\n        });\n        if (!ser.supportedAbiVersion(buffer.getString())) {\n            throw new Error('Unsupported abi version');\n        }\n        buffer.restartRead();\n        return this.abiTypes.get('abi_def')!.deserialize(buffer);\n    }\n\n    /** Encodes a json abi as Uint8Array. */\n    public jsonToRawAbi(jsonAbi: Abi): Uint8Array {\n        const buffer = new ser.SerialBuffer();\n        this.abiTypes.get('abi_def')!.serialize(buffer, jsonAbi);\n        if (!ser.supportedAbiVersion(buffer.getString())) {\n            throw new Error('Unsupported abi version');\n        }\n        return buffer.asUint8Array();\n    }\n\n    /** Get abi in both binary and structured forms. Fetch when needed. */\n    public async getCachedAbi(accountName: string, reload = false): Promise<CachedAbi> {\n        if (!reload && this.cachedAbis.get(accountName)) {\n            return this.cachedAbis.get(accountName) as CachedAbi;\n        }\n        let cachedAbi: CachedAbi;\n        try {\n            const rawAbi = (await this.abiProvider.getRawAbi(accountName)).abi;\n            const abi = this.rawAbiToJson(rawAbi);\n            cachedAbi = { rawAbi, abi };\n        } catch (e) {\n            e.message = `fetching abi for ${accountName}: ${e.message}`;\n            throw e;\n        }\n        if (!cachedAbi) {\n            throw new Error(`Missing abi for ${accountName}`);\n        }\n        this.cachedAbis.set(accountName, cachedAbi);\n        return cachedAbi;\n    }\n\n    /** Get abi in structured form. Fetch when needed. */\n    public async getAbi(accountName: string, reload = false): Promise<Abi> {\n        return (await this.getCachedAbi(accountName, reload)).abi;\n    }\n\n    /** Get abis needed by a transaction */\n    public async getTransactionAbis(transaction: any, reload = false): Promise<BinaryAbi[]> {\n        const actions = (transaction.context_free_actions || []).concat(transaction.actions);\n        const accounts: string[] = actions.map((action: ser.Action): string => action.account);\n        const uniqueAccounts: Set<string> = new Set(accounts);\n        const actionPromises: Promise<BinaryAbi>[] = Array.from(uniqueAccounts).map(\n            async (account: string): Promise<BinaryAbi> => {\n                const { rawAbi } = await this.getCachedAbi(account, reload)\n                return {\n                    accountName: account,\n                    abi: rawAbi\n                }\n            }\n        );\n        return Promise.all(actionPromises);\n    }\n\n    /** Get data needed to serialize actions in a contract */\n    public async getContract(accountName: string, reload = false): Promise<ser.Contract> {\n        if (!reload && this.contracts.get(accountName)) {\n            return this.contracts.get(accountName) as ser.Contract;\n        }\n        const abi = await this.getAbi(accountName, reload);\n        const types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);\n        const actions = new Map<string, ser.Type>();\n        for (const { name, type } of abi.actions) {\n            actions.set(name, ser.getType(types, type));\n        }\n        const result = { types, actions };\n        this.contracts.set(accountName, result);\n        return result;\n    }\n\n    /** Convert `value` to binary form. `type` must be a built-in abi type or in `transaction.abi.json`. */\n    public serialize(buffer: ser.SerialBuffer, type: string, value: any): void {\n        this.transactionTypes.get(type)!.serialize(buffer, value);\n    }\n\n    /** Convert data in `buffer` to structured form. `type` must be a built-in abi type or in `transaction.abi.json`. */\n    public deserialize(buffer: ser.SerialBuffer, type: string): any {\n        return this.transactionTypes.get(type)!.deserialize(buffer);\n    }\n\n    /** Convert a transaction to binary */\n    public serializeTransaction(transaction: Transaction): Uint8Array {\n        const buffer = new ser.SerialBuffer();\n        this.serialize(buffer, 'transaction', {\n            max_net_usage_words: 0,\n            max_cpu_usage_ms: 0,\n            delay_sec: 0,\n            context_free_actions: [],\n            transaction_extensions: [],\n            ...transaction,\n        });\n        return buffer.asUint8Array();\n    }\n\n    /** Serialize context-free data */\n    public serializeContextFreeData(contextFreeData?: Uint8Array[]): Uint8Array | undefined {\n        if (!contextFreeData || !contextFreeData.length) {\n            return undefined;\n        }\n        const buffer = new ser.SerialBuffer();\n        buffer.pushVaruint32(contextFreeData.length);\n        for (const data of contextFreeData) {\n            buffer.pushBytes(data);\n        }\n        return buffer.asUint8Array();\n    }\n\n    /** Convert a transaction from binary. Leaves actions in hex. */\n    public deserializeTransaction(transaction: Uint8Array): Transaction {\n        const buffer = new ser.SerialBuffer();\n        buffer.pushArray(transaction);\n        return this.deserialize(buffer, 'transaction');\n    }\n\n    private transactionExtensions = [\n        { id: 1, type: 'resource_payer', keys: ['payer', 'max_net_bytes', 'max_cpu_us', 'max_memory_bytes'] },\n    ];\n\n    // Order of adding to transaction_extension is transaction_extension id ascending\n    public serializeTransactionExtensions(transaction: Transaction): [number, string][] {\n        let transaction_extensions: [number, string][] = [];\n        if (transaction.resource_payer) {\n            const extensionBuffer = new ser.SerialBuffer();\n            const types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());\n            types.get('resource_payer')!.serialize(extensionBuffer, transaction.resource_payer);\n            transaction_extensions = [...transaction_extensions, [1, ser.arrayToHex(extensionBuffer.asUint8Array())]];\n        }\n        return transaction_extensions;\n    };\n\n    // Usage: transaction = {...transaction, ...this.deserializeTransactionExtensions(transaction.transaction_extensions)}\n    public deserializeTransactionExtensions(data: [number, string][]): any[] {\n        const transaction = {} as any;\n        data.forEach((extensionData: [number, string]) => {\n            const transactionExtension = this.transactionExtensions.find(extension => extension.id === extensionData[0]);\n            if (transactionExtension === undefined) {\n                throw new Error(`Transaction Extension could not be determined: ${extensionData}`);\n            }\n            const types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());\n            const extensionBuffer = new ser.SerialBuffer();\n            extensionBuffer.pushArray(ser.hexToUint8Array(extensionData[1]));\n            const deserializedObj = types.get(transactionExtension.type)!.deserialize(extensionBuffer);\n            if (extensionData[0] === 1) {\n                deserializedObj.max_net_bytes = Number(deserializedObj.max_net_bytes);\n                deserializedObj.max_cpu_us = Number(deserializedObj.max_cpu_us);\n                deserializedObj.max_memory_bytes = Number(deserializedObj.max_memory_bytes);\n                transaction.resource_payer = deserializedObj;\n            }\n        });\n        return transaction;\n    };\n\n    // Transaction extensions are serialized and moved to `transaction_extensions`, deserialized objects are not needed on the transaction\n    public deleteTransactionExtensionObjects(transaction: Transaction): Transaction {\n        delete transaction.resource_payer;\n        return transaction;\n    }\n\n    /** Convert actions to hex */\n    public async serializeActions(actions: ser.Action[]): Promise<ser.SerializedAction[]> {\n        return await Promise.all(actions.map(async (action) => {\n            const { account, name, authorization, data } = action;\n            const contract = await this.getContract(account);\n            if (typeof data !== 'object') {\n                return action;\n            }\n            return ser.serializeAction(\n                contract, account, name, authorization, data);\n        }));\n    }\n\n    /** Convert actions from hex */\n    public async deserializeActions(actions: ser.Action[]): Promise<ser.Action[]> {\n        return await Promise.all(actions.map(async ({ account, name, authorization, data }) => {\n            const contract = await this.getContract(account);\n            return ser.deserializeAction(\n                contract, account, name, authorization, data);\n        }));\n    }\n\n    public async deserializeActionsSync(actions: ser.Action[] = []): Promise<ser.Action[]> {\n        let deserializedActions = []\n        for (const { account, name, authorization, data } of actions) {\n            const contract = await this.getContract(account);\n            deserializedActions.push(\n                ser.deserializeAction(\n                    contract, account, name, authorization, data\n                )\n            )\n        }\n        return deserializedActions\n    }\n\n    /** Convert a transaction from binary. Also deserializes actions. */\n    public async deserializeTransactionWithActions(transaction: Uint8Array | string): Promise<any> {\n        if (typeof transaction === 'string') {\n            transaction = ser.hexToUint8Array(transaction);\n        }\n        const deserializedTransaction = this.deserializeTransaction(transaction);\n        const deserializedCFActions = await this.deserializeActionsSync(deserializedTransaction.context_free_actions);\n        const deserializedActions = await this.deserializeActionsSync(deserializedTransaction.actions);\n        return {\n            ...deserializedTransaction, context_free_actions: deserializedCFActions, actions: deserializedActions\n        };\n    }\n\n    /** Deflate a serialized object */\n    public deflateSerializedArray(serializedArray: Uint8Array): Uint8Array {\n        return deflate(serializedArray, { level: 9 });\n    }\n\n    /** Inflate a compressed serialized object */\n    public inflateSerializedArray(compressedSerializedArray: Uint8Array): Uint8Array {\n        return inflate(compressedSerializedArray);\n    }\n\n    /**\n     * Create and optionally broadcast a transaction.\n     *\n     * Named Parameters:\n     * `broadcast`: broadcast this transaction?\n     * `sign`: sign this transaction?\n     * `compression`: compress this transaction?\n     * `readOnlyTrx`: read only transaction?\n     * `returnFailureTraces`: return failure traces? (only available for read only transactions currently)\n     *\n     * If both `blocksBehind` and `expireSeconds` are present,\n     * then fetch the block which is `blocksBehind` behind head block,\n     * use it as a reference for TAPoS, and expire the transaction `expireSeconds` after that block's time.\n     *\n     * If both `useLastIrreversible` and `expireSeconds` are present,\n     * then fetch the last irreversible block, use it as a reference for TAPoS,\n     * and expire the transaction `expireSeconds` after that block's time.\n     *\n     * @returns node response if `broadcast`, `{signatures, serializedTransaction}` if `!broadcast`\n     */\n    public async transact(\n        transaction: Transaction,\n        {\n            broadcast = true,\n            sign = true,\n            readOnlyTrx,\n            returnFailureTraces,\n            requiredKeys, // When you will sign later\n            compression,\n            blocksBehind,\n            useLastIrreversible,\n            expireSeconds,\n            transactionHeader\n        }:\n        TransactConfig = {}): Promise<TransactResult|ReadOnlyTransactResult|PushTransactionArgs>\n    {\n        const info: GetInfoResult = await this.rpc.get_info();;\n\n        // Calculate header if not provided\n        if (!transactionHeader) {\n            if (typeof blocksBehind === 'number' && useLastIrreversible) {\n                throw new Error('Use either blocksBehind or useLastIrreversible');\n            } else if (typeof blocksBehind !== 'number' && !useLastIrreversible) {\n                throw new Error('Must provide one blocksBehind or useLastIrreversible');\n            } else if (!expireSeconds) {\n                throw new Error('Must provide expireSeconds');\n            } else {\n                transactionHeader = await this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds);;\n            }\n\n            if (!this.hasRequiredTaposFields(transactionHeader)) {\n                throw new Error('Required configuration or TAPOS fields are not present');\n            }\n        }\n\n        const abis: BinaryAbi[] = await this.getTransactionAbis(transaction);\n        transaction = {\n            ...transactionHeader,\n            transaction_extensions: await this.serializeTransactionExtensions(transaction),\n            context_free_actions: await this.serializeActions(transaction.context_free_actions || []),\n            actions: await this.serializeActions(transaction.actions)\n        };\n        transaction = this.deleteTransactionExtensionObjects(transaction);\n        const serializedTransaction = this.serializeTransaction(transaction);\n        const serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);\n        let pushTransactionArgs: PushTransactionArgs = {\n            serializedTransaction, serializedContextFreeData, signatures: []\n        };\n\n        if (sign) {\n            if (!this.signatureProvider) {\n                throw new Error('No signature provider available')\n            }\n            \n            if (!requiredKeys) {\n                const availableKeys = await this.signatureProvider.getAvailableKeys();\n                requiredKeys = await this.authorityProvider.getRequiredKeys({ transaction, availableKeys });\n            }\n\n            pushTransactionArgs = await this.signatureProvider.sign({\n                chainId: info.chain_id,\n                requiredKeys,\n                serializedTransaction,\n                serializedContextFreeData,\n                abis,\n            });\n        }\n        if (broadcast) {\n            if (compression) {\n                return this.pushCompressedSignedTransaction(\n                    pushTransactionArgs,\n                    readOnlyTrx,\n                    returnFailureTraces,\n                ) as Promise<TransactResult|ReadOnlyTransactResult>;\n            }\n            return this.pushSignedTransaction(\n                pushTransactionArgs,\n                readOnlyTrx,\n                returnFailureTraces,\n            ) as Promise<TransactResult|ReadOnlyTransactResult>;\n        }\n        return {\n            ...pushTransactionArgs,\n            transactionHeader //\n        };\n    }\n\n    public async transactWithDelay(transaction: any, params: TransactConfig = {}, delay: number): Promise<any> {\n        async function wait (ms: number) {\n            return new Promise(resolve => {\n              setTimeout(resolve, ms);\n            });\n        }\n\n        const success = await this.transact(transaction, params)\n        await wait(delay)\n        return success\n    }\n\n    public async query(\n        account: string, short: boolean, query: Query,\n        { sign, requiredKeys, authorization = [] }: QueryConfig\n    ): Promise<any> {\n        const info = await this.rpc.get_info();\n        const refBlock = await this.tryRefBlockFromGetInfo(info);\n        const queryBuffer = new ser.SerialBuffer();\n        ser.serializeQuery(queryBuffer, query);\n\n        const transaction = {\n            ...ser.transactionHeader(refBlock, 60 * 30),\n            context_free_actions: [] as ser.Action[],\n            actions: [{\n                account,\n                name: 'queryit',\n                authorization,\n                data: ser.arrayToHex(queryBuffer.asUint8Array()),\n            }],\n        };\n\n        const serializedTransaction = this.serializeTransaction(transaction);\n        let signatures: string[] = [];\n        if (sign) {\n            if (!this.signatureProvider) {\n                throw new Error('No signature provider available')\n            }\n    \n            const abis: BinaryAbi[] = await this.getTransactionAbis(transaction);\n            if (!requiredKeys) {\n                const availableKeys = await this.signatureProvider.getAvailableKeys();\n                requiredKeys = await this.authorityProvider.getRequiredKeys({ transaction, availableKeys });\n            }\n\n            const signResponse = await this.signatureProvider.sign({\n                chainId: info.chain_id,\n                requiredKeys,\n                serializedTransaction,\n                serializedContextFreeData: undefined,\n                abis,\n            });\n\n            signatures = signResponse.signatures;\n        }\n\n        const response = await this.rpc.send_transaction({\n            signatures,\n            compression: 0,\n            serializedTransaction\n        }) as any;\n\n        const returnBuffer = new ser.SerialBuffer({\n            array: ser.hexToUint8Array(response.processed.action_traces[0][1].return_value)\n        });\n        if (short) {\n            return ser.deserializeAnyvarShort(returnBuffer);\n        } else {\n            return ser.deserializeAnyvar(returnBuffer);\n        }\n    }\n\n    /** Broadcast a signed transaction */\n    public async pushSignedTransaction(\n        { signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs,\n        readOnlyTrx = false,\n        returnFailureTraces = false,\n        ): Promise<TransactResult|ReadOnlyTransactResult> {\n            if (readOnlyTrx) {\n                return this.rpc.push_ro_transaction({\n                    signatures,\n                    serializedTransaction,\n                    serializedContextFreeData,\n                }, returnFailureTraces);\n            }\n        return this.rpc.push_transaction({\n            signatures,\n            serializedTransaction,\n            serializedContextFreeData\n        });\n    }\n\n    public async pushCompressedSignedTransaction(\n        { signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs,\n        readOnlyTrx = false,\n        returnFailureTraces = false,\n    ): Promise<TransactResult|ReadOnlyTransactResult> {\n        const compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);\n        const compressedSerializedContextFreeData =\n            this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));\n\n        if (readOnlyTrx) {\n            return this.rpc.push_ro_transaction({\n                signatures,\n                compression: 1,\n                serializedTransaction: compressedSerializedTransaction,\n                serializedContextFreeData: compressedSerializedContextFreeData\n            }, returnFailureTraces);\n        }\n        return this.rpc.push_transaction({\n            signatures,\n            compression: 1,\n            serializedTransaction: compressedSerializedTransaction,\n            serializedContextFreeData: compressedSerializedContextFreeData\n        });\n    }\n\n    public async generateTapos(\n        info: GetInfoResult | undefined,\n        transaction: Transaction,\n        blocksBehind: number = 3,\n        useLastIrreversible: boolean | undefined,\n        expireSeconds: number\n    ) {\n        if (!info) {\n            info = await this.rpc.get_info();\n        }\n        if (useLastIrreversible) {\n            const block = await this.tryRefBlockFromGetInfo(info);\n            return { ...ser.transactionHeader(block, expireSeconds), ...transaction };\n        }\n\n        const taposBlockNumber: number = info.head_block_num - blocksBehind;\n\n        const refBlock: GetBlockHeaderStateResult | GetBlockResult | GetBlockInfoResult =\n            taposBlockNumber <= info.last_irreversible_block_num\n                ? await this.tryGetBlockInfo(taposBlockNumber)\n                : await this.tryGetBlockHeaderState(taposBlockNumber);\n\n        return { ...ser.transactionHeader(refBlock, expireSeconds), ...transaction };\n    }\n\n    // eventually break out into TransactionValidator class\n    private hasRequiredTaposFields({ expiration, ref_block_num, ref_block_prefix }: Transaction): boolean {\n        return !!(expiration && typeof(ref_block_num) === 'number' && typeof(ref_block_prefix) === 'number');\n    }\n\n    private async tryGetBlockHeaderState(taposBlockNumber: number): Promise<GetBlockHeaderStateResult | GetBlockResult | GetBlockInfoResult>\n    {\n        try {\n            return await this.rpc.get_block_header_state(taposBlockNumber);\n        } catch (error) {\n            return await this.tryGetBlockInfo(taposBlockNumber);\n        }\n    }\n\n    private async tryGetBlockInfo(blockNumber: number): Promise<GetBlockInfoResult | GetBlockResult> {\n        try {\n            return await this.rpc.get_block_info(blockNumber);\n        } catch (error) {\n            return await this.rpc.get_block(blockNumber);\n        }\n    }\n\n    private async tryRefBlockFromGetInfo(info: GetInfoResult): Promise<BlockTaposInfo | GetBlockInfoResult | GetBlockResult> {\n        if (\n            info.hasOwnProperty('last_irreversible_block_id') &&\n            info.hasOwnProperty('last_irreversible_block_num') &&\n            info.hasOwnProperty('last_irreversible_block_time')\n        ) {\n            return {\n                block_num: info.last_irreversible_block_num,\n                id: info.last_irreversible_block_id,\n                timestamp: info.last_irreversible_block_time,\n            };\n        } else {\n            const block = await this.tryGetBlockInfo(info.last_irreversible_block_num);\n            return {\n                block_num: block.block_num,\n                id: block.id,\n                timestamp: block.timestamp,\n            };\n        }\n    }\n\n    public with(accountName: string): ActionBuilder {\n        return new ActionBuilder(this, accountName);\n    }\n\n    public buildTransaction(cb?: (tx: TransactionBuilder) => void): TransactionBuilder|void {\n        const tx = new TransactionBuilder(this);\n        if (cb) {\n            return cb(tx);\n        }\n        return tx as TransactionBuilder;\n    }\n\n    public async getAccountKeys (actor: string, permission: string) {\n        try {\n            const { permissions } = await this.rpc.get_account(actor)\n            const relevantPermission = permissions.find(({ perm_name }: any) => perm_name === permission)\n            if (relevantPermission) {\n                return relevantPermission.required_auth.keys.map(({ key }: any) => PublicKey.fromString(key).toString())\n            }\n        } catch (e) {\n            console.log(e)\n        }\n\n        return []\n    }\n\n    public async sha256Digest (\n        array: Uint8Array | ArrayBuffer\n    ): Promise<Uint8Array> {\n        const buffer = array instanceof Uint8Array ? array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength) : array;\n        return new Uint8Array(await this.getCrypto().subtle.digest('SHA-256', buffer));\n    };\n\n    async matchRsaKeyToSignature({ actor, transaction }: { actor: string, transaction: Transaction }) {\n        // 0. Destructure\n        const { signature, nonce, trx }: {\n            account: string,\n            signature: { auth_data: string; signature: string; client_json: string },\n            nonce: number,\n            trx: ApiInterfaces.Transaction\n        } = transaction.actions[0].data\n\n        // 1. Get user creds\n        let creds = await this.rpc.fetchCredentials(actor);\n    \n        // 2. Filter RSA\n        creds = creds.filter((cred) => cred.key.key[0] === 'rsa_public_key');\n    \n        // 3. For each cred\n        for (const cred of creds) {\n            // Create key \n            const rsaKey = cred.key.key[1] as RsaKey;\n        \n            // Create crypto key\n            const exponentBase64 = b64tob64u(Buffer.from(rsaKey.exponent, 'hex').toString('base64'));\n            const modulusBase64 = b64tob64u(Buffer.from(rsaKey.modulus, 'hex').toString('base64'));\n        \n            // Check challenge\n            const clientJson = JSON.parse(signature.client_json);\n            const signedDigest = new Uint8Array(base64url.toBuffer(clientJson.challenge).buffer);\n        \n            // Create TX Digest\n            const signBuf = new ser.SerialBuffer();\n            const serializedTransaction = this.serializeTransaction(trx);\n            signBuf.pushArray(serializedTransaction);\n            signBuf.pushNumberAsUint64(nonce);\n            const actualDigest = await this.sha256Digest(signBuf.asUint8Array().slice());\n        \n            if (ser.arrayToHex(signedDigest) !== ser.arrayToHex(actualDigest)) {\n                continue;\n            }\n        \n            // Check signature\n            const publicKey = await this.getCrypto().subtle.importKey(\n                'jwk',\n                {\n                    //this is an example jwk key, other key types are Uint8Array objects\n                    kty: 'RSA',\n                    e: exponentBase64,\n                    n: modulusBase64,\n                    alg: 'RS256',\n                    ext: false,\n                },\n                {\n                    name: 'RSASSA-PKCS1-v1_5',\n                    hash: {\n                        name: 'SHA-256',\n                    },\n                },\n                false,\n                ['verify']\n            );\n        \n            const authData = ser.hexToUint8Array(signature.auth_data);\n            const clientJsonHash = ser.hexToUint8Array(sha256(signature.client_json));\n            const resultingHash = new Uint8Array([...authData, ...clientJsonHash]);\n\n            const verified = await this.getCrypto().subtle.verify(\n                'RSASSA-PKCS1-v1_5',\n                publicKey,\n                ser.hexToUint8Array(signature.signature),\n                resultingHash\n            );\n        \n            if (verified) {\n                return true;\n            }\n        }\n    \n        return false;\n    }\n  \n    async matchEthKeyToSignature({ actor, transaction }: { actor: string, transaction: Transaction }) {\n        // 0. Destructure\n        const { signature, nonce, trx }: {\n            signature: { auth_data: string; signature: string; client_json: string },\n            nonce: number,\n            trx: ApiInterfaces.Transaction\n        } = transaction.actions[0].data\n\n        // 1. Get user creds\n        let creds = await this.rpc.fetchCredentials(actor);\n    \n        // 2. Filter RSA\n        creds = creds.filter((cred) => cred.key.key[0] === 'eth_public_key');\n    \n        // 3. For each cred\n        for (const cred of creds) {\n            // Create key\n            const ethKey = '0x' + cred.key.key[1];\n\n            // Create TX Digest\n            const signBuf = new ser.SerialBuffer();\n            const serializedTransaction = this.serializeTransaction(trx);\n            signBuf.pushArray(serializedTransaction);\n            signBuf.pushNumberAsUint64(nonce);\n            \n            const actualDigestArray = await this.sha256Digest(signBuf.asUint8Array().slice());\n            const actualDigest = ser.arrayToHex(actualDigestArray);\n\n            // Create signature\n            const ethSignature = '0x' + signature.signature;\n\n            // Verify\n            const signedWithKey = this.getRecoverPersonalSignature()({\n                data: actualDigest,\n                sig: ethSignature,\n            });\n\n            if (signedWithKey === ethKey) {\n                return true;\n            }\n        }\n    \n        return false;\n    }\n\n    public async matchWaKeyToSignature({ signature, key, digest }: { signature: string, key: string, digest: string }) {\n        try {\n          // Decode WA Signature data\n          const fullSignature = Numeric.stringToSignature(signature);\n          const sigData = new ser.SerialBuffer({ array: fullSignature.data });\n      \n          // Create R1\n          const r1Signature = new Signature({\n            type: Numeric.KeyType.r1,\n            data: sigData.getUint8Array(65),\n          }, new ec('p256'));\n      \n          // Recreate the data the browser actually signed\n          const authenticatorData = sigData.getBytes().slice();\n          const clientDataJSON = sigData.getBytes().slice();\n      \n          const whatItReallySigned = new ser.SerialBuffer();\n          whatItReallySigned.pushArray(authenticatorData);\n          whatItReallySigned.pushArray(await this.sha256Digest(clientDataJSON));\n      \n          // Recover public key\n          const recoveredR1Key = r1Signature.recover(whatItReallySigned.asUint8Array());\n      \n          // Create actual R1 Pub Key\n          const waPublicKey = PublicKey.fromString(key);\n          const actualR1KeyBuffer = new ser.SerialBuffer({\n            array: waPublicKey.key.data.slice(0, 33),\n          });\n          const actualR1Key = Numeric.publicKeyToString({\n            type: Numeric.KeyType.r1,\n            data: actualR1KeyBuffer.asUint8Array(),\n          });\n      \n          return recoveredR1Key.toString() === actualR1Key && r1Signature.verify(digest, recoveredR1Key, false);\n        } catch (e) {\n          return false\n        }\n    }\n\n    public async checkIfKeysMatchTransaction ({\n        actor,\n        permission,\n        transaction,\n        signatures,\n        chainId\n    }: {\n        actor: string,\n        permission: string,\n        transaction: any,\n        signatures: string[],\n        chainId?: string\n    }) {\n        // Copy by value\n        transaction = JSON.parse(JSON.stringify(transaction))\n        signatures = JSON.parse(JSON.stringify(signatures))\n\n        // RSA / ETH WA\n        if (\n            transaction.actions.length === 1 &&\n            transaction.actions[0].account === 'webauthn' &&\n            transaction.actions[0].name === 'exec' &&\n            permission === 'active'\n        ) {\n            // Destructure\n            const webauthTransaction = transaction.actions[0].data.trx\n            console.dir(webauthTransaction, { depth: null })\n\n            if (webauthTransaction.actions.length !== 1) {\n                return false\n            }\n\n            // Check authorization\n            for (const action of webauthTransaction.actions) {\n                for (const authorization of action.authorization) {\n                    if (authorization.actor !== actor || authorization.permission !== permission) {\n                        return false\n                    }\n                }\n            }\n\n            const typeOfKey = transaction.actions[0].data.key.key[0]\n            if (typeOfKey === 'eth_public_key') {\n                return this.matchEthKeyToSignature({ transaction, actor })\n            } else if (typeOfKey === 'rsa_public_key') {\n                return this.matchRsaKeyToSignature({ transaction, actor })\n            } else {\n                console.log(`Key type ${typeOfKey} not supported`)\n                return false\n            }\n        // normal keys\n        } else {\n            // Check authorization\n            for (const action of transaction.actions) {\n                for (const authorization of action.authorization) {\n                    if (authorization.actor !== actor || authorization.permission !== permission) {\n                        return false\n                    }\n                }\n            }\n\n            // Get chain ID\n            if (!chainId) {\n                const info = await this.rpc.get_info()\n                chainId = info.chain_id\n            }\n        \n            // Serialize\n            transaction.context_free_actions = await this.serializeActions(transaction.context_free_actions || []),\n            transaction.actions = await this.serializeActions(transaction.actions)\n    \n            const serializedTransaction = this.serializeTransaction(transaction);\n            const serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);\n    \n            const signature = Signature.fromString(signatures[0])\n            const signatureType = signature.getType()\n            const digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData)\n        \n            // Check keys\n            const keys = await this.getAccountKeys(actor, permission)\n            const verified = keys.some((key: string) => {\n                const publicKey = PublicKey.fromString(key)\n    \n                if (signatureType === Numeric.KeyType.wa) {\n                    return this.matchWaKeyToSignature({\n                        signature: signature.toString(),\n                        key: publicKey.toString(),\n                        digest\n                    })\n                }  else if ([Numeric.KeyType.k1, Numeric.KeyType.r1].includes(signatureType)) {\n                    return signature.verify(digest, publicKey, false)\n                } else {\n                    console.log(`Key type ${signatureType} not supported`)\n                    return false\n                }\n            })\n            return verified\n        }\n    }\n} // Api\n\nexport class TransactionBuilder {\n    private api: Api;\n    private actions: ActionBuilder[] = [];\n    private contextFreeGroups: ContextFreeGroupCallback[] = [];\n    constructor(api: Api) {\n        this.api = api;\n    }\n\n    public with(accountName: string): ActionBuilder {\n        const actionBuilder = new ActionBuilder(this.api, accountName);\n        this.actions.push(actionBuilder);\n        return actionBuilder;\n    }\n\n    public associateContextFree(contextFreeGroup: ContextFreeGroupCallback): TransactionBuilder {\n        this.contextFreeGroups.push(contextFreeGroup);\n        return this;\n    }\n\n    public async send(config?: TransactConfig): Promise<PushTransactionArgs|ReadOnlyTransactResult|TransactResult> {\n        const contextFreeDataSet: Uint8Array[] = [];\n        const contextFreeActions: ser.SerializedAction[] = [];\n        const actions: ser.SerializedAction[] = this.actions.map((actionBuilder) => actionBuilder.serializedData as ser.SerializedAction);\n        await Promise.all(this.contextFreeGroups.map(\n            async (contextFreeCallback: ContextFreeGroupCallback) => {\n                const { action, contextFreeAction, contextFreeData } = contextFreeCallback({\n                    cfd: contextFreeDataSet.length,\n                    cfa: contextFreeActions.length\n                });\n                if (action) {\n                    actions.push(action);\n                }\n                if (contextFreeAction) {\n                    contextFreeActions.push(contextFreeAction);\n                }\n                if (contextFreeData) {\n                    contextFreeDataSet.push(contextFreeData);\n                }\n            }\n        ));\n        this.contextFreeGroups = [];\n        this.actions = [];\n        return await this.api.transact({\n            context_free_data: contextFreeDataSet,\n            context_free_actions: contextFreeActions,\n            actions\n        }, config);\n    }\n}\n\nexport class ActionBuilder {\n    private api: Api;\n    private readonly accountName: string;\n    public serializedData: ser.SerializedAction | undefined;\n\n    constructor(api: Api, accountName: string) {\n        this.api = api;\n        this.accountName = accountName;\n    }\n\n    public as(actorName: string | ser.Authorization[] = []): ActionSerializerType {\n        let authorization: ser.Authorization[] = [];\n        if (actorName && typeof actorName === 'string') {\n            authorization = [{ actor: actorName, permission: 'active'}];\n        } else {\n            authorization = actorName as ser.Authorization[];\n        }\n\n        return new ActionSerializer(this, this.api, this.accountName, authorization) as ActionSerializerType;\n    }\n}\n\nclass ActionSerializer implements ActionSerializerType {\n    constructor(\n        parent: ActionBuilder,\n        api: Api,\n        accountName: string,\n        authorization: ser.Authorization[],\n    ) {\n        const jsonAbi = api.cachedAbis.get(accountName);\n        if (!jsonAbi) {\n            throw new Error('ABI must be cached before using ActionBuilder, run api.getAbi()');\n        }\n        const types = ser.getTypesFromAbi(ser.createInitialTypes(), jsonAbi.abi);\n        const actions = new Map<string, ser.Type>();\n        for (const { name, type } of jsonAbi.abi.actions) {\n            actions.set(name, ser.getType(types, type));\n        }\n        actions.forEach((type, name) => {\n            Object.assign(this, {\n                [name]: (...args: any[]) => {\n                    const data: { [key: string]: any } = {};\n                    args.forEach((arg, index) => {\n                        const field = type.fields[index];\n                        data[field.name] = arg;\n                    });\n                    const serializedData = ser.serializeAction(\n                        { types, actions },\n                        accountName,\n                        name,\n                        authorization,\n                        data,\n                    );\n                    parent.serializedData = serializedData;\n                    return serializedData;\n                }\n            });\n        });\n    }\n}\n","/**\n * @module RPC-Error\n */\n\n/** Holds detailed error information */\nexport class RpcError extends Error {\n    /** Detailed error information */\n    public json: any;\n    public details: any;\n\n    constructor(json: any) {\n        if (json && json.error && json.error.details && json.error.details.length && json.error.details[0].message) {\n            super(json.error.details[0].message);\n            this.details = json.error.details;\n        } else if (json && json.processed && json.processed.except && json.processed.except.message) {\n            super(json.processed.except.message);\n            this.details = json.processed.except;\n        }else if (json && json.result && json.result.except && json.result.except.message) {\n            super(json.result.except.message);\n            this.details = json.result.except;\n        } else if(json) {\n            super(json.message);\n        } else {\n            super(json);\n        }\n        Object.setPrototypeOf(this, RpcError.prototype);\n        this.json = json;\n    }\n}\n","import type { JsonRpc } from './index'\nimport type { KycProvider, UserInfo, WaKey } from './types';\n\n\n/**\n * Checks blockchain for a list of kycproviders, and sorts through the ones that are blacklisted.\n * @returns An array of strings with valid kyc provider names.\n */\n export async function getValidKycProviders(this: JsonRpc) {\n    try {\n      const { rows } = await this.get_table_rows({\n        code: 'eosio.proton',\n        table: 'kycproviders',\n        scope: 'eosio.proton',\n      });\n      this.validKycProviders = rows.reduce((acc: string[], provider: KycProvider) => {\n        if (!provider.blisted) {\n          acc.push(provider.kyc_provider)\n        }\n\n        return acc\n      }, [])\n    } catch (e) {\n      throw new Error('Unable to get KYC Providers.')\n    }\n  }\n\n/**\n * Takes an account or a list of accounts and checks to make sure that they are light-verified\n * @param account This could be an array of user rows from the usersinfo table on the blockchain, or a singular string for an account name\n * @returns An object of the user data as pulled from the usersinfo table on the blockchain with an additional key, isLightKYCVerified (boolean)\n */\nexport async function isLightKYCVerified(\n  this: JsonRpc,\n  account: UserInfo[] | string\n) {\n    const lightKyc = [\n      \"firstname\",\n      \"lastname\",\n      \"birthdate\",\n      \"address\"\n    ];\n\n    if (account.length === 0) {\n      throw new Error('Please enter an account.');\n    }\n\n    if (this.validKycProviders.length === 0) {\n      await this.getValidKycProviders();\n    }\n\n    let users: UserInfo[] = [];\n\n    if (Array.isArray(account)) {\n      users = account;\n    } else if (typeof account === 'string') {\n      try {\n        const { rows } = await this.get_table_rows({\n            code: 'eosio.proton',\n            table: 'usersinfo',\n            scope: 'eosio.proton',\n            lower_bound: account,\n            upper_bound: account,\n        });\n        \n        users = rows;\n      } catch(e) {\n        throw new Error('Account not found!');\n      }\n    }\n    \n    const resultsWithKycStatus: UserInfo[] = users.map((user: UserInfo) => {\n      const levelsResult: string[] = user.kyc.reduce((acc: string[], kyc) => {\n        if (this.validKycProviders.indexOf(kyc.kyc_provider) >= 0) {\n          const result = kyc.kyc_level.split(',').map((kycItem: string) => kycItem.split(':')[1]);\n          acc = result.concat(acc);\n        }\n\n        return acc\n      }, []);\n\n      user.isLightKYCVerified = lightKyc.every(lightKycField => levelsResult.includes(lightKycField));\n\n      return user\n    })\n\n    return resultsWithKycStatus;\n};\n\nexport async function fetchCredentials(\n  this: JsonRpc,\n  actor: string\n): Promise<WaKey[]> {\n  const { rows: credentials }: { rows: WaKey[] } = await this.get_table_rows({\n    code: 'webauthn',\n    scope: 'webauthn',\n    table: 'credentials',\n    lower_bound: actor,\n    upper_bound: actor,\n    key_type: 'name',\n    index_position: 2,\n  });\n  return credentials;\n};\n  ","import { AbiProvider, AuthorityProvider, AuthorityProviderArgs, BinaryAbi, TransactResult } from '../api/types';\nimport { RpcError } from './error';\nimport { isLightKYCVerified, getValidKycProviders, fetchCredentials } from './proton'\nimport fetch from 'cross-fetch'\nimport { base64ToBinary, convertLegacyPublicKeys } from '../api/numeric';\nimport { Authorization } from '../api/serialize';\nimport { GetAccountResult, GetBlockHeaderStateResult, GetBlockInfoResult, GetBlockResult, GetInfoResult, GetActivatedProtocolFeaturesResult, GetAbiResult, GetRawCodeAndAbiResult, GetRawAbiResult, GetCodeResult, PushTransactionArgs, AbiBinToJsonResult, AbiJsonToBinResult, DBSizeGetResult, GetAccountsByAuthorizersResult, GetActivatedProtocolFeaturesParams, GetCodeHashResult, GetCurrencyStatsResult, GetProducerScheduleResult, GetProducersResult, GetScheduledTransactionsResult, GetTableByScopeResult, GetTableRowsResult, PackedTrx, ReadOnlyTransactResult, TraceApiGetBlockResult } from './types';\n\nconst arrayToHex = (data: Uint8Array): string => {\n    let result = '';\n    for (const x of data) {\n        result += ('00' + x.toString(16)).slice(-2);\n    }\n    return result;\n};\n\n/** Make RPC calls */\nexport class JsonRpc implements AuthorityProvider, AbiProvider {\n    public endpoints: string[];\n    public maxRetries: number = 3;\n    public currentEndpoint: string;\n    public validKycProviders: string[] = [];\n\n    /**\n     * @param args\n     *`fetch`:\n     * browsers: leave `null` or `undefined`\n     * node: provide an implementation\n     */\n    constructor(endpoints: string | string[]) {\n        endpoints = Array.isArray(endpoints) ? endpoints : [endpoints];\n        this.endpoints = endpoints.map(endpoint => endpoint.replace(/\\/$/, ''))\n        this.currentEndpoint = ''\n        this.nextEndpoint();\n    }\n\n    public nextEndpoint() {\n        if (this.endpoints.length) {\n            if (this.currentEndpoint) {\n                const removed = this.endpoints.shift();\n                this.endpoints = this.endpoints.concat(removed || []);\n            }\n\n            this.currentEndpoint = this.endpoints[0];\n        }\n    }\n\n    /** Post `body` to `endpoint + path`. Throws detailed error information in `RpcError` when available. */\n    public async fetch(path: string, body: any, currentRetries: number = 0): Promise<any> {\n        let response;\n        let json;\n        try {\n            response = await fetch(this.currentEndpoint + path, {\n                body: JSON.stringify(body),\n                method: 'POST',\n            });\n            json = await response.json();\n            if (json.processed && json.processed.except) {\n                throw new RpcError(json);\n            } else if (json.result && json.result.except) {\n                throw new RpcError(json);\n            }\n        } catch (e) {\n            console.log({\n                currentEndpoint: this.currentEndpoint,\n                endpoints: this.endpoints,\n                currentRetries: currentRetries,\n                error: e\n            })\n\n            if (this.endpoints.length > 1) {\n                this.nextEndpoint()\n                if (currentRetries < this.maxRetries)  {\n                    return this.fetch(path, body, ++currentRetries)\n                } else {\n                    e.isFetchError = true;\n                    throw new RpcError(e);\n                }\n            }\n        }\n\n        if (!(response && response.ok)) {\n            throw new RpcError(json);\n        }\n\n        // Check for synced\n        if (json && json.head_block_time) {\n            const headTime = new Date(json.head_block_time + 'Z').getTime()\n            const ct = new Date().getTime()\n            const secondsBehind = (ct - headTime) / 1000\n\n            if (secondsBehind > 30 && this.endpoints.length > 1) {\n                this.nextEndpoint()\n                if (currentRetries < this.maxRetries)  {\n                    return this.fetch(path, body, ++currentRetries)\n                }\n            }\n        }\n\n        return json;\n    }\n\n    /** Get from endpoint  */\n    public async get(path: string): Promise<any> {\n        const res = await fetch(path);\n\n        if (res.status >= 400) {\n            throw new Error(\"Bad response from server \" + res.status);\n        }\n\n        const data = await res.json()\n        return data\n    }\n\n    public async abi_bin_to_json(\n        code: string,\n        action: string,\n        binargs: string,\n    ): Promise<AbiBinToJsonResult> {\n        return await this.fetch('/v1/chain/abi_bin_to_json', { code, action, binargs });\n    }\n\n    public async abi_json_to_bin(\n        code: string,\n        action: string,\n        args: any[],\n    ): Promise<AbiJsonToBinResult> {\n        return await this.fetch('/v1/chain/abi_json_to_bin', { code, action, args });\n    }\n\n    /** Raw call to `/v1/chain/get_abi` */\n    public async get_abi(accountName: string): Promise<GetAbiResult> {\n        return await this.fetch('/v1/chain/get_abi', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_account` */\n    public async get_account(accountName: string): Promise<GetAccountResult> {\n        return await this.fetch('/v1/chain/get_account', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_accounts_by_authorizers` */\n    public async get_accounts_by_authorizers(accounts: Authorization[], keys: string[]): Promise<GetAccountsByAuthorizersResult> {\n        return await this.fetch('/v1/chain/get_accounts_by_authorizers', { accounts, keys });\n    }\n\n    /** Raw call to `get_activated_protocol_features` */\n    public async get_activated_protocol_features({\n        limit,\n        search_by_block_num,\n        reverse,\n        lower_bound,\n        upper_bound,\n    }: GetActivatedProtocolFeaturesParams = {\n        limit: 50,\n        search_by_block_num: false,\n        reverse: false\n    }): Promise<GetActivatedProtocolFeaturesResult> {\n        return await this.fetch('/v1/chain/get_activated_protocol_features', { lower_bound, upper_bound, limit, search_by_block_num, reverse });\n    }\n\n    /** Raw call to `/v1/chain/get_block_header_state` */\n    public async get_block_header_state(blockNumOrId: number | string): Promise<GetBlockHeaderStateResult> {\n        return await this.fetch('/v1/chain/get_block_header_state', { block_num_or_id: blockNumOrId });\n    }\n\n    /** Raw call to `/v1/chain/get_block_info` */\n    public async get_block_info(blockNum: number): Promise<GetBlockInfoResult> {\n        return await this.fetch('/v1/chain/get_block_info', { block_num: blockNum });\n    }\n\n    /** Raw call to `/v1/chain/get_block` */\n    public async get_block(blockNumOrId: number | string): Promise<GetBlockResult> {\n        return await this.fetch('/v1/chain/get_block', { block_num_or_id: blockNumOrId });\n    }\n\n    /** Raw call to `/v1/chain/get_code` */\n    public async get_code(accountName: string): Promise<GetCodeResult> {\n        return await this.fetch('/v1/chain/get_code', {\n            account_name: accountName,\n            code_as_wasm: true\n        });\n    }\n\n    /** Raw call to `/v1/chain/get_code_hash` */\n    public async get_code_hash(accountName: string): Promise<GetCodeHashResult> {\n        return await this.fetch('/v1/chain/get_code_hash', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_currency_balance` */\n    public async get_currency_balance(code: string, account: string, symbol: string): Promise<string[]> {\n        return await this.fetch('/v1/chain/get_currency_balance', { code, account, symbol });\n    }\n\n    /** Raw call to `/v1/chain/get_currency_stats` */\n    public async get_currency_stats(code: string, symbol: string): Promise<GetCurrencyStatsResult> {\n        return await this.fetch('/v1/chain/get_currency_stats', { code, symbol });\n    }\n\n    /** Raw call to `/v1/chain/get_info` */\n    public async get_info(): Promise<GetInfoResult> {\n        return await this.fetch('/v1/chain/get_info', {});\n    }\n\n    /** Raw call to `/v1/chain/get_producer_schedule` */\n    public async get_producer_schedule(): Promise<GetProducerScheduleResult> {\n        return await this.fetch('/v1/chain/get_producer_schedule', {});\n    }\n\n    /** Raw call to `/v1/chain/get_producers` */\n    public async get_producers(json = true, lowerBound = '', limit = 50): Promise<GetProducersResult> {\n        return await this.fetch('/v1/chain/get_producers', { json, lower_bound: lowerBound, limit });\n    }\n\n    /** Raw call to `/v1/chain/get_raw_code_and_abi` */\n    public async get_raw_code_and_abi(accountName: string): Promise<GetRawCodeAndAbiResult> {\n        return await this.fetch('/v1/chain/get_raw_code_and_abi', { account_name: accountName });\n    }\n\n    /** calls `/v1/chain/get_raw_code_and_abi` and pulls out unneeded raw wasm code */\n    public async getRawAbi(accountName: string): Promise<BinaryAbi> {\n        const rawAbi = await this.get_raw_abi(accountName);\n        const abi = base64ToBinary(rawAbi.abi);\n        return { accountName: rawAbi.account_name, abi };\n    }\n\n    /** Raw call to `/v1/chain/get_raw_abi` */\n    public async get_raw_abi(accountName: string): Promise<GetRawAbiResult> {\n        return await this.fetch('/v1/chain/get_raw_abi', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_scheduled_transactions` */\n    public async get_scheduled_transactions(json = true, lowerBound = '', limit = 50): Promise<GetScheduledTransactionsResult> {\n        return await this.fetch('/v1/chain/get_scheduled_transactions', { json, lower_bound: lowerBound, limit });\n    }\n\n    /** Raw call to `/v1/chain/get_table_rows` */\n    public async get_table_rows({\n        json = true,\n        code,\n        scope,\n        table,\n        lower_bound = '',\n        upper_bound = '',\n        index_position = 1,\n        key_type = '',\n        limit = 10,\n        reverse = false,\n        show_payer = false,\n    }: any): Promise<GetTableRowsResult> {\n        return await this.fetch(\n            '/v1/chain/get_table_rows', {\n                json,\n                code,\n                scope,\n                table,\n                lower_bound,\n                upper_bound,\n                index_position,\n                key_type,\n                limit,\n                reverse,\n                show_payer,\n            });\n    }\n\n    /** Raw call to `/v1/chain/get_kv_table_rows` */\n    public async get_kv_table_rows({\n        json = true,\n        code,\n        table,\n        index_name,\n        encode_type = 'bytes',\n        index_value,\n        lower_bound,\n        upper_bound,\n        limit = 10,\n        reverse = false,\n        show_payer = false,\n    }: any): Promise<GetTableRowsResult> {\n        return await this.fetch(\n            '/v1/chain/get_kv_table_rows', {\n                json,\n                code,\n                table,\n                index_name,\n                encode_type,\n                index_value,\n                lower_bound,\n                upper_bound,\n                limit,\n                reverse,\n                show_payer,\n            });\n    }\n\n    /** Raw call to `/v1/chain/get_table_by_scope` */\n    public async get_table_by_scope({\n        code,\n        table,\n        lower_bound = '',\n        upper_bound = '',\n        limit = 10,\n    }: any): Promise<GetTableByScopeResult> {\n        return await this.fetch(\n            '/v1/chain/get_table_by_scope', {\n                code,\n                table,\n                lower_bound,\n                upper_bound,\n                limit,\n            });\n    }\n\n    /** Get subset of `availableKeys` needed to meet authorities in `transaction`. Implements `AuthorityProvider` */\n    public async getRequiredKeys(args: AuthorityProviderArgs): Promise<string[]> {\n        const requiredKeys = await this.fetch('/v1/chain/get_required_keys', {\n            transaction: args.transaction,\n            available_keys: args.availableKeys,\n        })\n        return convertLegacyPublicKeys(requiredKeys.required_keys);\n    }\n\n    /** Push a serialized transaction (replaced by send_transaction, but returned format has changed) */\n    public async push_transaction(\n        { signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n    ): Promise<TransactResult> {\n            try {\n            return await this.fetch('/v1/chain/push_transaction', {\n                signatures,\n                compression,\n                packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n                packed_trx: arrayToHex(serializedTransaction),\n            });\n        } catch (e) {\n            if (e && e.json && e.json.error) {\n                const expired = e.json.error.name === 'expired_tx_exception'\n                if (expired) {\n                    e.json.error.message = 'Transaction Expired: Try Again'\n                    this.nextEndpoint()\n                }\n            }\n            throw e\n        }\n    }\n    \n    /** Raw call to `/v1/chain/push_ro_transaction */\n    public async push_ro_transaction({ signatures, compression = 0, serializedTransaction }: PushTransactionArgs,\n        returnFailureTraces: boolean = false): Promise<ReadOnlyTransactResult> {\n        return await this.fetch('/v1/chain/push_ro_transaction', {\n            transaction: {\n                signatures,\n                compression,\n                packed_context_free_data: arrayToHex(new Uint8Array(0)),\n                packed_trx: arrayToHex(serializedTransaction),\n            },\n            return_failure_traces: returnFailureTraces,\n        });\n    }\n\n    public async push_transactions(transactions: PushTransactionArgs[]): Promise<TransactResult[]> {\n        const packedTrxs: PackedTrx[] = transactions.map(({signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs) => {\n            return {\n                signatures,\n                compression,\n                packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n                packed_trx: arrayToHex(serializedTransaction),\n            };\n        });\n        return await this.fetch('/v1/chain/push_transactions', packedTrxs );\n    }\n\n    /** Send a serialized transaction */\n    public async send_transaction(\n        { signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n    ): Promise<TransactResult> {\n            return await this.fetch('/v1/chain/send_transaction', {\n            signatures,\n            compression,\n            packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n            packed_trx: arrayToHex(serializedTransaction),\n        });\n    }\n\n    /** Raw call to `/v1/db_size/get` */\n    public async db_size_get(): Promise<DBSizeGetResult> { return await this.fetch('/v1/db_size/get', {}); }\n\n    /** Raw call to `/v1/trace_api/get_block` */\n    public async trace_get_block(block_num: number): Promise<TraceApiGetBlockResult> {\n        return await this.fetch('/v1/trace_api/get_block', { block_num });\n    }\n\n    /** Raw call to `/v1/history/get_actions` */\n    public async history_get_actions(accountName: string, pos: number | null = null, offset: number | null = null) {\n        return await this.fetch('/v1/history/get_actions', { account_name: accountName, pos, offset });\n    }\n\n    /** Raw call to `/v1/history/get_transaction` */\n    public async history_get_transaction(id: string, blockNumHint: number | null = null) {\n        return await this.fetch('/v1/history/get_transaction', { id, block_num_hint: blockNumHint });\n    }\n\n    /** Raw call to `/v1/history/get_key_accounts` */\n    public async history_get_key_accounts(publicKey: string) {\n        return await this.fetch('/v1/history/get_key_accounts', { public_key: publicKey });\n    }\n\n    /** Raw call to `/v1/history/get_controlled_accounts` */\n    public async history_get_controlled_accounts(controllingAccount: string) {\n        return await this.fetch('/v1/history/get_controlled_accounts', { controlling_account: controllingAccount });\n    }\n\n    /** FIO` */\n    public async get_nfts_fio_address(address: string) {\n        return await this.fetch('/v1/chain/get_nfts_fio_address', { fio_address: address });\n    }\n        \n    /** Proton` */\n    public isLightKYCVerified = isLightKYCVerified\n    public getValidKycProviders = getValidKycProviders\n    public fetchCredentials = fetchCredentials\n} // JsonRpc\n\nexport { RpcError } from './error';","/**\n * @module WebAuthn-Sig\n */\n// copyright defined in eosjs/LICENSE.txt\n\nimport { SignatureProvider, SignatureProviderArgs } from '../api/types';\nimport * as ser from '../api/serialize';\nimport * as numeric from '../api/numeric';\nimport { ec } from 'elliptic';\n\n/** Signs transactions using WebAuthn */\nexport class WebAuthnSignatureProvider implements SignatureProvider {\n    /** Map public key to credential ID (hex). User must populate this. */\n    public keys = new Map<string, string>();\n\n    /** Public keys that the `SignatureProvider` holds */\n    public async getAvailableKeys() {\n        return Array.from(this.keys.keys());\n    }\n\n    /** Sign a transaction */\n    public async sign(\n        { chainId, requiredKeys, serializedTransaction, serializedContextFreeData }: SignatureProviderArgs,\n    ) {\n        const signBuf = new ser.SerialBuffer();\n        signBuf.pushArray(ser.hexToUint8Array(chainId));\n        signBuf.pushArray(serializedTransaction);\n        if (serializedContextFreeData) {\n            signBuf.pushArray(new Uint8Array(await crypto.subtle.digest('SHA-256', serializedContextFreeData.buffer)));\n        } else {\n            signBuf.pushArray(new Uint8Array(32));\n        }\n        const digest = new Uint8Array(await crypto.subtle.digest('SHA-256', signBuf.asUint8Array().slice().buffer));\n\n        const signatures = [] as string[];\n        for (const key of requiredKeys) {\n            const id = ser.hexToUint8Array(this.keys.get(key) as string);\n            const assertion = await (navigator as any).credentials.get({\n                publicKey: {\n                    timeout: 60000,\n                    allowCredentials: [{\n                        id,\n                        type: 'public-key',\n                    }],\n                    challenge: digest.buffer,\n                },\n            });\n            const e = new ec('p256') as any; // https://github.com/indutny/elliptic/pull/232\n            const pubKey = e.keyFromPublic(numeric.stringToPublicKey(key).data.subarray(0, 33)).getPublic();\n\n            const fixup = (x: Uint8Array) => {\n                const a = Array.from(x);\n                while (a.length < 32) {\n                    a.unshift(0);\n                }\n                while (a.length > 32) {\n                    if (a.shift() !== 0) {\n                        throw new Error('Signature has an r or s that is too big');\n                    }\n                }\n                return new Uint8Array(a);\n            };\n\n            const der = new ser.SerialBuffer({ array: new Uint8Array(assertion.response.signature) });\n            if (der.get() !== 0x30) {\n                throw new Error('Signature missing DER prefix');\n            }\n            if (der.get() !== der.array.length - 2) {\n                throw new Error('Signature has bad length');\n            }\n            if (der.get() !== 0x02) {\n                throw new Error('Signature has bad r marker');\n            }\n            const r = fixup(der.getUint8Array(der.get()));\n            if (der.get() !== 0x02) {\n                throw new Error('Signature has bad s marker');\n            }\n            const s = fixup(der.getUint8Array(der.get()));\n\n            const whatItReallySigned = new ser.SerialBuffer();\n            whatItReallySigned.pushArray(new Uint8Array(assertion.response.authenticatorData));\n            whatItReallySigned.pushArray(new Uint8Array(\n                await crypto.subtle.digest('SHA-256', assertion.response.clientDataJSON)));\n            const hash = new Uint8Array(\n                await crypto.subtle.digest('SHA-256', whatItReallySigned.asUint8Array().slice()));\n            const recid = e.getKeyRecoveryParam(hash, new Uint8Array(assertion.response.signature), pubKey);\n\n            const sigData = new ser.SerialBuffer();\n            sigData.push(recid + 27 + 4);\n            sigData.pushArray(r);\n            sigData.pushArray(s);\n            sigData.pushBytes(new Uint8Array(assertion.response.authenticatorData));\n            sigData.pushBytes(new Uint8Array(assertion.response.clientDataJSON));\n\n            const sig = numeric.signatureToString({\n                type: numeric.KeyType.wa,\n                data: sigData.asUint8Array().slice(),\n            });\n            signatures.push(sig);\n        }\n        return { signatures, serializedTransaction, serializedContextFreeData };\n    }\n}\n","import { Api } from './api';\n\nimport * as ApiInterfaces from './api/types';\n\nimport { JsonRpc, RpcError } from './rpc';\nimport * as RpcInterfaces from './rpc/types';\n\nimport * as Numeric from './api/numeric';\nimport * as Serialize from './api/serialize';\n\nimport { JsSignatureProvider, digestFromSerializedData } from './cryptography/jsSignatureProvider';\nimport { WebAuthnSignatureProvider } from './cryptography/webauthn'\n\nimport * as Key from './cryptography/key'\nimport { sha256 } from './cryptography/conversions'\n\nexport {\n  Api,\n  ApiInterfaces,\n  JsonRpc,\n  Numeric,\n  RpcInterfaces,\n  RpcError,\n  Serialize,\n  JsSignatureProvider,\n  WebAuthnSignatureProvider,\n  digestFromSerializedData,\n  Key,\n  sha256,\n};\n\nexport default {\n  Api,\n  ApiInterfaces,\n  JsonRpc,\n  Numeric,\n  RpcInterfaces,\n  RpcError,\n  Serialize,\n  JsSignatureProvider,\n  Key,\n  sha256,\n  WebAuthnSignatureProvider\n};\n"],"names":["KeyType","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","ripemd160","RIPEMD160","hash","base58Chars","base64Chars","base58Map","base58M","Array","fill","charCodeAt","create_base58_map","base64Map","base64M","create_base64_map","isNegative","bignum","negate","carry","x","decimalToBinary","size","s","Uint8Array","srcDigit","j","signedDecimalToBinary","negative","substr","binaryToDecimal","minDigits","String","fromCharCode","signedBinaryToDecimal","base58ToBinary","base58ToBinaryVarSize","binaryToBase58","base64ToBinary","len","groups","bytes","group","digit0","digit1","digit2","digit3","digestSuffixRipemd160","data","suffix","d","stringToKey","whole","buffer","digest","keyToString","prefix","stringToPublicKey","publicKeyDataSize","k1","r1","wa","publicKeyToLegacyString","publicKeyToString","convertLegacyPublicKey","convertLegacyPublicKeys","map","stringToPrivateKey","privateKeyDataSize","privateKeyToLegacyString","byte","sha256","update","privateKeyToString","stringToSignature","signatureToString","signature","SerializerState","options","skippedBinaryExtension","SerialBuffer","array","textEncoder","textDecoder","readPos","TextEncoder","TextDecoder","reserve","l","Math","ceil","newArray","set","haveReadData","restartRead","asUint8Array","byteOffset","pushArray","v","get","pushUint8ArrayChecked","getUint8Array","skip","pushUint16","getUint16","pushUint32","getUint32","pushNumberAsUint64","floor","getUint64AsNumber","low","pushVaruint32","getVaruint32","bit","b","pushVarint32","getVarint32","pushFloat32","Float32Array","getFloat32","pushFloat64","Float64Array","getFloat64","pushName","RegExp","test","charToSymbol","c","a","getName","endsWith","pushBytes","getBytes","pushString","encode","getString","decode","pushSymbolCode","getSymbolCode","pushSymbol","precision","getSymbol","pushAsset","pos","amount","trim","foundDigit","numeric","getAsset","pushPublicKey","getPublicKey","begin","pushPrivateKey","getPrivateKey","pushSignature","getSignature","supportedAbiVersion","version","startsWith","checkDateParse","date","Date","parse","Number","dateToTimePoint","round","timePointToDate","us","toISOString","dateToTimePointSec","timePointSecToDate","sec","dateToBlockTimestamp","blockTimestampToDate","slot","stringToSymbol","m","match","symbolToString","arrayToHex","toString","toUpperCase","hexToUint8Array","hex","parseInt","serializeUnknown","_","__","deserializeUnknown","serializeStruct","allowExtensions","JSON","stringify","base","serialize","fields","field","extensionOf","deserializeStruct","deserialize","serializeVariant","isArray","findIndex","deserializeVariant","serializeArray","arrayOf","deserializeArray","serializeOptional","optionalOf","deserializeOptional","serializeExtension","deserializeExtension","serializeObject","entries","dataType","deserializeObject","serializePair","item","_this","deserializePair","createType","attrs","aliasOfName","baseName","checkRange","orig","converted","createInitialTypes","Map","bool","uint8","int8","uint16","int16","uint32","uint64","int64","int32","varuint32","varint32","uint128","int128","float32","float64","float128","bytesAsUint8Array","string","time_point","time_point_sec","block_timestamp_type","symbol_code","symbol","asset","checksum160","checksum256","checksum512","public_key","private_key","typeName","createAbiTypes","initialTypes","createTransactionExtensionTypes","createTransactionTypes","getType","types","getTypesFromAbi","abi","new_type_name","structs","variants","transactionHeader","refBlock","expireSeconds","h","timestamp","header","id","expiration","ref_block_num","block_num","ref_block_prefix","serializeActionData","contract","account","action","actions","serializeAction","authorization","deserializeActionData","deserializeAction","serializeAnyvar","anyvar","def","anyvarDefs","null_t","any_array","any_object","index","deserializeAnyvar","defIndex","anyvarDefsByIndex","useShortForm","deserializeAnyvarShort","serializeAnyObject","deserializeAnyObject","serializeAnyArray","arr","deserializeAnyArray","additionalTypes","addAdditionalTypes","serializeQuery","query","filter","b64tob64u","replace","max_net_usage_words","max_cpu_usage_ms","delay_sec","context_free_actions","transaction_extensions","constructElliptic","EC","PublicKey","ec","fromString","publicKeyStr","fromElliptic","publicKey","keyType","getPublic","getX","toArray","y","getY","concat","toLegacyString","toElliptic","keyPair","pub","Buffer","from","isValid","validate","BN","require","Signature","sig","ellipticSig","recoveryParam","eosioRecoveryParam","r","sigData","ellipticRecoveryBitField","lengthOfR","toBinary","verify","shouldHash","encoding","ellipticSignature","ellipticPublicKey","recover","recoveredPublicKey","recoverPubKey","ellipticKPub","keyFromPublic","PrivateKey","privKey","getPrivate","toArrayLike","keyString","privateKey","keyFromPrivate","ellipticPrivateKey","sign","tries","constructSignature","canonical","pers","secureEnv","ellipticKeyPair","genKeyPair","ecOptions","defaultEc","digestFromSerializedData","chainId","serializedTransaction","serializedContextFreeData","e","signBuf","JsSignatureProvider","privateKeys","availableKeys","priv","privElliptic","pubStr","getAvailableKeys","requiredKeys","signatures","Api","args","rpc","authorityProvider","abiProvider","signatureProvider","abiTypes","transactionTypes","contracts","cachedAbis","crypto","recoverPersonalSignature","transactionExtensions","ser","window","global","getCrypto","getRecoverPersonalSignature","rawAbiToJson","rawAbi","jsonToRawAbi","jsonAbi","getCachedAbi","accountName","reload","getRawAbi","cachedAbi","message","_context","getAbi","getTransactionAbis","transaction","accounts","uniqueAccounts","Set","actionPromises","all","getContract","serializeTransaction","serializeContextFreeData","contextFreeData","deserializeTransaction","serializeTransactionExtensions","resource_payer","extensionBuffer","deserializeTransactionExtensions","extensionData","transactionExtension","_this2","find","extension","deserializedObj","max_net_bytes","max_cpu_us","max_memory_bytes","deleteTransactionExtensionObjects","serializeActions","_this3","deserializeActions","_this4","deserializeActionsSync","deserializedActions","deserializeTransactionWithActions","deserializedTransaction","deserializedCFActions","deflateSerializedArray","serializedArray","deflate","level","inflateSerializedArray","compressedSerializedArray","inflate","transact","broadcast","readOnlyTrx","returnFailureTraces","compression","blocksBehind","useLastIrreversible","get_info","generateTapos","hasRequiredTaposFields","abis","context_free_data","pushTransactionArgs","getRequiredKeys","chain_id","pushCompressedSignedTransaction","pushSignedTransaction","transactWithDelay","params","delay","wait","ms","setTimeout","success","short","tryRefBlockFromGetInfo","queryBuffer","send_transaction","returnBuffer","processed","action_traces","return_value","push_ro_transaction","push_transaction","compressedSerializedTransaction","compressedSerializedContextFreeData","taposBlockNumber","head_block_num","last_irreversible_block_num","tryGetBlockInfo","tryGetBlockHeaderState","get_block_header_state","blockNumber","get_block_info","get_block","last_irreversible_block_id","last_irreversible_block_time","block","ActionBuilder","buildTransaction","cb","tx","TransactionBuilder","getAccountKeys","actor","permission","get_account","relevantPermission","permissions","perm_name","required_auth","console","log","sha256Digest","byteLength","subtle","matchRsaKeyToSignature","nonce","trx","fetchCredentials","creds","cred","rsaKey","exponentBase64","exponent","modulusBase64","modulus","clientJson","client_json","signedDigest","base64url","toBuffer","challenge","actualDigest","importKey","kty","n","alg","ext","authData","auth_data","clientJsonHash","resultingHash","matchEthKeyToSignature","ethKey","ethSignature","matchWaKeyToSignature","fullSignature","Numeric","r1Signature","authenticatorData","clientDataJSON","whatItReallySigned","recoveredR1Key","waPublicKey","actualR1KeyBuffer","actualR1Key","checkIfKeysMatchTransaction","webauthTransaction","dir","depth","typeOfKey","signatureType","verified","some","_this5","includes","api","contextFreeGroups","actionBuilder","associateContextFree","contextFreeGroup","send","config","contextFreeDataSet","contextFreeActions","serializedData","contextFreeCallback","cfd","cfa","contextFreeAction","as","actorName","ActionSerializer","parent","assign","_this6","RpcError","json","details","except","getValidKycProviders","get_table_rows","code","table","scope","validKycProviders","rows","reduce","acc","provider","blisted","kyc_provider","isLightKYCVerified","lightKyc","users","lower_bound","upper_bound","resultsWithKycStatus","user","levelsResult","kyc","indexOf","kyc_level","split","kycItem","every","lightKycField","key_type","index_position","JsonRpc","endpoints","maxRetries","currentEndpoint","endpoint","nextEndpoint","removed","shift","fetch","path","body","currentRetries","response","isFetchError","ok","head_block_time","headTime","getTime","res","status","abi_bin_to_json","binargs","abi_json_to_bin","get_abi","account_name","get_accounts_by_authorizers","get_activated_protocol_features","limit","search_by_block_num","blockNumOrId","block_num_or_id","blockNum","get_code","code_as_wasm","get_code_hash","get_currency_balance","get_currency_stats","get_producer_schedule","get_producers","lowerBound","get_raw_code_and_abi","get_raw_abi","get_scheduled_transactions","show_payer","get_kv_table_rows","index_name","encode_type","index_value","get_table_by_scope","available_keys","required_keys","packed_context_free_data","packed_trx","_context27","return_failure_traces","push_transactions","transactions","packedTrxs","db_size_get","trace_get_block","history_get_actions","offset","history_get_transaction","blockNumHint","block_num_hint","history_get_key_accounts","history_get_controlled_accounts","controllingAccount","controlling_account","get_nfts_fio_address","address","fio_address","WebAuthnSignatureProvider","navigator","credentials","timeout","allowCredentials","assertion","pubKey","subarray","fixup","unshift","der","recid","getKeyRecoveryParam","ApiInterfaces","RpcInterfaces","Serialize","Key"],"mappings":"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"}