import { deflate, inflate } from 'pako';
import { ec } from 'elliptic';
import base64url from 'base64url';
import { sha256 as sha256$1 } from 'hash.js';
import RIPEMD160 from 'ripemd-ts';
import 'fast-text-encoding';
import _fetch from 'cross-fetch';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
});

var ripemd160 = RIPEMD160.hash;
var base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var create_base58_map = function create_base58_map() {
  var base58M = Array(256).fill(-1);

  for (var i = 0; i < base58Chars.length; ++i) {
    base58M[base58Chars.charCodeAt(i)] = i;
  }

  return base58M;
};

var base58Map = /*#__PURE__*/create_base58_map();

var create_base64_map = function create_base64_map() {
  var base64M = Array(256).fill(-1);

  for (var i = 0; i < base64Chars.length; ++i) {
    base64M[base64Chars.charCodeAt(i)] = i;
  }

  base64M['='.charCodeAt(0)] = 0;
  return base64M;
};

var base64Map = /*#__PURE__*/create_base64_map();
/** Is `bignum` a negative number? */

var isNegative = function isNegative(bignum) {
  return (bignum[bignum.length - 1] & 0x80) !== 0;
};
/** Negate `bignum` */

var negate = function negate(bignum) {
  var carry = 1;

  for (var i = 0; i < bignum.length; ++i) {
    var x = (~bignum[i] & 0xff) + carry;
    bignum[i] = x;
    carry = x >> 8;
  }
};
/**
 * Convert an unsigned decimal number in `s` to a bignum
 *
 * @param size bignum size (bytes)
 */

var decimalToBinary = function decimalToBinary(size, s) {
  var result = new Uint8Array(size);

  for (var i = 0; i < s.length; ++i) {
    var srcDigit = s.charCodeAt(i);

    if (srcDigit < '0'.charCodeAt(0) || srcDigit > '9'.charCodeAt(0)) {
      throw new Error('invalid number');
    }

    var carry = srcDigit - '0'.charCodeAt(0);

    for (var j = 0; j < size; ++j) {
      var x = result[j] * 10 + carry;
      result[j] = x;
      carry = x >> 8;
    }

    if (carry) {
      throw new Error('number is out of range');
    }
  }

  return result;
};
/**
 * Convert a signed decimal number in `s` to a bignum
 *
 * @param size bignum size (bytes)
 */

var signedDecimalToBinary = function signedDecimalToBinary(size, s) {
  var negative = s[0] === '-';

  if (negative) {
    s = s.substr(1);
  }

  var result = decimalToBinary(size, s);

  if (negative) {
    negate(result);

    if (!isNegative(result)) {
      throw new Error('number is out of range');
    }
  } else if (isNegative(result)) {
    throw new Error('number is out of range');
  }

  return result;
};
/**
 * Convert `bignum` to an unsigned decimal number
 *
 * @param minDigits 0-pad result to this many digits
 */

var binaryToDecimal = function binaryToDecimal(bignum, minDigits) {
  if (minDigits === void 0) {
    minDigits = 1;
  }

  var result = Array(minDigits).fill('0'.charCodeAt(0));

  for (var i = bignum.length - 1; i >= 0; --i) {
    var carry = bignum[i];

    for (var j = 0; j < result.length; ++j) {
      var x = (result[j] - '0'.charCodeAt(0) << 8) + carry;
      result[j] = '0'.charCodeAt(0) + x % 10;
      carry = x / 10 | 0;
    }

    while (carry) {
      result.push('0'.charCodeAt(0) + carry % 10);
      carry = carry / 10 | 0;
    }
  }

  result.reverse();
  return String.fromCharCode.apply(String, result);
};
/**
 * Convert `bignum` to a signed decimal number
 *
 * @param minDigits 0-pad result to this many digits
 */

var signedBinaryToDecimal = function signedBinaryToDecimal(bignum, minDigits) {
  if (minDigits === void 0) {
    minDigits = 1;
  }

  if (isNegative(bignum)) {
    var x = bignum.slice();
    negate(x);
    return '-' + binaryToDecimal(x, minDigits);
  }

  return binaryToDecimal(bignum, minDigits);
};

var base58ToBinaryVarSize = function base58ToBinaryVarSize(s) {
  var result = [];

  for (var i = 0; i < s.length; ++i) {
    var carry = base58Map[s.charCodeAt(i)];

    if (carry < 0) {
      throw new Error('invalid base-58 value');
    }

    for (var j = 0; j < result.length; ++j) {
      var x = result[j] * 58 + carry;
      result[j] = x & 0xff;
      carry = x >> 8;
    }

    if (carry) {
      result.push(carry);
    }
  }

  for (var _iterator = _createForOfIteratorHelperLoose(s), _step; !(_step = _iterator()).done;) {
    var ch = _step.value;

    if (ch === '1') {
      result.push(0);
    } else {
      break;
    }
  }

  result.reverse();
  return new Uint8Array(result);
};
/**
 * Convert an unsigned base-58 number in `s` to a bignum
 *
 * @param size bignum size (bytes)
 */


var base58ToBinary = function base58ToBinary(size, s) {
  if (!size) {
    return base58ToBinaryVarSize(s);
  }

  var result = new Uint8Array(size);

  for (var i = 0; i < s.length; ++i) {
    var carry = base58Map[s.charCodeAt(i)];

    if (carry < 0) {
      throw new Error('invalid base-58 value');
    }

    for (var j = 0; j < size; ++j) {
      var x = result[j] * 58 + carry;
      result[j] = x;
      carry = x >> 8;
    }

    if (carry) {
      throw new Error('base-58 value is out of range');
    }
  }

  result.reverse();
  return result;
};
/**
 * Convert `bignum` to a base-58 number
 *
 * @param minDigits 0-pad result to this many digits
 */

var binaryToBase58 = function binaryToBase58(bignum) {
  var result = [];

  for (var _iterator2 = _createForOfIteratorHelperLoose(bignum), _step2; !(_step2 = _iterator2()).done;) {
    var _byte = _step2.value;
    var carry = _byte;

    for (var j = 0; j < result.length; ++j) {
      var x = (base58Map[result[j]] << 8) + carry;
      result[j] = base58Chars.charCodeAt(x % 58);
      carry = x / 58 | 0;
    }

    while (carry) {
      result.push(base58Chars.charCodeAt(carry % 58));
      carry = carry / 58 | 0;
    }
  }

  for (var _iterator3 = _createForOfIteratorHelperLoose(bignum), _step3; !(_step3 = _iterator3()).done;) {
    var _byte2 = _step3.value;

    if (_byte2) {
      break;
    } else {
      result.push('1'.charCodeAt(0));
    }
  }

  result.reverse();
  return String.fromCharCode.apply(String, result);
};
/** Convert an unsigned base-64 number in `s` to a bignum */

var base64ToBinary = function base64ToBinary(s) {
  var len = s.length;

  if ((len & 3) === 1 && s[len - 1] === '=') {
    len -= 1;
  } // fc appends an extra '='


  if ((len & 3) !== 0) {
    throw new Error('base-64 value is not padded correctly');
  }

  var groups = len >> 2;
  var bytes = groups * 3;

  if (len > 0 && s[len - 1] === '=') {
    if (s[len - 2] === '=') {
      bytes -= 2;
    } else {
      bytes -= 1;
    }
  }

  var result = new Uint8Array(bytes);

  for (var group = 0; group < groups; ++group) {
    var digit0 = base64Map[s.charCodeAt(group * 4 + 0)];
    var digit1 = base64Map[s.charCodeAt(group * 4 + 1)];
    var digit2 = base64Map[s.charCodeAt(group * 4 + 2)];
    var digit3 = base64Map[s.charCodeAt(group * 4 + 3)];
    result[group * 3 + 0] = digit0 << 2 | digit1 >> 4;

    if (group * 3 + 1 < bytes) {
      result[group * 3 + 1] = (digit1 & 15) << 4 | digit2 >> 2;
    }

    if (group * 3 + 2 < bytes) {
      result[group * 3 + 2] = (digit2 & 3) << 6 | digit3;
    }
  }

  return result;
};
/** Key types this library supports */

var KeyType;

(function (KeyType) {
  KeyType[KeyType["k1"] = 0] = "k1";
  KeyType[KeyType["r1"] = 1] = "r1";
  KeyType[KeyType["wa"] = 2] = "wa";
  KeyType[KeyType["rsa"] = 100] = "rsa";
  KeyType[KeyType["eth"] = 101] = "eth";
})(KeyType || (KeyType = {}));
/** Public key data size, excluding type field */


var publicKeyDataSize = 33;
/** Private key data size, excluding type field */

var privateKeyDataSize = 32;
/** Signature data size, excluding type field */

var signatureDataSize = 65;

var digestSuffixRipemd160 = function digestSuffixRipemd160(data, suffix) {
  var d = new Uint8Array(data.length + suffix.length);

  for (var i = 0; i < data.length; ++i) {
    d[i] = data[i];
  }

  for (var _i = 0; _i < suffix.length; ++_i) {
    d[data.length + _i] = suffix.charCodeAt(_i);
  }

  return ripemd160(d);
};

var stringToKey = function stringToKey(s, type, size, suffix) {
  var whole = base58ToBinary(size ? size + 4 : 0, s);
  var result = {
    type: type,
    data: new Uint8Array(whole.buffer, 0, whole.length - 4)
  };
  var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));

  if (digest[0] !== whole[whole.length - 4] || digest[1] !== whole[whole.length - 3] || digest[2] !== whole[whole.length - 2] || digest[3] !== whole[whole.length - 1]) {
    throw new Error('checksum doesn\'t match');
  }

  return result;
};

var keyToString = function keyToString(key, suffix, prefix) {
  var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
  var whole = new Uint8Array(key.data.length + 4);

  for (var i = 0; i < key.data.length; ++i) {
    whole[i] = key.data[i];
  }

  for (var _i2 = 0; _i2 < 4; ++_i2) {
    whole[_i2 + key.data.length] = digest[_i2];
  }

  return prefix + binaryToBase58(whole);
};
/** Convert key in `s` to binary form */


var stringToPublicKey = function stringToPublicKey(s, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  if (typeof s !== 'string') {
    throw new Error('expected string containing public key');
  }

  if (s.substr(0, 3) === prefix) {
    var whole = base58ToBinary(publicKeyDataSize + 4, s.substr(3));
    var key = {
      type: KeyType.k1,
      data: new Uint8Array(publicKeyDataSize)
    };

    for (var i = 0; i < publicKeyDataSize; ++i) {
      key.data[i] = whole[i];
    }

    var digest = new Uint8Array(ripemd160(key.data));

    if (digest[0] !== whole[publicKeyDataSize] || digest[1] !== whole[34] || digest[2] !== whole[35] || digest[3] !== whole[36]) {
      throw new Error('checksum doesn\'t match');
    }

    return key;
  } else if (s.substr(0, 7) === 'PUB_K1_') {
    return stringToKey(s.substr(7), KeyType.k1, publicKeyDataSize, 'K1');
  } else if (s.substr(0, 7) === 'PUB_R1_') {
    return stringToKey(s.substr(7), KeyType.r1, publicKeyDataSize, 'R1');
  } else if (s.substr(0, 7) === 'PUB_WA_') {
    return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** Convert public `key` to legacy string (base-58) form */

var publicKeyToLegacyString = function publicKeyToLegacyString(key, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {
    return keyToString(key, '', prefix);
  } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
    throw new Error('Key format not supported in legacy conversion');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** Convert `key` to string (base-58) form */

var publicKeyToString = function publicKeyToString(key) {
  if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {
    return keyToString(key, 'K1', 'PUB_K1_');
  } else if (key.type === KeyType.r1 && key.data.length === publicKeyDataSize) {
    return keyToString(key, 'R1', 'PUB_R1_');
  } else if (key.type === KeyType.wa) {
    return keyToString(key, 'WA', 'PUB_WA_');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).
 * Leaves other formats untouched
 */

var convertLegacyPublicKey = function convertLegacyPublicKey(s, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  if (s.substr(0, 3) === prefix) {
    return publicKeyToString(stringToPublicKey(s, prefix));
  }

  return s;
};
/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).
 * Leaves other formats untouched
 */

var convertLegacyPublicKeys = function convertLegacyPublicKeys(keys, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  return keys.map(function (key) {
    return convertLegacyPublicKey(key, prefix);
  });
};
/** Convert key in `s` to binary form */

var stringToPrivateKey = function stringToPrivateKey(s) {
  if (typeof s !== 'string') {
    throw new Error('expected string containing private key');
  }

  if (s.substr(0, 7) === 'PVT_R1_') {
    return stringToKey(s.substr(7), KeyType.r1, privateKeyDataSize, 'R1');
  } else if (s.substr(0, 7) === 'PVT_K1_') {
    return stringToKey(s.substr(7), KeyType.k1, privateKeyDataSize, 'K1');
  } else {
    // todo: Verify checksum: sha256(sha256(key.data)).
    //       Not critical since a bad key will fail to produce a
    //       valid signature anyway.
    var whole = base58ToBinary(privateKeyDataSize + 5, s);
    var key = {
      type: KeyType.k1,
      data: new Uint8Array(privateKeyDataSize)
    };

    if (whole[0] !== 0x80) {
      throw new Error('unrecognized private key type');
    }

    for (var i = 0; i < privateKeyDataSize; ++i) {
      key.data[i] = whole[i + 1];
    }

    return key;
  }
};
/** Convert private `key` to legacy string (base-58) form */

var privateKeyToLegacyString = function privateKeyToLegacyString(key) {
  if (key.type === KeyType.k1 && key.data.length === privateKeyDataSize) {
    var whole = [];
    whole.push(128);
    key.data.forEach(function (_byte3) {
      return whole.push(_byte3);
    });
    var digest = new Uint8Array(sha256$1().update(sha256$1().update(whole).digest()).digest());
    var result = new Uint8Array(privateKeyDataSize + 5);

    for (var i = 0; i < whole.length; i++) {
      result[i] = whole[i];
    }

    for (var _i3 = 0; _i3 < 4; _i3++) {
      result[_i3 + whole.length] = digest[_i3];
    }

    return binaryToBase58(result);
  } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
    throw new Error('Key format not supported in legacy conversion');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** Convert `key` to string (base-58) form */

var privateKeyToString = function privateKeyToString(key) {
  if (key.type === KeyType.r1) {
    return keyToString(key, 'R1', 'PVT_R1_');
  } else if (key.type === KeyType.k1) {
    return keyToString(key, 'K1', 'PVT_K1_');
  } else {
    throw new Error('unrecognized private key format');
  }
};
/** Convert key in `s` to binary form */

var stringToSignature = function stringToSignature(s) {
  if (typeof s !== 'string') {
    throw new Error('expected string containing signature');
  }

  if (s.substr(0, 7) === 'SIG_K1_') {
    return stringToKey(s.substr(7), KeyType.k1, signatureDataSize, 'K1');
  } else if (s.substr(0, 7) === 'SIG_R1_') {
    return stringToKey(s.substr(7), KeyType.r1, signatureDataSize, 'R1');
  } else if (s.substr(0, 7) === 'SIG_WA_') {
    return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');
  } else {
    throw new Error('unrecognized signature format');
  }
};
/** Convert `signature` to string (base-58) form */

var signatureToString = function signatureToString(signature) {
  if (signature.type === KeyType.k1) {
    return keyToString(signature, 'K1', 'SIG_K1_');
  } else if (signature.type === KeyType.r1) {
    return keyToString(signature, 'R1', 'SIG_R1_');
  } else if (signature.type === KeyType.wa) {
    return keyToString(signature, 'WA', 'SIG_WA_');
  } else {
    throw new Error('unrecognized signature format');
  }
};

var Numeric = {
  __proto__: null,
  isNegative: isNegative,
  negate: negate,
  decimalToBinary: decimalToBinary,
  signedDecimalToBinary: signedDecimalToBinary,
  binaryToDecimal: binaryToDecimal,
  signedBinaryToDecimal: signedBinaryToDecimal,
  base58ToBinary: base58ToBinary,
  binaryToBase58: binaryToBase58,
  base64ToBinary: base64ToBinary,
  get KeyType () { return KeyType; },
  publicKeyDataSize: publicKeyDataSize,
  privateKeyDataSize: privateKeyDataSize,
  signatureDataSize: signatureDataSize,
  stringToPublicKey: stringToPublicKey,
  publicKeyToLegacyString: publicKeyToLegacyString,
  publicKeyToString: publicKeyToString,
  convertLegacyPublicKey: convertLegacyPublicKey,
  convertLegacyPublicKeys: convertLegacyPublicKeys,
  stringToPrivateKey: stringToPrivateKey,
  privateKeyToLegacyString: privateKeyToLegacyString,
  privateKeyToString: privateKeyToString,
  stringToSignature: stringToSignature,
  signatureToString: signatureToString
};

/** State for serialize() and deserialize() */

var SerializerState =
/** Have any binary extensions been skipped? */
function SerializerState(options) {
  if (options === void 0) {
    options = {};
  }

  this.options = void 0;
  this.skippedBinaryExtension = false;
  this.options = options;
};
/** Serialize and deserialize data */

var SerialBuffer = /*#__PURE__*/function () {
  /** Amount of valid data in `array` */

  /** Data in serialized (binary) form */

  /** Current position while reading (deserializing) */

  /**
   * @param __namedParameters
   * `array`: `null` if serializing, or binary data to deserialize
   * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser
   * `textDecoder`: `TextDecider` instance to use. Pass in `null` if running in a browser
   */
  function SerialBuffer(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        array = _ref.array,
        textEncoder = _ref.textEncoder,
        textDecoder = _ref.textDecoder;

    this.length = void 0;
    this.array = void 0;
    this.readPos = 0;
    this.textEncoder = void 0;
    this.textDecoder = void 0;
    this.array = array || new Uint8Array(1024);
    this.length = array ? array.length : 0;
    this.textEncoder = textEncoder || new TextEncoder();
    this.textDecoder = textDecoder || new TextDecoder('utf-8');
  }
  /** Resize `array` if needed to have at least `size` bytes free */


  var _proto = SerialBuffer.prototype;

  _proto.reserve = function reserve(size) {
    if (this.length + size <= this.array.length) {
      return;
    }

    var l = this.array.length;

    while (this.length + size > l) {
      l = Math.ceil(l * 1.5);
    }

    var newArray = new Uint8Array(l);
    newArray.set(this.array);
    this.array = newArray;
  }
  /** Is there data available to read? */
  ;

  _proto.haveReadData = function haveReadData() {
    return this.readPos < this.length;
  }
  /** Restart reading from the beginning */
  ;

  _proto.restartRead = function restartRead() {
    this.readPos = 0;
  }
  /** Return data with excess storage trimmed away */
  ;

  _proto.asUint8Array = function asUint8Array() {
    return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
  }
  /** Append bytes */
  ;

  _proto.pushArray = function pushArray(v) {
    this.reserve(v.length);
    this.array.set(v, this.length);
    this.length += v.length;
  }
  /** Append bytes */
  ;

  _proto.push = function push() {
    for (var _len = arguments.length, v = new Array(_len), _key = 0; _key < _len; _key++) {
      v[_key] = arguments[_key];
    }

    this.pushArray(v);
  }
  /** Get a single byte */
  ;

  _proto.get = function get() {
    if (this.readPos < this.length) {
      return this.array[this.readPos++];
    }

    throw new Error('Read past end of buffer');
  }
  /** Append bytes in `v`. Throws if `len` doesn't match `v.length` */
  ;

  _proto.pushUint8ArrayChecked = function pushUint8ArrayChecked(v, len) {
    if (v.length !== len) {
      throw new Error('Binary data has incorrect size');
    }

    this.pushArray(v);
  }
  /** Get `len` bytes */
  ;

  _proto.getUint8Array = function getUint8Array(len) {
    if (this.readPos + len > this.length) {
      throw new Error('Read past end of buffer');
    }

    var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
    this.readPos += len;
    return result;
  }
  /** Skip `len` bytes */
  ;

  _proto.skip = function skip(len) {
    if (this.readPos + len > this.length) {
      throw new Error('Read past end of buffer');
    }

    this.readPos += len;
  }
  /** Append a `uint16` */
  ;

  _proto.pushUint16 = function pushUint16(v) {
    this.push(v >> 0 & 0xff, v >> 8 & 0xff);
  }
  /** Get a `uint16` */
  ;

  _proto.getUint16 = function getUint16() {
    var v = 0;
    v |= this.get() << 0;
    v |= this.get() << 8;
    return v;
  }
  /** Append a `uint32` */
  ;

  _proto.pushUint32 = function pushUint32(v) {
    this.push(v >> 0 & 0xff, v >> 8 & 0xff, v >> 16 & 0xff, v >> 24 & 0xff);
  }
  /** Get a `uint32` */
  ;

  _proto.getUint32 = function getUint32() {
    var v = 0;
    v |= this.get() << 0;
    v |= this.get() << 8;
    v |= this.get() << 16;
    v |= this.get() << 24;
    return v >>> 0;
  }
  /** Append a `uint64`. *Caution*: `number` only has 53 bits of precision */
  ;

  _proto.pushNumberAsUint64 = function pushNumberAsUint64(v) {
    this.pushUint32(v >>> 0);
    this.pushUint32(Math.floor(v / 0x100000000) >>> 0);
  }
  /**
   * Get a `uint64` as a `number`. *Caution*: `number` only has 53 bits of precision; some values will change.
   * `numeric.binaryToDecimal(serialBuffer.getUint8Array(8))` recommended instead
   */
  ;

  _proto.getUint64AsNumber = function getUint64AsNumber() {
    var low = this.getUint32();
    var high = this.getUint32();
    return (high >>> 0) * 0x100000000 + (low >>> 0);
  }
  /** Append a `varuint32` */
  ;

  _proto.pushVaruint32 = function pushVaruint32(v) {
    while (true) {
      if (v >>> 7) {
        this.push(0x80 | v & 0x7f);
        v = v >>> 7;
      } else {
        this.push(v);
        break;
      }
    }
  }
  /** Get a `varuint32` */
  ;

  _proto.getVaruint32 = function getVaruint32() {
    var v = 0;
    var bit = 0;

    while (true) {
      var b = this.get();
      v |= (b & 0x7f) << bit;
      bit += 7;

      if (!(b & 0x80)) {
        break;
      }
    }

    return v >>> 0;
  }
  /** Append a `varint32` */
  ;

  _proto.pushVarint32 = function pushVarint32(v) {
    this.pushVaruint32(v << 1 ^ v >> 31);
  }
  /** Get a `varint32` */
  ;

  _proto.getVarint32 = function getVarint32() {
    var v = this.getVaruint32();

    if (v & 1) {
      return ~v >> 1 | 0x80000000;
    } else {
      return v >>> 1;
    }
  }
  /** Append a `float32` */
  ;

  _proto.pushFloat32 = function pushFloat32(v) {
    this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
  }
  /** Get a `float32` */
  ;

  _proto.getFloat32 = function getFloat32() {
    return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
  }
  /** Append a `float64` */
  ;

  _proto.pushFloat64 = function pushFloat64(v) {
    this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
  }
  /** Get a `float64` */
  ;

  _proto.getFloat64 = function getFloat64() {
    return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
  }
  /** Append a `name` */
  ;

  _proto.pushName = function pushName(s) {
    if (typeof s !== 'string') {
      throw new Error('Expected string containing name');
    }

    var regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);

    if (!regex.test(s)) {
      throw new Error('Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz'); // eslint-disable-line
    }

    var charToSymbol = function charToSymbol(c) {
      if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {
        return c - 'a'.charCodeAt(0) + 6;
      }

      if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {
        return c - '1'.charCodeAt(0) + 1;
      }

      return 0;
    };

    var a = new Uint8Array(8);
    var bit = 63;

    for (var i = 0; i < s.length; ++i) {
      var c = charToSymbol(s.charCodeAt(i));

      if (bit < 5) {
        c = c << 1;
      }

      for (var j = 4; j >= 0; --j) {
        if (bit >= 0) {
          a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
          --bit;
        }
      }
    }

    this.pushArray(a);
  }
  /** Get a `name` */
  ;

  _proto.getName = function getName() {
    var a = this.getUint8Array(8);
    var result = '';

    for (var bit = 63; bit >= 0;) {
      var c = 0;

      for (var i = 0; i < 5; ++i) {
        if (bit >= 0) {
          c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
          --bit;
        }
      }

      if (c >= 6) {
        result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);
      } else if (c >= 1) {
        result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);
      } else {
        result += '.';
      }
    }

    while (result.endsWith('.')) {
      result = result.substr(0, result.length - 1);
    }

    return result;
  }
  /** Append length-prefixed binary data */
  ;

  _proto.pushBytes = function pushBytes(v) {
    this.pushVaruint32(v.length);
    this.pushArray(v);
  }
  /** Get length-prefixed binary data */
  ;

  _proto.getBytes = function getBytes() {
    return this.getUint8Array(this.getVaruint32());
  }
  /** Append a string */
  ;

  _proto.pushString = function pushString(v) {
    this.pushBytes(this.textEncoder.encode(v));
  }
  /** Get a string */
  ;

  _proto.getString = function getString() {
    return this.textDecoder.decode(this.getBytes());
  }
  /** Append a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */
  ;

  _proto.pushSymbolCode = function pushSymbolCode(name) {
    if (typeof name !== 'string') {
      throw new Error('Expected string containing symbol_code');
    }

    var a = [];
    a.push.apply(a, this.textEncoder.encode(name));

    while (a.length < 8) {
      a.push(0);
    }

    this.pushArray(a.slice(0, 8));
  }
  /** Get a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */
  ;

  _proto.getSymbolCode = function getSymbolCode() {
    var a = this.getUint8Array(8);
    var len;

    for (len = 0; len < a.length; ++len) {
      if (!a[len]) {
        break;
      }
    }

    var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
    return name;
  }
  /** Append a `symbol` */
  ;

  _proto.pushSymbol = function pushSymbol(_ref2) {
    var name = _ref2.name,
        precision = _ref2.precision;

    if (!/^[A-Z]{1,7}$/.test(name)) {
      throw new Error('Expected symbol to be A-Z and between one and seven characters');
    }

    var a = [precision & 0xff];
    a.push.apply(a, this.textEncoder.encode(name));

    while (a.length < 8) {
      a.push(0);
    }

    this.pushArray(a.slice(0, 8));
  }
  /** Get a `symbol` */
  ;

  _proto.getSymbol = function getSymbol() {
    var precision = this.get();
    var a = this.getUint8Array(7);
    var len;

    for (len = 0; len < a.length; ++len) {
      if (!a[len]) {
        break;
      }
    }

    var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
    return {
      name: name,
      precision: precision
    };
  }
  /** Append an asset */
  ;

  _proto.pushAsset = function pushAsset(s) {
    if (typeof s !== 'string') {
      throw new Error('Expected string containing asset');
    }

    s = s.trim();
    var pos = 0;
    var amount = '';
    var precision = 0;

    if (s[pos] === '-') {
      amount += '-';
      ++pos;
    }

    var foundDigit = false;

    while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
      foundDigit = true;
      amount += s[pos];
      ++pos;
    }

    if (!foundDigit) {
      throw new Error('Asset must begin with a number');
    }

    if (s[pos] === '.') {
      ++pos;

      while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
        amount += s[pos];
        ++precision;
        ++pos;
      }
    }

    var name = s.substr(pos).trim();
    this.pushArray(signedDecimalToBinary(8, amount));
    this.pushSymbol({
      name: name,
      precision: precision
    });
  }
  /** Get an asset */
  ;

  _proto.getAsset = function getAsset() {
    var amount = this.getUint8Array(8);

    var _this$getSymbol = this.getSymbol(),
        name = _this$getSymbol.name,
        precision = _this$getSymbol.precision;

    var s = signedBinaryToDecimal(amount, precision + 1);

    if (precision) {
      s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);
    }

    return s + ' ' + name;
  }
  /** Append a public key */
  ;

  _proto.pushPublicKey = function pushPublicKey(s) {
    var key = stringToPublicKey(s);
    this.push(key.type);
    this.pushArray(key.data);
  }
  /** Get a public key */
  ;

  _proto.getPublicKey = function getPublicKey() {
    var type = this.get();
    var data;

    if (type === KeyType.wa) {
      var begin = this.readPos;
      this.skip(34);
      this.skip(this.getVaruint32());
      data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
    } else {
      data = this.getUint8Array(publicKeyDataSize);
    }

    return publicKeyToString({
      type: type,
      data: data
    });
  }
  /** Append a private key */
  ;

  _proto.pushPrivateKey = function pushPrivateKey(s) {
    var key = stringToPrivateKey(s);
    this.push(key.type);
    this.pushArray(key.data);
  }
  /** Get a private key */
  ;

  _proto.getPrivateKey = function getPrivateKey() {
    var type = this.get();
    var data = this.getUint8Array(privateKeyDataSize);
    return privateKeyToString({
      type: type,
      data: data
    });
  }
  /** Append a signature */
  ;

  _proto.pushSignature = function pushSignature(s) {
    var key = stringToSignature(s);
    this.push(key.type);
    this.pushArray(key.data);
  }
  /** Get a signature */
  ;

  _proto.getSignature = function getSignature() {
    var type = this.get();
    var data;

    if (type === KeyType.wa) {
      var begin = this.readPos;
      this.skip(65);
      this.skip(this.getVaruint32());
      this.skip(this.getVaruint32());
      data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
    } else {
      data = this.getUint8Array(signatureDataSize);
    }

    return signatureToString({
      type: type,
      data: data
    });
  };

  return SerialBuffer;
}(); // SerialBuffer

/** Is this a supported ABI version? */

var supportedAbiVersion = function supportedAbiVersion(version) {
  return version.startsWith('eosio::abi/1.');
};

var checkDateParse = function checkDateParse(date) {
  var result = Date.parse(date);

  if (Number.isNaN(result)) {
    throw new Error('Invalid time format');
  }

  return result;
};
/** Convert date in ISO format to `time_point` (miliseconds since epoch) */


var dateToTimePoint = function dateToTimePoint(date) {
  return Math.round(checkDateParse(date + 'Z') * 1000);
};
/** Convert `time_point` (miliseconds since epoch) to date in ISO format */

var timePointToDate = function timePointToDate(us) {
  var s = new Date(us / 1000).toISOString();
  return s.substr(0, s.length - 1);
};
/** Convert date in ISO format to `time_point_sec` (seconds since epoch) */

var dateToTimePointSec = function dateToTimePointSec(date) {
  return Math.round(checkDateParse(date + 'Z') / 1000);
};
/** Convert `time_point_sec` (seconds since epoch) to to date in ISO format */

var timePointSecToDate = function timePointSecToDate(sec) {
  var s = new Date(sec * 1000).toISOString();
  return s.substr(0, s.length - 1);
};
/** Convert date in ISO format to `block_timestamp_type` (half-seconds since a different epoch) */

var dateToBlockTimestamp = function dateToBlockTimestamp(date) {
  return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);
};
/** Convert `block_timestamp_type` (half-seconds since a different epoch) to to date in ISO format */

var blockTimestampToDate = function blockTimestampToDate(slot) {
  var s = new Date(slot * 500 + 946684800000).toISOString();
  return s.substr(0, s.length - 1);
};
/** Convert `string` to `Symbol`. format: `precision,NAME`. */

var stringToSymbol = function stringToSymbol(s) {
  if (typeof s !== 'string') {
    throw new Error('Expected string containing symbol');
  }

  var m = s.match(/^([0-9]+),([A-Z]+)$/);

  if (!m) {
    throw new Error('Invalid symbol');
  }

  return {
    name: m[2],
    precision: +m[1]
  };
};
/** Convert `Symbol` to `string`. format: `precision,NAME`. */

var symbolToString = function symbolToString(_ref3) {
  var name = _ref3.name,
      precision = _ref3.precision;
  return precision + ',' + name;
};
/** Convert binary data to hex */

var arrayToHex = function arrayToHex(data) {
  var result = '';

  for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done;) {
    var x = _step.value;
    result += ('00' + x.toString(16)).slice(-2);
  }

  return result.toUpperCase();
};
/** Convert hex to binary data */

var hexToUint8Array = function hexToUint8Array(hex) {
  if (typeof hex !== 'string') {
    throw new Error('Expected string containing hex digits');
  }

  if (hex.length % 2) {
    throw new Error('Odd number of hex digits');
  }

  var l = hex.length / 2;
  var result = new Uint8Array(l);

  for (var i = 0; i < l; ++i) {
    var x = parseInt(hex.substr(i * 2, 2), 16);

    if (Number.isNaN(x)) {
      throw new Error('Expected hex string');
    }

    result[i] = x;
  }

  return result;
};

function serializeUnknown(_, __) {
  throw new Error('Don\'t know how to serialize ' + this.name);
}

function deserializeUnknown(_) {
  throw new Error('Don\'t know how to deserialize ' + this.name);
}

function serializeStruct(buffer, data, state, allowExtensions) {
  if (state === void 0) {
    state = new SerializerState();
  }

  if (allowExtensions === void 0) {
    allowExtensions = true;
  }

  if (typeof data !== 'object') {
    throw new Error('expected object containing data: ' + JSON.stringify(data));
  }

  if (this.base) {
    this.base.serialize(buffer, data, state, allowExtensions);
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose(this.fields), _step2; !(_step2 = _iterator2()).done;) {
    var field = _step2.value;

    if (field.name in data) {
      if (state.skippedBinaryExtension) {
        throw new Error('unexpected ' + this.name + '.' + field.name);
      }

      field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
    } else {
      if (allowExtensions && field.type.extensionOf) {
        state.skippedBinaryExtension = true;
      } else {
        throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type.name + ')');
      }
    }
  }
}

function deserializeStruct(buffer, state, allowExtensions) {
  if (state === void 0) {
    state = new SerializerState();
  }

  if (allowExtensions === void 0) {
    allowExtensions = true;
  }

  var result;

  if (this.base) {
    result = this.base.deserialize(buffer, state, allowExtensions);
  } else {
    result = {};
  }

  for (var _iterator3 = _createForOfIteratorHelperLoose(this.fields), _step3; !(_step3 = _iterator3()).done;) {
    var field = _step3.value;

    if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {
      state.skippedBinaryExtension = true;
    } else {
      result[field.name] = field.type.deserialize(buffer, state, allowExtensions);
    }
  }

  return result;
}

function serializeVariant(buffer, data, state, allowExtensions) {
  if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== 'string') {
    throw new Error('expected variant: ["type", value]');
  }

  var i = this.fields.findIndex(function (field) {
    return field.name === data[0];
  });

  if (i < 0) {
    throw new Error("type \"" + data[0] + "\" is not valid for variant");
  }

  buffer.pushVaruint32(i);
  this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);
}

function deserializeVariant(buffer, state, allowExtensions) {
  var i = buffer.getVaruint32();

  if (i >= this.fields.length) {
    throw new Error("type index " + i + " is not valid for variant");
  }

  var field = this.fields[i];
  return [field.name, field.type.deserialize(buffer, state, allowExtensions)];
}

function serializeArray(buffer, data, state, _) {
  buffer.pushVaruint32(data.length);

  for (var _iterator4 = _createForOfIteratorHelperLoose(data), _step4; !(_step4 = _iterator4()).done;) {
    var item = _step4.value;
    this.arrayOf.serialize(buffer, item, state, false);
  }
}

function deserializeArray(buffer, state, _) {
  var len = buffer.getVaruint32();
  var result = [];

  for (var i = 0; i < len; ++i) {
    result.push(this.arrayOf.deserialize(buffer, state, false));
  }

  return result;
}

function serializeOptional(buffer, data, state, allowExtensions) {
  if (data === null || data === undefined) {
    buffer.push(0);
  } else {
    buffer.push(1);
    this.optionalOf.serialize(buffer, data, state, allowExtensions);
  }
}

function deserializeOptional(buffer, state, allowExtensions) {
  if (buffer.get()) {
    return this.optionalOf.deserialize(buffer, state, allowExtensions);
  } else {
    return null;
  }
}

function serializeExtension(buffer, data, state, allowExtensions) {
  this.extensionOf.serialize(buffer, data, state, allowExtensions);
}

function deserializeExtension(buffer, state, allowExtensions) {
  return this.extensionOf.deserialize(buffer, state, allowExtensions);
}

function serializeObject(buffer, data, state, allowExtensions) {
  var entries = Object.entries(data);
  buffer.pushVaruint32(entries.length);

  for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
    var _entries$_i = _entries[_i],
        key = _entries$_i[0],
        value = _entries$_i[1];
    var keyType = this.fields[0].type;
    var dataType = this.fields[1].type;
    keyType.serialize(buffer, key, state, allowExtensions);
    dataType.serialize(buffer, value, state, allowExtensions);
  }
}

function deserializeObject(buffer, state, allowExtensions) {
  var len = buffer.getVaruint32();
  var result = {};

  for (var i = 0; i < len; ++i) {
    var keyType = this.fields[0].type;
    var dataType = this.fields[1].type;
    var key = keyType.deserialize(buffer, state, allowExtensions);
    result[key] = dataType.deserialize(buffer, state, allowExtensions);
  }

  return result;
}

function serializePair(buffer, data, state, allowExtensions) {
  var _this = this;

  buffer.pushVaruint32(data.length);
  data.forEach(function (item) {
    _this.fields[0].type.serialize(buffer, item[0], state, allowExtensions);

    _this.fields[1].type.serialize(buffer, item[1], state, allowExtensions);
  });
}

function deserializePair(buffer, state, allowExtensions) {
  var result = [];
  var len = buffer.getVaruint32();

  for (var i = 0; i < len; ++i) {
    result.push(this.fields[0].type.deserialize(buffer, state, allowExtensions));
    result.push(this.fields[1].type.deserialize(buffer, state, allowExtensions));
  }

  return result;
}

var createType = function createType(attrs) {
  return Object.assign({
    name: '<missing name>',
    aliasOfName: '',
    arrayOf: undefined,
    optionalOf: undefined,
    extensionOf: undefined,
    baseName: '',
    base: undefined,
    fields: [],
    serialize: serializeUnknown,
    deserialize: deserializeUnknown
  }, attrs);
};

var checkRange = function checkRange(orig, converted) {
  if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== 'number' && typeof orig !== 'string') {
    throw new Error('Expected number');
  }

  if (+orig !== +converted) {
    throw new Error('Number is out of range');
  }

  return +orig;
};
/** Create the set of types built-in to the abi format */


var createInitialTypes = function createInitialTypes() {
  var result = new Map(Object.entries({
    bool: createType({
      name: 'bool',
      serialize: function serialize(buffer, data) {
        if (!(typeof data === 'boolean' || typeof data === 'number' && (data === 1 || data === 0))) {
          throw new Error('Expected boolean or number equal to 1 or 0');
        }

        buffer.push(data ? 1 : 0);
      },
      deserialize: function deserialize(buffer) {
        return !!buffer.get();
      }
    }),
    uint8: createType({
      name: 'uint8',
      serialize: function serialize(buffer, data) {
        buffer.push(checkRange(data, data & 0xff));
      },
      deserialize: function deserialize(buffer) {
        return buffer.get();
      }
    }),
    int8: createType({
      name: 'int8',
      serialize: function serialize(buffer, data) {
        buffer.push(checkRange(data, data << 24 >> 24));
      },
      deserialize: function deserialize(buffer) {
        return buffer.get() << 24 >> 24;
      }
    }),
    uint16: createType({
      name: 'uint16',
      serialize: function serialize(buffer, data) {
        buffer.pushUint16(checkRange(data, data & 0xffff));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint16();
      }
    }),
    int16: createType({
      name: 'int16',
      serialize: function serialize(buffer, data) {
        buffer.pushUint16(checkRange(data, data << 16 >> 16));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint16() << 16 >> 16;
      }
    }),
    uint32: createType({
      name: 'uint32',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(checkRange(data, data >>> 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint32();
      }
    }),
    uint64: createType({
      name: 'uint64',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(decimalToBinary(8, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return binaryToDecimal(buffer.getUint8Array(8));
      }
    }),
    int64: createType({
      name: 'int64',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(signedDecimalToBinary(8, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return signedBinaryToDecimal(buffer.getUint8Array(8));
      }
    }),
    int32: createType({
      name: 'int32',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(checkRange(data, data | 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint32() | 0;
      }
    }),
    varuint32: createType({
      name: 'varuint32',
      serialize: function serialize(buffer, data) {
        buffer.pushVaruint32(checkRange(data, data >>> 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getVaruint32();
      }
    }),
    varint32: createType({
      name: 'varint32',
      serialize: function serialize(buffer, data) {
        buffer.pushVarint32(checkRange(data, data | 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getVarint32();
      }
    }),
    uint128: createType({
      name: 'uint128',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(decimalToBinary(16, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return binaryToDecimal(buffer.getUint8Array(16));
      }
    }),
    int128: createType({
      name: 'int128',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(signedDecimalToBinary(16, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return signedBinaryToDecimal(buffer.getUint8Array(16));
      }
    }),
    float32: createType({
      name: 'float32',
      serialize: function serialize(buffer, data) {
        buffer.pushFloat32(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getFloat32();
      }
    }),
    float64: createType({
      name: 'float64',
      serialize: function serialize(buffer, data) {
        buffer.pushFloat64(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getFloat64();
      }
    }),
    float128: createType({
      name: 'float128',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(16));
      }
    }),
    bytes: createType({
      name: 'bytes',
      serialize: function serialize(buffer, data) {
        if (data instanceof Uint8Array || Array.isArray(data)) {
          buffer.pushBytes(data);
        } else {
          buffer.pushBytes(hexToUint8Array(data));
        }
      },
      deserialize: function deserialize(buffer, state) {
        if (state && state.options.bytesAsUint8Array) {
          return buffer.getBytes();
        } else {
          return arrayToHex(buffer.getBytes());
        }
      }
    }),
    string: createType({
      name: 'string',
      serialize: function serialize(buffer, data) {
        buffer.pushString(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getString();
      }
    }),
    name: createType({
      name: 'name',
      serialize: function serialize(buffer, data) {
        buffer.pushName(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getName();
      }
    }),
    time_point: createType({
      name: 'time_point',
      serialize: function serialize(buffer, data) {
        buffer.pushNumberAsUint64(dateToTimePoint(data));
      },
      deserialize: function deserialize(buffer) {
        return timePointToDate(buffer.getUint64AsNumber());
      }
    }),
    time_point_sec: createType({
      name: 'time_point_sec',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(dateToTimePointSec(data));
      },
      deserialize: function deserialize(buffer) {
        return timePointSecToDate(buffer.getUint32());
      }
    }),
    block_timestamp_type: createType({
      name: 'block_timestamp_type',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(dateToBlockTimestamp(data));
      },
      deserialize: function deserialize(buffer) {
        return blockTimestampToDate(buffer.getUint32());
      }
    }),
    symbol_code: createType({
      name: 'symbol_code',
      serialize: function serialize(buffer, data) {
        buffer.pushSymbolCode(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getSymbolCode();
      }
    }),
    symbol: createType({
      name: 'symbol',
      serialize: function serialize(buffer, data) {
        buffer.pushSymbol(stringToSymbol(data));
      },
      deserialize: function deserialize(buffer) {
        return symbolToString(buffer.getSymbol());
      }
    }),
    asset: createType({
      name: 'asset',
      serialize: function serialize(buffer, data) {
        buffer.pushAsset(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getAsset();
      }
    }),
    checksum160: createType({
      name: 'checksum160',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(20));
      }
    }),
    checksum256: createType({
      name: 'checksum256',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(32));
      }
    }),
    checksum512: createType({
      name: 'checksum512',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(64));
      }
    }),
    public_key: createType({
      name: 'public_key',
      serialize: function serialize(buffer, data) {
        buffer.pushPublicKey(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getPublicKey();
      }
    }),
    private_key: createType({
      name: 'private_key',
      serialize: function serialize(buffer, data) {
        buffer.pushPrivateKey(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getPrivateKey();
      }
    }),
    signature: createType({
      name: 'signature',
      serialize: function serialize(buffer, data) {
        buffer.pushSignature(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getSignature();
      }
    })
  }));
  result.set('extended_asset', createType({
    name: 'extended_asset',
    baseName: '',
    fields: [{
      name: 'quantity',
      typeName: 'asset',
      type: result.get('asset')
    }, {
      name: 'contract',
      typeName: 'name',
      type: result.get('name')
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  return result;
}; // createInitialTypes()

var createAbiTypes = function createAbiTypes() {
  var initialTypes = createInitialTypes();
  initialTypes.set('extensions_entry', createType({
    name: 'extensions_entry',
    baseName: '',
    fields: [{
      name: 'tag',
      typeName: 'uint16',
      type: undefined
    }, {
      name: 'value',
      typeName: 'bytes',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('type_def', createType({
    name: 'type_def',
    baseName: '',
    fields: [{
      name: 'new_type_name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('field_def', createType({
    name: 'field_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('struct_def', createType({
    name: 'struct_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'base',
      typeName: 'string',
      type: undefined
    }, {
      name: 'fields',
      typeName: 'field_def[]',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('action_def', createType({
    name: 'action_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }, {
      name: 'ricardian_contract',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('table_def', createType({
    name: 'table_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'index_type',
      typeName: 'string',
      type: undefined
    }, {
      name: 'key_names',
      typeName: 'string[]',
      type: undefined
    }, {
      name: 'key_types',
      typeName: 'string[]',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('clause_pair', createType({
    name: 'clause_pair',
    baseName: '',
    fields: [{
      name: 'id',
      typeName: 'string',
      type: undefined
    }, {
      name: 'body',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('error_message', createType({
    name: 'error_message',
    baseName: '',
    fields: [{
      name: 'error_code',
      typeName: 'uint64',
      type: undefined
    }, {
      name: 'error_msg',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('variant_def', createType({
    name: 'variant_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'types',
      typeName: 'string[]',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('action_result', createType({
    name: 'action_result',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'result_type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('primary_key_index_def', createType({
    name: 'primary_key_index_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('secondary_index_def', createType({
    name: 'secondary_index_def',
    baseName: '',
    fields: [{
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('secondary_indices', createType({
    name: 'secondary_indices',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'secondary_index_def',
      typeName: 'secondary_index_def',
      type: undefined
    }],
    serialize: serializeObject,
    deserialize: deserializeObject
  }));
  initialTypes.set('kv_table_entry_def', createType({
    name: 'kv_table_entry_def',
    baseName: '',
    fields: [{
      name: 'type',
      typeName: 'string',
      type: undefined
    }, {
      name: 'primary_index',
      typeName: 'primary_key_index_def',
      type: undefined
    }, {
      name: 'secondary_indices',
      typeName: 'secondary_indices',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('kv_table', createType({
    name: 'kv_table',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'kv_table_entry_def',
      typeName: 'kv_table_entry_def',
      type: undefined
    }],
    serialize: serializeObject,
    deserialize: deserializeObject
  }));
  initialTypes.set('abi_def', createType({
    name: 'abi_def',
    baseName: '',
    fields: [{
      name: 'version',
      typeName: 'string',
      type: undefined
    }, {
      name: 'types',
      typeName: 'type_def[]',
      type: undefined
    }, {
      name: 'structs',
      typeName: 'struct_def[]',
      type: undefined
    }, {
      name: 'actions',
      typeName: 'action_def[]',
      type: undefined
    }, {
      name: 'tables',
      typeName: 'table_def[]',
      type: undefined
    }, {
      name: 'ricardian_clauses',
      typeName: 'clause_pair[]',
      type: undefined
    }, {
      name: 'error_messages',
      typeName: 'error_message[]',
      type: undefined
    }, {
      name: 'abi_extensions',
      typeName: 'extensions_entry[]',
      type: undefined
    }, {
      name: 'variants',
      typeName: 'variant_def[]$',
      type: undefined
    }, {
      name: 'action_results',
      typeName: 'action_result[]$',
      type: undefined
    }, {
      name: 'kv_tables',
      typeName: 'kv_table$',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  return initialTypes;
};
var createTransactionExtensionTypes = function createTransactionExtensionTypes() {
  var initialTypes = createInitialTypes();
  initialTypes.set('resource_payer', createType({
    name: 'resource_payer',
    baseName: '',
    fields: [{
      name: 'payer',
      typeName: 'name',
      type: undefined
    }, {
      name: 'max_net_bytes',
      typeName: 'uint64',
      type: undefined
    }, {
      name: 'max_cpu_us',
      typeName: 'uint64',
      type: undefined
    }, {
      name: 'max_memory_bytes',
      typeName: 'uint64',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  return initialTypes;
};
var createTransactionTypes = function createTransactionTypes() {
  var initialTypes = createInitialTypes();
  initialTypes.set('permission_level', createType({
    name: 'permission_level',
    baseName: '',
    fields: [{
      name: 'actor',
      typeName: 'name',
      type: undefined
    }, {
      name: 'permission',
      typeName: 'name',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('action', createType({
    name: 'action',
    baseName: '',
    fields: [{
      name: 'account',
      typeName: 'name',
      type: undefined
    }, {
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'authorization',
      typeName: 'permission_level[]',
      type: undefined
    }, {
      name: 'data',
      typeName: 'bytes',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('extension', createType({
    name: 'extension',
    baseName: '',
    fields: [{
      name: 'type',
      typeName: 'uint16',
      type: undefined
    }, {
      name: 'data',
      typeName: 'bytes',
      type: undefined
    }],
    serialize: serializePair,
    deserialize: deserializePair
  }));
  initialTypes.set('transaction_header', createType({
    name: 'transaction_header',
    baseName: '',
    fields: [{
      name: 'expiration',
      typeName: 'time_point_sec',
      type: undefined
    }, {
      name: 'ref_block_num',
      typeName: 'uint16',
      type: undefined
    }, {
      name: 'ref_block_prefix',
      typeName: 'uint32',
      type: undefined
    }, {
      name: 'max_net_usage_words',
      typeName: 'varuint32',
      type: undefined
    }, {
      name: 'max_cpu_usage_ms',
      typeName: 'uint8',
      type: undefined
    }, {
      name: 'delay_sec',
      typeName: 'varuint32',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('transaction', createType({
    name: 'transaction',
    baseName: 'transaction_header',
    fields: [{
      name: 'context_free_actions',
      typeName: 'action[]',
      type: undefined
    }, {
      name: 'actions',
      typeName: 'action[]',
      type: undefined
    }, {
      name: 'transaction_extensions',
      typeName: 'extension',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  return initialTypes;
};
/** Get type from `types` */

var getType = function getType(types, name) {
  var type = types.get(name);

  if (type && type.aliasOfName) {
    return getType(types, type.aliasOfName);
  }

  if (type) {
    return type;
  }

  if (name.endsWith('[]')) {
    return createType({
      name: name,
      arrayOf: getType(types, name.substr(0, name.length - 2)),
      serialize: serializeArray,
      deserialize: deserializeArray
    });
  }

  if (name.endsWith('?')) {
    return createType({
      name: name,
      optionalOf: getType(types, name.substr(0, name.length - 1)),
      serialize: serializeOptional,
      deserialize: deserializeOptional
    });
  }

  if (name.endsWith('$')) {
    return createType({
      name: name,
      extensionOf: getType(types, name.substr(0, name.length - 1)),
      serialize: serializeExtension,
      deserialize: deserializeExtension
    });
  }

  throw new Error('Unknown type: ' + name);
};
/**
 * Get types from abi
 *
 * @param initialTypes Set of types to build on.
 * In most cases, it's best to fill this from a fresh call to `getTypesFromAbi()`.
 */

var getTypesFromAbi = function getTypesFromAbi(initialTypes, abi) {
  var types = new Map(initialTypes);

  if (abi && abi.types) {
    for (var _iterator5 = _createForOfIteratorHelperLoose(abi.types), _step5; !(_step5 = _iterator5()).done;) {
      var _step5$value = _step5.value,
          new_type_name = _step5$value.new_type_name,
          type = _step5$value.type;
      types.set(new_type_name, createType({
        name: new_type_name,
        aliasOfName: type
      }));
    }
  }

  if (abi && abi.structs) {
    for (var _iterator6 = _createForOfIteratorHelperLoose(abi.structs), _step6; !(_step6 = _iterator6()).done;) {
      var _step6$value = _step6.value,
          name = _step6$value.name,
          base = _step6$value.base,
          fields = _step6$value.fields;
      types.set(name, createType({
        name: name,
        baseName: base,
        fields: fields.map(function (_ref4) {
          var n = _ref4.name,
              type = _ref4.type;
          return {
            name: n,
            typeName: type,
            type: undefined
          };
        }),
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
    }
  }

  if (abi && abi.variants) {
    for (var _iterator7 = _createForOfIteratorHelperLoose(abi.variants), _step7; !(_step7 = _iterator7()).done;) {
      var _step7$value = _step7.value,
          _name = _step7$value.name,
          t = _step7$value.types;
      types.set(_name, createType({
        name: _name,
        fields: t.map(function (s) {
          return {
            name: s,
            typeName: s,
            type: undefined
          };
        }),
        serialize: serializeVariant,
        deserialize: deserializeVariant
      }));
    }
  }

  for (var _iterator8 = _createForOfIteratorHelperLoose(types), _step8; !(_step8 = _iterator8()).done;) {
    var _step8$value = _step8.value,

    _type = _step8$value[1];

    if (_type.baseName) {
      _type.base = getType(types, _type.baseName);
    }

    for (var _iterator9 = _createForOfIteratorHelperLoose(_type.fields), _step9; !(_step9 = _iterator9()).done;) {
      var field = _step9.value;
      field.type = getType(types, field.typeName);
    }
  }

  return types;
}; // getTypesFromAbi

var reverseHex = function reverseHex(h) {
  return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);
};
/** TAPoS: Return transaction fields which reference `refBlock` and expire `expireSeconds` after `timestamp` */


var transactionHeader = function transactionHeader(refBlock, expireSeconds) {
  var timestamp = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;
  var prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);
  return {
    expiration: timePointSecToDate(dateToTimePointSec(timestamp) + expireSeconds),
    ref_block_num: refBlock.block_num & 0xffff,
    ref_block_prefix: prefix
  };
};
/** Convert action data to serialized form (hex) */

var serializeActionData = function serializeActionData(contract, account, name, data) {
  var action = contract.actions.get(name);

  if (!action) {
    throw new Error("Unknown action " + name + " in contract " + account);
  }

  var buffer = new SerialBuffer();
  action.serialize(buffer, data);
  return arrayToHex(buffer.asUint8Array());
};
/** Return action in serialized form */

var serializeAction = function serializeAction(contract, account, name, authorization, data) {
  return {
    account: account,
    name: name,
    authorization: authorization,
    data: serializeActionData(contract, account, name, data)
  };
};
/** Deserialize action data. If `data` is a `string`, then it's assumed to be in hex. */

var deserializeActionData = function deserializeActionData(contract, account, name, data) {
  var action = contract.actions.get(name);

  if (typeof data === 'string') {
    data = hexToUint8Array(data);
  }

  if (!action) {
    throw new Error("Unknown action " + name + " in contract " + account);
  }

  var buffer = new SerialBuffer();
  buffer.pushArray(data);
  return action.deserialize(buffer);
};
/** Deserialize action. If `data` is a `string`, then it's assumed to be in hex. */

var deserializeAction = function deserializeAction(contract, account, name, authorization, data) {
  return {
    account: account,
    name: name,
    authorization: authorization,
    data: deserializeActionData(contract, account, name, data)
  };
};
var serializeAnyvar = function serializeAnyvar(buffer, anyvar) {
  var def;
  var value;

  if (anyvar === null) {
    var _ref5 = [anyvarDefs.null_t, anyvar];
    def = _ref5[0];
    value = _ref5[1];
  } else if (typeof anyvar === 'string') {
    var _ref6 = [anyvarDefs.string, anyvar];
    def = _ref6[0];
    value = _ref6[1];
  } else if (typeof anyvar === 'number') {
    var _ref7 = [anyvarDefs.int32, anyvar];
    def = _ref7[0];
    value = _ref7[1];
  } else if (anyvar instanceof Uint8Array) {
    var _ref8 = [anyvarDefs.bytes, anyvar];
    def = _ref8[0];
    value = _ref8[1];
  } else if (Array.isArray(anyvar)) {
    var _ref9 = [anyvarDefs.any_array, anyvar];
    def = _ref9[0];
    value = _ref9[1];
  } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty('type') && anyvar.hasOwnProperty('value')) {
    var _ref10 = [anyvarDefs[anyvar.type], anyvar.value];
    def = _ref10[0];
    value = _ref10[1];
  } else {
    var _ref11 = [anyvarDefs.any_object, anyvar];
    def = _ref11[0];
    value = _ref11[1];
  }

  buffer.pushVaruint32(def.index);
  def.type.serialize(buffer, value);
};
var deserializeAnyvar = function deserializeAnyvar(buffer, state) {
  var defIndex = buffer.getVaruint32();

  if (defIndex >= anyvarDefsByIndex.length) {
    throw new Error('Tried to deserialize unknown anyvar type');
  }

  var def = anyvarDefsByIndex[defIndex];
  var value = def.type.deserialize(buffer, state);

  if (state && state.options.useShortForm || def.useShortForm) {
    return value;
  } else {
    return {
      type: def.type.name,
      value: value
    };
  }
};
var deserializeAnyvarShort = function deserializeAnyvarShort(buffer) {
  return deserializeAnyvar(buffer, new SerializerState({
    useShortForm: true
  }));
};
var serializeAnyObject = function serializeAnyObject(buffer, obj) {
  var entries = Object.entries(obj);
  buffer.pushVaruint32(entries.length);

  for (var _i2 = 0, _entries2 = entries; _i2 < _entries2.length; _i2++) {
    var _entries2$_i = _entries2[_i2],
        key = _entries2$_i[0],
        value = _entries2$_i[1];
    buffer.pushString(key);
    serializeAnyvar(buffer, value);
  }
};
var deserializeAnyObject = function deserializeAnyObject(buffer, state) {
  var len = buffer.getVaruint32();
  var result = {};

  for (var i = 0; i < len; ++i) {
    var key = buffer.getString();

    if (key in result) {
      var j = 1;

      while (key + '_' + j in result) {
        ++j;
      }

      key = key + '_' + j;
    }

    result[key] = deserializeAnyvar(buffer, state);
  }

  return result;
};
var serializeAnyArray = function serializeAnyArray(buffer, arr) {
  buffer.pushVaruint32(arr.length);

  for (var _iterator10 = _createForOfIteratorHelperLoose(arr), _step10; !(_step10 = _iterator10()).done;) {
    var x = _step10.value;
    serializeAnyvar(buffer, x);
  }
};
var deserializeAnyArray = function deserializeAnyArray(buffer, state) {
  var len = buffer.getVaruint32();
  var result = [];

  for (var i = 0; i < len; ++i) {
    result.push(deserializeAnyvar(buffer, state));
  }

  return result;
};

var addAdditionalTypes = function addAdditionalTypes() {
  var initialTypes = createInitialTypes();
  initialTypes.set('null_t', createType({
    name: 'null_t',
    serialize: function serialize(_, __) {},
    deserialize: function deserialize(_, __) {}
  }));
  initialTypes.set('any_object', createType({
    name: 'any_object',
    serialize: serializeAnyObject,
    deserialize: deserializeAnyObject
  }));
  initialTypes.set('any_array', createType({
    name: 'any_array',
    serialize: serializeAnyArray,
    deserialize: deserializeAnyArray
  }));
  return initialTypes;
};

var additionalTypes = /*#__PURE__*/addAdditionalTypes();
var anyvarDefs = {
  null_t: {
    index: 0,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('null_t')
  },
  int64: {
    index: 1,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('int64')
  },
  uint64: {
    index: 2,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint64')
  },
  int32: {
    index: 3,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('int32')
  },
  uint32: {
    index: 4,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint32')
  },
  int16: {
    index: 5,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('int16')
  },
  uint16: {
    index: 6,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint16')
  },
  int8: {
    index: 7,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('int8')
  },
  uint8: {
    index: 8,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint8')
  },
  time_point: {
    index: 9,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('time_point')
  },
  checksum256: {
    index: 10,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('checksum256')
  },
  float64: {
    index: 11,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('float64')
  },
  string: {
    index: 12,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('string')
  },
  any_object: {
    index: 13,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('any_object')
  },
  any_array: {
    index: 14,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('any_array')
  },
  bytes: {
    index: 15,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('bytes')
  },
  symbol: {
    index: 16,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('symbol')
  },
  symbol_code: {
    index: 17,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('symbol_code')
  },
  asset: {
    index: 18,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('asset')
  }
};
var anyvarDefsByIndex = [anyvarDefs.null_t, anyvarDefs.int64, anyvarDefs.uint64, anyvarDefs.int32, anyvarDefs.uint32, anyvarDefs.int16, anyvarDefs.uint16, anyvarDefs.int8, anyvarDefs.uint8, anyvarDefs.time_point, anyvarDefs.checksum256, anyvarDefs.float64, anyvarDefs.string, anyvarDefs.any_object, anyvarDefs.any_array, anyvarDefs.bytes, anyvarDefs.symbol, anyvarDefs.symbol_code, anyvarDefs.asset];
var serializeQuery = function serializeQuery(buffer, query) {
  var method;
  var arg;
  var filter;

  if (typeof query === 'string') {
    method = query;
  } else if (Array.isArray(query) && query.length === 2) {
    method = query[0];
    filter = query[1];
  } else if (Array.isArray(query) && query.length === 3) {
    method = query[0];
    arg = query[1];
    filter = query[2];
  } else {
    var _ref12 = [query.method, query.arg, query.filter];
    method = _ref12[0];
    arg = _ref12[1];
    filter = _ref12[2];
  }

  buffer.pushString(method); // @ts-ignore

  if (arg === undefined) {
    buffer.push(0);
  } else {
    buffer.push(1);
    serializeAnyvar(buffer, arg);
  } // @ts-ignore


  if (filter === undefined) {
    buffer.push(0);
  } else {
    buffer.pushVaruint32(filter.length);

    for (var _iterator11 = _createForOfIteratorHelperLoose(filter), _step11; !(_step11 = _iterator11()).done;) {
      var q = _step11.value;
      serializeQuery(buffer, q);
    }
  }
};
function b64tob64u(a) {
  a = a.replace(/\=/g, '');
  a = a.replace(/\+/g, '-');
  a = a.replace(/\//g, '_');
  return a;
}
function createBaseResolvedTransaction() {
  return {
    expiration: new Date().toISOString().slice(0, -1),
    ref_block_num: 0,
    ref_block_prefix: 0,
    max_net_usage_words: 0,
    max_cpu_usage_ms: 0,
    delay_sec: 0,
    context_free_actions: [],
    actions: [],
    transaction_extensions: []
  };
}

var Serialize = {
  __proto__: null,
  SerializerState: SerializerState,
  SerialBuffer: SerialBuffer,
  supportedAbiVersion: supportedAbiVersion,
  dateToTimePoint: dateToTimePoint,
  timePointToDate: timePointToDate,
  dateToTimePointSec: dateToTimePointSec,
  timePointSecToDate: timePointSecToDate,
  dateToBlockTimestamp: dateToBlockTimestamp,
  blockTimestampToDate: blockTimestampToDate,
  stringToSymbol: stringToSymbol,
  symbolToString: symbolToString,
  arrayToHex: arrayToHex,
  hexToUint8Array: hexToUint8Array,
  createInitialTypes: createInitialTypes,
  createAbiTypes: createAbiTypes,
  createTransactionExtensionTypes: createTransactionExtensionTypes,
  createTransactionTypes: createTransactionTypes,
  getType: getType,
  getTypesFromAbi: getTypesFromAbi,
  transactionHeader: transactionHeader,
  serializeActionData: serializeActionData,
  serializeAction: serializeAction,
  deserializeActionData: deserializeActionData,
  deserializeAction: deserializeAction,
  serializeAnyvar: serializeAnyvar,
  deserializeAnyvar: deserializeAnyvar,
  deserializeAnyvarShort: deserializeAnyvarShort,
  serializeAnyObject: serializeAnyObject,
  deserializeAnyObject: deserializeAnyObject,
  serializeAnyArray: serializeAnyArray,
  deserializeAnyArray: deserializeAnyArray,
  serializeQuery: serializeQuery,
  b64tob64u: b64tob64u,
  createBaseResolvedTransaction: createBaseResolvedTransaction
};

/** Construct the elliptic curve object based on key type */

var constructElliptic = function constructElliptic(type) {
  if (type === KeyType.k1) {
    return new ec('secp256k1');
  }

  return new ec('p256');
};
var sha256 = function sha256(data) {
  return sha256$1().update(data).digest('hex');
};

/** Represents/stores a public key and provides easy conversion for use with `elliptic` lib */

var PublicKey = /*#__PURE__*/function () {
  function PublicKey(key, ec) {
    this.key = void 0;
    this.ec = void 0;
    this.key = key;
    this.ec = ec;
  }
  /** Instantiate public key from an EOSIO-format public key */


  PublicKey.fromString = function fromString(publicKeyStr, ec) {
    var key = stringToPublicKey(publicKeyStr);

    if (!ec) {
      ec = constructElliptic(key.type);
    }

    return new PublicKey(key, ec);
  }
  /** Instantiate public key from an `elliptic`-format public key */
  ;

  PublicKey.fromElliptic = function fromElliptic(publicKey, keyType, ec) {
    var x = publicKey.getPublic().getX().toArray('be', 32);
    var y = publicKey.getPublic().getY().toArray('be', 32);

    if (!ec) {
      ec = constructElliptic(keyType);
    }

    return new PublicKey({
      type: keyType,
      data: new Uint8Array([y[31] & 1 ? 3 : 2].concat(x))
    }, ec);
  }
  /** Export public key as EOSIO-format public key */
  ;

  var _proto = PublicKey.prototype;

  _proto.toString = function toString() {
    return publicKeyToString(this.key);
  }
  /** Export public key as Legacy EOSIO-format public key */
  ;

  _proto.toLegacyString = function toLegacyString(prefix) {
    return publicKeyToLegacyString(this.key, prefix);
  }
  /** Export public key as `elliptic`-format public key */
  ;

  _proto.toElliptic = function toElliptic() {
    return this.ec.keyPair({
      pub: Buffer.from(this.key.data)
    });
  }
  /** Get key type from key */
  ;

  _proto.getType = function getType() {
    return this.key.type;
  }
  /** Validate a public key */
  ;

  _proto.isValid = function isValid() {
    try {
      var ellipticPublicKey = this.toElliptic();
      var validationObj = ellipticPublicKey.validate();
      return validationObj.result;
    } catch (_unused) {
      return false;
    }
  };

  return PublicKey;
}();

var BN = /*#__PURE__*/require('bn.js');
/** Represents/stores a Signature and provides easy conversion for use with `elliptic` lib */

var Signature = /*#__PURE__*/function () {
  function Signature(signature, ec) {
    this.signature = void 0;
    this.ec = void 0;
    this.signature = signature;
    this.ec = ec;
  }
  /** Instantiate Signature from an EOSIO-format Signature */


  Signature.fromString = function fromString(sig, ec) {
    var signature = stringToSignature(sig);

    if (!ec) {
      ec = constructElliptic(signature.type);
    }

    return new Signature(signature, ec);
  }
  /** Instantiate Signature from an `elliptic`-format Signature */
  ;

  Signature.fromElliptic = function fromElliptic(ellipticSig, keyType, ec) {
    if (!ellipticSig.recoveryParam) {
      ellipticSig.recoveryParam = 0;
    }

    var r = ellipticSig.r.toArray('be', 32);
    var s = ellipticSig.s.toArray('be', 32);
    var eosioRecoveryParam;

    if (keyType === KeyType.k1 || keyType === KeyType.r1) {
      eosioRecoveryParam = ellipticSig.recoveryParam + 27;

      if (ellipticSig.recoveryParam <= 3) {
        eosioRecoveryParam += 4;
      }
    } else if (keyType === KeyType.wa) {
      eosioRecoveryParam = ellipticSig.recoveryParam;
    }

    var sigData = new Uint8Array([eosioRecoveryParam].concat(r, s));

    if (!ec) {
      ec = constructElliptic(keyType);
    }

    return new Signature({
      type: keyType,
      data: sigData
    }, ec);
  }
  /** Export Signature as `elliptic`-format Signature
   * NOTE: This isn't an actual elliptic-format Signature, as ec.Signature is not exported by the library.
   * That's also why the return type is `any`.  We're *actually* returning an object with the 3 params
   * not an ec.Signature.
   * Further NOTE: @types/elliptic shows ec.Signature as exported; it is *not*.  Hence the `any`.
   */
  ;

  var _proto = Signature.prototype;

  _proto.toElliptic = function toElliptic() {
    var lengthOfR = 32;
    var lengthOfS = 32;
    var r = new BN(this.signature.data.slice(1, lengthOfR + 1));
    var s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));
    var ellipticRecoveryBitField;

    if (this.signature.type === KeyType.k1 || this.signature.type === KeyType.r1) {
      ellipticRecoveryBitField = this.signature.data[0] - 27;

      if (ellipticRecoveryBitField > 3) {
        ellipticRecoveryBitField -= 4;
      }
    } else if (this.signature.type === KeyType.wa) {
      ellipticRecoveryBitField = this.signature.data[0];
    } else {
      ellipticRecoveryBitField = 0;
    }

    var recoveryParam = ellipticRecoveryBitField & 3;
    return {
      r: r,
      s: s,
      recoveryParam: recoveryParam
    };
  }
  /** Export Signature as EOSIO-format Signature */
  ;

  _proto.toString = function toString() {
    return signatureToString(this.signature);
  }
  /** Export Signature in binary format */
  ;

  _proto.toBinary = function toBinary() {
    return this.signature.data;
  }
  /** Get key type from signature */
  ;

  _proto.getType = function getType() {
    return this.signature.type;
  }
  /** Verify a signature with a message or hashed message digest and public key */
  ;

  _proto.verify = function verify(data, publicKey, shouldHash, encoding) {
    if (shouldHash === void 0) {
      shouldHash = true;
    }

    if (encoding === void 0) {
      encoding = 'utf8';
    }

    if (shouldHash) {
      if (typeof data === 'string') {
        data = Buffer.from(data, encoding);
      }

      data = this.ec.hash().update(data).digest();
    }

    var ellipticSignature = this.toElliptic();
    var ellipticPublicKey = publicKey.toElliptic();
    return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);
  }
  /** Recover a public key from a message or hashed message digest and signature */
  ;

  _proto.recover = function recover(data, shouldHash, encoding) {
    if (shouldHash === void 0) {
      shouldHash = true;
    }

    if (encoding === void 0) {
      encoding = 'utf8';
    }

    if (shouldHash) {
      if (typeof data === 'string') {
        data = Buffer.from(data, encoding);
      }

      data = this.ec.hash().update(data).digest();
    }

    var ellipticSignature = this.toElliptic();
    var recoveredPublicKey = this.ec.recoverPubKey(data, ellipticSignature, ellipticSignature.recoveryParam, encoding);
    var ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);
    return PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);
  };

  return Signature;
}();

/** Represents/stores a private key and provides easy conversion for use with `elliptic` lib */

var PrivateKey = /*#__PURE__*/function () {
  function PrivateKey(key, ec) {
    this.key = void 0;
    this.ec = void 0;
    this.key = key;
    this.ec = ec;
  }
  /** Instantiate private key from an `elliptic`-format private key */


  PrivateKey.fromElliptic = function fromElliptic(privKey, keyType, ec) {
    if (!ec) {
      ec = constructElliptic(keyType);
    }

    return new PrivateKey({
      type: keyType,
      data: privKey.getPrivate().toArrayLike(Buffer, 'be', 32)
    }, ec);
  }
  /** Instantiate private key from an EOSIO-format private key */
  ;

  PrivateKey.fromString = function fromString(keyString, ec) {
    var privateKey = stringToPrivateKey(keyString);

    if (!ec) {
      ec = constructElliptic(privateKey.type);
    }

    return new PrivateKey(privateKey, ec);
  }
  /** Export private key as `elliptic`-format private key */
  ;

  var _proto = PrivateKey.prototype;

  _proto.toElliptic = function toElliptic() {
    return this.ec.keyFromPrivate(this.key.data);
  };

  _proto.toLegacyString = function toLegacyString() {
    return privateKeyToLegacyString(this.key);
  }
  /** Export private key as EOSIO-format private key */
  ;

  _proto.toString = function toString() {
    return privateKeyToString(this.key);
  }
  /** Get key type from key */
  ;

  _proto.getType = function getType() {
    return this.key.type;
  }
  /** Retrieve the public key from a private key */
  ;

  _proto.getPublicKey = function getPublicKey() {
    var ellipticPrivateKey = this.toElliptic();
    return PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);
  }
  /** Sign a message or hashed message digest with private key */
  ;

  _proto.sign = function sign(data, shouldHash, encoding) {
    var _this = this;

    if (shouldHash === void 0) {
      shouldHash = true;
    }

    if (encoding === void 0) {
      encoding = 'utf8';
    }

    if (shouldHash) {
      if (typeof data === 'string') {
        data = Buffer.from(data, encoding);
      }

      data = this.ec.hash().update(data).digest();
    }

    var tries = 0;
    var signature;

    var isCanonical = function isCanonical(sigData) {
      return !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80)) && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));
    };

    var constructSignature = function constructSignature(options) {
      var ellipticPrivateKey = _this.toElliptic();

      var ellipticSignature = ellipticPrivateKey.sign(data, options);
      return Signature.fromElliptic(ellipticSignature, _this.getType(), _this.ec);
    };

    if (this.key.type === KeyType.k1) {
      do {
        signature = constructSignature({
          canonical: true,
          pers: [++tries]
        });
      } while (!isCanonical(signature.toBinary()));
    } else {
      signature = constructSignature({
        canonical: true
      });
    }

    return signature;
  }
  /** Validate a private key */
  ;

  _proto.isValid = function isValid() {
    try {
      var ellipticPrivateKey = this.toElliptic();
      var validationObj = ellipticPrivateKey.validate();
      return validationObj.result;
    } catch (_unused) {
      return false;
    }
  };

  return PrivateKey;
}();

var generateKeyPair = function generateKeyPair(type, options) {
  if (options === void 0) {
    options = {};
  }

  if (!options.secureEnv) {
    throw new Error('Key generation is completely INSECURE in production environments in the browser. ' + 'If you are absolutely certain this does NOT describe your environment, set `secureEnv` in your ' + 'options to `true`.  If this does describe your environment and you set `secureEnv` to `true`, ' + 'YOU DO SO AT YOUR OWN RISK AND THE RISK OF YOUR USERS.');
  }

  var ec$1;

  if (type === KeyType.k1) {
    ec$1 = new ec('secp256k1');
  } else {
    ec$1 = new ec('p256');
  }

  var ellipticKeyPair = ec$1.genKeyPair(options.ecOptions);
  var publicKey = PublicKey.fromElliptic(ellipticKeyPair, type, ec$1);
  var privateKey = PrivateKey.fromElliptic(ellipticKeyPair, type, ec$1);
  return {
    publicKey: publicKey,
    privateKey: privateKey
  };
};

var Key = {
  __proto__: null,
  generateKeyPair: generateKeyPair,
  PrivateKey: PrivateKey,
  PublicKey: PublicKey,
  Signature: Signature,
  constructElliptic: constructElliptic
};

/** expensive to construct; so we do it once and reuse it */

var defaultEc = /*#__PURE__*/new ec('secp256k1');
/** Construct the digest from transaction details */

var digestFromSerializedData = function digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData, e) {
  if (e === void 0) {
    e = defaultEc;
  }

  var signBuf = Buffer.concat([Buffer.from(chainId, 'hex'), Buffer.from(serializedTransaction), Buffer.from(serializedContextFreeData ? new Uint8Array(e.hash().update(serializedContextFreeData).digest()) : new Uint8Array(32))]);
  return e.hash().update(signBuf).digest();
};
/** Signs transactions using in-process private keys */


var JsSignatureProvider = /*#__PURE__*/function () {
  /** map public to private keys */

  /** public keys */

  /** @param privateKeys private keys to sign with */
  function JsSignatureProvider(privateKeys) {
    this.keys = new Map();
    this.availableKeys = [];

    for (var _iterator = _createForOfIteratorHelperLoose(privateKeys), _step; !(_step = _iterator()).done;) {
      var k = _step.value;
      var priv = PrivateKey.fromString(k);
      var privElliptic = priv.toElliptic();
      var pubStr = priv.getPublicKey().toString();
      this.keys.set(pubStr, privElliptic);
      this.availableKeys.push(pubStr);
    }
  }
  /** Public keys associated with the private keys that the `SignatureProvider` holds */


  var _proto = JsSignatureProvider.prototype;

  _proto.getAvailableKeys =
  /*#__PURE__*/
  function () {
    var _getAvailableKeys = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.availableKeys);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getAvailableKeys() {
      return _getAvailableKeys.apply(this, arguments);
    }

    return getAvailableKeys;
  }()
  /** Sign a transaction */
  ;

  _proto.sign =
  /*#__PURE__*/
  function () {
    var _sign = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref) {
      var chainId, requiredKeys, serializedTransaction, serializedContextFreeData, digest, signatures, _iterator2, _step2, key, publicKey, ellipticPrivateKey, privateKey, signature;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              chainId = _ref.chainId, requiredKeys = _ref.requiredKeys, serializedTransaction = _ref.serializedTransaction, serializedContextFreeData = _ref.serializedContextFreeData;
              digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData, defaultEc);
              signatures = [];

              for (_iterator2 = _createForOfIteratorHelperLoose(requiredKeys); !(_step2 = _iterator2()).done;) {
                key = _step2.value;
                publicKey = PublicKey.fromString(key);
                ellipticPrivateKey = this.keys.get(convertLegacyPublicKey(key));

                if (ellipticPrivateKey) {
                  privateKey = PrivateKey.fromElliptic(ellipticPrivateKey, publicKey.getType());
                  signature = privateKey.sign(digest, false);
                  signatures.push(signature.toString());
                }
              }

              return _context2.abrupt("return", {
                signatures: signatures,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData
              });

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function sign(_x) {
      return _sign.apply(this, arguments);
    }

    return sign;
  }();

  return JsSignatureProvider;
}();

var Api = /*#__PURE__*/function () {
  /** Issues RPC calls */

  /** Get subset of `availableKeys` needed to meet authorities in a `transaction` */

  /** Supplies ABIs in raw form (binary) */

  /** Signs transactions */

  /** Converts abi files between binary and structured form (`abi.abi.json`) */

  /** Converts transactions between binary and structured form (`transaction.abi.json`) */

  /** Holds information needed to serialize contract actions */

  /** Fetched abis */

  /** Crypto */

  /**
   * @param args
   *    * `rpc`: Issues RPC calls
   *    * `authorityProvider`: Get public keys needed to meet authorities in a transaction
   *    * `abiProvider`: Supplies ABIs in raw form (binary)
   *    * `signatureProvider`: Signs transactions
   */
  function Api(args) {
    this.rpc = void 0;
    this.authorityProvider = void 0;
    this.abiProvider = void 0;
    this.signatureProvider = void 0;
    this.abiTypes = void 0;
    this.transactionTypes = void 0;
    this.contracts = new Map();
    this.cachedAbis = new Map();
    this.crypto = void 0;
    this.recoverPersonalSignature = void 0;
    this.transactionExtensions = [{
      id: 1,
      type: 'resource_payer',
      keys: ['payer', 'max_net_bytes', 'max_cpu_us', 'max_memory_bytes']
    }];
    this.rpc = args.rpc;
    this.authorityProvider = args.authorityProvider || args.rpc;
    this.abiProvider = args.abiProvider || args.rpc;

    if (args.signatureProvider) {
      this.signatureProvider = args.signatureProvider;
    }

    this.abiTypes = getTypesFromAbi(createAbiTypes());
    this.transactionTypes = getTypesFromAbi(createTransactionTypes());
    this.crypto = args.crypto || typeof window !== "undefined" && window && window.crypto || global && global.crypto;
    this.recoverPersonalSignature = args.recoverPersonalSignature;
  }

  var _proto = Api.prototype;

  _proto.getCrypto = function getCrypto() {
    if (!this.crypto) {
      throw new Error("No 'crypto' module found. On nodejs, do const { Crypto } = require('@peculiar/webcrypto'); const crypto = new Crypto; new Api({ rpc, crypto });");
    }

    return this.crypto;
  };

  _proto.getRecoverPersonalSignature = function getRecoverPersonalSignature() {
    if (!this.recoverPersonalSignature) {
      throw new Error("No 'recoverPersonalSignature' function found. Do const { recoverPersonalSignature } = require('eth-sig-util'); new Api({ rpc, recoverPersonalSignature });");
    }

    return this.recoverPersonalSignature;
  }
  /** Decodes an abi as Uint8Array into json. */
  ;

  _proto.rawAbiToJson = function rawAbiToJson(rawAbi) {
    var buffer = new SerialBuffer({
      array: rawAbi
    });

    if (!supportedAbiVersion(buffer.getString())) {
      throw new Error('Unsupported abi version');
    }

    buffer.restartRead();
    return this.abiTypes.get('abi_def').deserialize(buffer);
  }
  /** Encodes a json abi as Uint8Array. */
  ;

  _proto.jsonToRawAbi = function jsonToRawAbi(jsonAbi) {
    var buffer = new SerialBuffer();
    this.abiTypes.get('abi_def').serialize(buffer, jsonAbi);

    if (!supportedAbiVersion(buffer.getString())) {
      throw new Error('Unsupported abi version');
    }

    return buffer.asUint8Array();
  }
  /** Get abi in both binary and structured forms. Fetch when needed. */
  ;

  _proto.getCachedAbi =
  /*#__PURE__*/
  function () {
    var _getCachedAbi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(accountName, reload) {
      var cachedAbi, rawAbi, abi;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              if (!(!reload && this.cachedAbis.get(accountName))) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return", this.cachedAbis.get(accountName));

            case 3:
              _context.prev = 3;
              _context.next = 6;
              return this.abiProvider.getRawAbi(accountName);

            case 6:
              rawAbi = _context.sent.abi;
              abi = this.rawAbiToJson(rawAbi);
              cachedAbi = {
                rawAbi: rawAbi,
                abi: abi
              };
              _context.next = 15;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](3);
              _context.t0.message = "fetching abi for " + accountName + ": " + _context.t0.message;
              throw _context.t0;

            case 15:
              if (cachedAbi) {
                _context.next = 17;
                break;
              }

              throw new Error("Missing abi for " + accountName);

            case 17:
              this.cachedAbis.set(accountName, cachedAbi);
              return _context.abrupt("return", cachedAbi);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[3, 11]]);
    }));

    function getCachedAbi(_x, _x2) {
      return _getCachedAbi.apply(this, arguments);
    }

    return getCachedAbi;
  }()
  /** Get abi in structured form. Fetch when needed. */
  ;

  _proto.getAbi =
  /*#__PURE__*/
  function () {
    var _getAbi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(accountName, reload) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              _context2.next = 3;
              return this.getCachedAbi(accountName, reload);

            case 3:
              return _context2.abrupt("return", _context2.sent.abi);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getAbi(_x3, _x4) {
      return _getAbi.apply(this, arguments);
    }

    return getAbi;
  }()
  /** Get abis needed by a transaction */
  ;

  _proto.getTransactionAbis =
  /*#__PURE__*/
  function () {
    var _getTransactionAbis = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(transaction, reload) {
      var _this = this;

      var actions, accounts, uniqueAccounts, actionPromises;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              actions = (transaction.context_free_actions || []).concat(transaction.actions);
              accounts = actions.map(function (action) {
                return action.account;
              });
              uniqueAccounts = new Set(accounts);
              actionPromises = Array.from(uniqueAccounts).map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(account) {
                  var _yield$_this$getCache, rawAbi;

                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this.getCachedAbi(account, reload);

                        case 2:
                          _yield$_this$getCache = _context3.sent;
                          rawAbi = _yield$_this$getCache.rawAbi;
                          return _context3.abrupt("return", {
                            accountName: account,
                            abi: rawAbi
                          });

                        case 5:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                return function (_x7) {
                  return _ref.apply(this, arguments);
                };
              }());
              return _context4.abrupt("return", Promise.all(actionPromises));

            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function getTransactionAbis(_x5, _x6) {
      return _getTransactionAbis.apply(this, arguments);
    }

    return getTransactionAbis;
  }()
  /** Get data needed to serialize actions in a contract */
  ;

  _proto.getContract =
  /*#__PURE__*/
  function () {
    var _getContract = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(accountName, reload) {
      var abi, types, actions, _iterator, _step, _step$value, name, type, result;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              if (!(!reload && this.contracts.get(accountName))) {
                _context5.next = 3;
                break;
              }

              return _context5.abrupt("return", this.contracts.get(accountName));

            case 3:
              _context5.next = 5;
              return this.getAbi(accountName, reload);

            case 5:
              abi = _context5.sent;
              types = getTypesFromAbi(createInitialTypes(), abi);
              actions = new Map();

              for (_iterator = _createForOfIteratorHelperLoose(abi.actions); !(_step = _iterator()).done;) {
                _step$value = _step.value, name = _step$value.name, type = _step$value.type;
                actions.set(name, getType(types, type));
              }

              result = {
                types: types,
                actions: actions
              };
              this.contracts.set(accountName, result);
              return _context5.abrupt("return", result);

            case 12:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getContract(_x8, _x9) {
      return _getContract.apply(this, arguments);
    }

    return getContract;
  }()
  /** Convert `value` to binary form. `type` must be a built-in abi type or in `transaction.abi.json`. */
  ;

  _proto.serialize = function serialize(buffer, type, value) {
    this.transactionTypes.get(type).serialize(buffer, value);
  }
  /** Convert data in `buffer` to structured form. `type` must be a built-in abi type or in `transaction.abi.json`. */
  ;

  _proto.deserialize = function deserialize(buffer, type) {
    return this.transactionTypes.get(type).deserialize(buffer);
  }
  /** Convert a transaction to binary */
  ;

  _proto.serializeTransaction = function serializeTransaction(transaction) {
    var buffer = new SerialBuffer();
    this.serialize(buffer, 'transaction', Object.assign({
      max_net_usage_words: 0,
      max_cpu_usage_ms: 0,
      delay_sec: 0,
      context_free_actions: [],
      transaction_extensions: []
    }, transaction));
    return buffer.asUint8Array();
  }
  /** Serialize context-free data */
  ;

  _proto.serializeContextFreeData = function serializeContextFreeData(contextFreeData) {
    if (!contextFreeData || !contextFreeData.length) {
      return undefined;
    }

    var buffer = new SerialBuffer();
    buffer.pushVaruint32(contextFreeData.length);

    for (var _iterator2 = _createForOfIteratorHelperLoose(contextFreeData), _step2; !(_step2 = _iterator2()).done;) {
      var data = _step2.value;
      buffer.pushBytes(data);
    }

    return buffer.asUint8Array();
  }
  /** Convert a transaction from binary. Leaves actions in hex. */
  ;

  _proto.deserializeTransaction = function deserializeTransaction(transaction) {
    var buffer = new SerialBuffer();
    buffer.pushArray(transaction);
    return this.deserialize(buffer, 'transaction');
  };

  // Order of adding to transaction_extension is transaction_extension id ascending
  _proto.serializeTransactionExtensions = function serializeTransactionExtensions(transaction) {
    var transaction_extensions = [];

    if (transaction.resource_payer) {
      var extensionBuffer = new SerialBuffer();
      var types = getTypesFromAbi(createTransactionExtensionTypes());
      types.get('resource_payer').serialize(extensionBuffer, transaction.resource_payer);
      transaction_extensions = [].concat(transaction_extensions, [[1, arrayToHex(extensionBuffer.asUint8Array())]]);
    }

    return transaction_extensions;
  };

  // Usage: transaction = {...transaction, ...this.deserializeTransactionExtensions(transaction.transaction_extensions)}
  _proto.deserializeTransactionExtensions = function deserializeTransactionExtensions(data) {
    var _this2 = this;

    var transaction = {};
    data.forEach(function (extensionData) {
      var transactionExtension = _this2.transactionExtensions.find(function (extension) {
        return extension.id === extensionData[0];
      });

      if (transactionExtension === undefined) {
        throw new Error("Transaction Extension could not be determined: " + extensionData);
      }

      var types = getTypesFromAbi(createTransactionExtensionTypes());
      var extensionBuffer = new SerialBuffer();
      extensionBuffer.pushArray(hexToUint8Array(extensionData[1]));
      var deserializedObj = types.get(transactionExtension.type).deserialize(extensionBuffer);

      if (extensionData[0] === 1) {
        deserializedObj.max_net_bytes = Number(deserializedObj.max_net_bytes);
        deserializedObj.max_cpu_us = Number(deserializedObj.max_cpu_us);
        deserializedObj.max_memory_bytes = Number(deserializedObj.max_memory_bytes);
        transaction.resource_payer = deserializedObj;
      }
    });
    return transaction;
  };

  // Transaction extensions are serialized and moved to `transaction_extensions`, deserialized objects are not needed on the transaction
  _proto.deleteTransactionExtensionObjects = function deleteTransactionExtensionObjects(transaction) {
    delete transaction.resource_payer;
    return transaction;
  }
  /** Convert actions to hex */
  ;

  _proto.serializeActions =
  /*#__PURE__*/
  function () {
    var _serializeActions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(actions) {
      var _this3 = this;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return Promise.all(actions.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(action) {
                  var account, name, authorization, data, contract;
                  return runtime_1.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          account = action.account, name = action.name, authorization = action.authorization, data = action.data;
                          _context6.next = 3;
                          return _this3.getContract(account);

                        case 3:
                          contract = _context6.sent;

                          if (!(typeof data !== 'object')) {
                            _context6.next = 6;
                            break;
                          }

                          return _context6.abrupt("return", action);

                        case 6:
                          return _context6.abrupt("return", serializeAction(contract, account, name, authorization, data));

                        case 7:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                }));

                return function (_x11) {
                  return _ref2.apply(this, arguments);
                };
              }()));

            case 2:
              return _context7.abrupt("return", _context7.sent);

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function serializeActions(_x10) {
      return _serializeActions.apply(this, arguments);
    }

    return serializeActions;
  }()
  /** Convert actions from hex */
  ;

  _proto.deserializeActions =
  /*#__PURE__*/
  function () {
    var _deserializeActions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(actions) {
      var _this4 = this;

      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return Promise.all(actions.map( /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(_ref3) {
                  var account, name, authorization, data, contract;
                  return runtime_1.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          account = _ref3.account, name = _ref3.name, authorization = _ref3.authorization, data = _ref3.data;
                          _context8.next = 3;
                          return _this4.getContract(account);

                        case 3:
                          contract = _context8.sent;
                          return _context8.abrupt("return", deserializeAction(contract, account, name, authorization, data));

                        case 5:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8);
                }));

                return function (_x13) {
                  return _ref4.apply(this, arguments);
                };
              }()));

            case 2:
              return _context9.abrupt("return", _context9.sent);

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    function deserializeActions(_x12) {
      return _deserializeActions.apply(this, arguments);
    }

    return deserializeActions;
  }();

  _proto.deserializeActionsSync = /*#__PURE__*/function () {
    var _deserializeActionsSync = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(actions) {
      var deserializedActions, _iterator3, _step3, _step3$value, account, name, authorization, data, contract;

      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (actions === void 0) {
                actions = [];
              }

              deserializedActions = [];
              _iterator3 = _createForOfIteratorHelperLoose(actions);

            case 3:
              if ((_step3 = _iterator3()).done) {
                _context10.next = 11;
                break;
              }

              _step3$value = _step3.value, account = _step3$value.account, name = _step3$value.name, authorization = _step3$value.authorization, data = _step3$value.data;
              _context10.next = 7;
              return this.getContract(account);

            case 7:
              contract = _context10.sent;
              deserializedActions.push(deserializeAction(contract, account, name, authorization, data));

            case 9:
              _context10.next = 3;
              break;

            case 11:
              return _context10.abrupt("return", deserializedActions);

            case 12:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function deserializeActionsSync(_x14) {
      return _deserializeActionsSync.apply(this, arguments);
    }

    return deserializeActionsSync;
  }()
  /** Convert a transaction from binary. Also deserializes actions. */
  ;

  _proto.deserializeTransactionWithActions =
  /*#__PURE__*/
  function () {
    var _deserializeTransactionWithActions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(transaction) {
      var deserializedTransaction, deserializedCFActions, deserializedActions;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (typeof transaction === 'string') {
                transaction = hexToUint8Array(transaction);
              }

              deserializedTransaction = this.deserializeTransaction(transaction);
              _context11.next = 4;
              return this.deserializeActionsSync(deserializedTransaction.context_free_actions);

            case 4:
              deserializedCFActions = _context11.sent;
              _context11.next = 7;
              return this.deserializeActionsSync(deserializedTransaction.actions);

            case 7:
              deserializedActions = _context11.sent;
              return _context11.abrupt("return", Object.assign({}, deserializedTransaction, {
                context_free_actions: deserializedCFActions,
                actions: deserializedActions
              }));

            case 9:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function deserializeTransactionWithActions(_x15) {
      return _deserializeTransactionWithActions.apply(this, arguments);
    }

    return deserializeTransactionWithActions;
  }()
  /** Deflate a serialized object */
  ;

  _proto.deflateSerializedArray = function deflateSerializedArray(serializedArray) {
    return deflate(serializedArray, {
      level: 9
    });
  }
  /** Inflate a compressed serialized object */
  ;

  _proto.inflateSerializedArray = function inflateSerializedArray(compressedSerializedArray) {
    return inflate(compressedSerializedArray);
  }
  /**
   * Create and optionally broadcast a transaction.
   *
   * Named Parameters:
   * `broadcast`: broadcast this transaction?
   * `sign`: sign this transaction?
   * `compression`: compress this transaction?
   * `readOnlyTrx`: read only transaction?
   * `returnFailureTraces`: return failure traces? (only available for read only transactions currently)
   *
   * If both `blocksBehind` and `expireSeconds` are present,
   * then fetch the block which is `blocksBehind` behind head block,
   * use it as a reference for TAPoS, and expire the transaction `expireSeconds` after that block's time.
   *
   * If both `useLastIrreversible` and `expireSeconds` are present,
   * then fetch the last irreversible block, use it as a reference for TAPoS,
   * and expire the transaction `expireSeconds` after that block's time.
   *
   * @returns node response if `broadcast`, `{signatures, serializedTransaction}` if `!broadcast`
   */
  ;

  _proto.transact =
  /*#__PURE__*/
  function () {
    var _transact = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(transaction, _temp) {
      var _ref5, _ref5$broadcast, broadcast, _ref5$sign, sign, readOnlyTrx, returnFailureTraces, requiredKeys, compression, blocksBehind, useLastIrreversible, expireSeconds, transactionHeader, info, abis, serializedTransaction, serializedContextFreeData, pushTransactionArgs, availableKeys;

      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _ref5 = _temp === void 0 ? {} : _temp, _ref5$broadcast = _ref5.broadcast, broadcast = _ref5$broadcast === void 0 ? true : _ref5$broadcast, _ref5$sign = _ref5.sign, sign = _ref5$sign === void 0 ? true : _ref5$sign, readOnlyTrx = _ref5.readOnlyTrx, returnFailureTraces = _ref5.returnFailureTraces, requiredKeys = _ref5.requiredKeys, compression = _ref5.compression, blocksBehind = _ref5.blocksBehind, useLastIrreversible = _ref5.useLastIrreversible, expireSeconds = _ref5.expireSeconds, transactionHeader = _ref5.transactionHeader;
              _context12.next = 3;
              return this.rpc.get_info();

            case 3:
              info = _context12.sent;

              if (transactionHeader) {
                _context12.next = 24;
                break;
              }

              if (!(typeof blocksBehind === 'number' && useLastIrreversible)) {
                _context12.next = 10;
                break;
              }

              throw new Error('Use either blocksBehind or useLastIrreversible');

            case 10:
              if (!(typeof blocksBehind !== 'number' && !useLastIrreversible)) {
                _context12.next = 14;
                break;
              }

              throw new Error('Must provide one blocksBehind or useLastIrreversible');

            case 14:
              if (expireSeconds) {
                _context12.next = 18;
                break;
              }

              throw new Error('Must provide expireSeconds');

            case 18:
              _context12.next = 20;
              return this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds);

            case 20:
              transactionHeader = _context12.sent;

            case 22:
              if (this.hasRequiredTaposFields(transactionHeader)) {
                _context12.next = 24;
                break;
              }

              throw new Error('Required configuration or TAPOS fields are not present');

            case 24:
              _context12.next = 26;
              return this.getTransactionAbis(transaction);

            case 26:
              abis = _context12.sent;
              _context12.t0 = Object;
              _context12.t1 = {};
              _context12.t2 = transactionHeader;
              _context12.next = 32;
              return this.serializeTransactionExtensions(transaction);

            case 32:
              _context12.t3 = _context12.sent;
              _context12.next = 35;
              return this.serializeActions(transaction.context_free_actions || []);

            case 35:
              _context12.t4 = _context12.sent;
              _context12.next = 38;
              return this.serializeActions(transaction.actions);

            case 38:
              _context12.t5 = _context12.sent;
              _context12.t6 = {
                transaction_extensions: _context12.t3,
                context_free_actions: _context12.t4,
                actions: _context12.t5
              };
              transaction = _context12.t0.assign.call(_context12.t0, _context12.t1, _context12.t2, _context12.t6);
              transaction = this.deleteTransactionExtensionObjects(transaction);
              serializedTransaction = this.serializeTransaction(transaction);
              serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
              pushTransactionArgs = {
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData,
                signatures: []
              };

              if (!sign) {
                _context12.next = 58;
                break;
              }

              if (this.signatureProvider) {
                _context12.next = 48;
                break;
              }

              throw new Error('No signature provider available');

            case 48:
              if (requiredKeys) {
                _context12.next = 55;
                break;
              }

              _context12.next = 51;
              return this.signatureProvider.getAvailableKeys();

            case 51:
              availableKeys = _context12.sent;
              _context12.next = 54;
              return this.authorityProvider.getRequiredKeys({
                transaction: transaction,
                availableKeys: availableKeys
              });

            case 54:
              requiredKeys = _context12.sent;

            case 55:
              _context12.next = 57;
              return this.signatureProvider.sign({
                chainId: info.chain_id,
                requiredKeys: requiredKeys,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData,
                abis: abis
              });

            case 57:
              pushTransactionArgs = _context12.sent;

            case 58:
              if (!broadcast) {
                _context12.next = 62;
                break;
              }

              if (!compression) {
                _context12.next = 61;
                break;
              }

              return _context12.abrupt("return", this.pushCompressedSignedTransaction(pushTransactionArgs, readOnlyTrx, returnFailureTraces));

            case 61:
              return _context12.abrupt("return", this.pushSignedTransaction(pushTransactionArgs, readOnlyTrx, returnFailureTraces));

            case 62:
              return _context12.abrupt("return", Object.assign({}, pushTransactionArgs, {
                transactionHeader: transactionHeader //

              }));

            case 63:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function transact(_x16, _x17) {
      return _transact.apply(this, arguments);
    }

    return transact;
  }();

  _proto.transactWithDelay = /*#__PURE__*/function () {
    var _transactWithDelay = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(transaction, params, delay) {
      var wait, _wait, success;

      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _wait = function _wait3() {
                _wait = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(ms) {
                  return runtime_1.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          return _context13.abrupt("return", new Promise(function (resolve) {
                            setTimeout(resolve, ms);
                          }));

                        case 1:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }));
                return _wait.apply(this, arguments);
              };

              wait = function _wait2(_x21) {
                return _wait.apply(this, arguments);
              };

              if (params === void 0) {
                params = {};
              }

              _context14.next = 5;
              return this.transact(transaction, params);

            case 5:
              success = _context14.sent;
              _context14.next = 8;
              return wait(delay);

            case 8:
              return _context14.abrupt("return", success);

            case 9:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function transactWithDelay(_x18, _x19, _x20) {
      return _transactWithDelay.apply(this, arguments);
    }

    return transactWithDelay;
  }();

  _proto.query = /*#__PURE__*/function () {
    var _query2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(account, _short, _query, _ref6) {
      var sign, requiredKeys, _ref6$authorization, authorization, info, refBlock, queryBuffer, transaction, serializedTransaction, signatures, abis, availableKeys, signResponse, response, returnBuffer;

      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              sign = _ref6.sign, requiredKeys = _ref6.requiredKeys, _ref6$authorization = _ref6.authorization, authorization = _ref6$authorization === void 0 ? [] : _ref6$authorization;
              _context15.next = 3;
              return this.rpc.get_info();

            case 3:
              info = _context15.sent;
              _context15.next = 6;
              return this.tryRefBlockFromGetInfo(info);

            case 6:
              refBlock = _context15.sent;
              queryBuffer = new SerialBuffer();
              serializeQuery(queryBuffer, _query);
              transaction = Object.assign({}, transactionHeader(refBlock, 60 * 30), {
                context_free_actions: [],
                actions: [{
                  account: account,
                  name: 'queryit',
                  authorization: authorization,
                  data: arrayToHex(queryBuffer.asUint8Array())
                }]
              });
              serializedTransaction = this.serializeTransaction(transaction);
              signatures = [];

              if (!sign) {
                _context15.next = 29;
                break;
              }

              if (this.signatureProvider) {
                _context15.next = 15;
                break;
              }

              throw new Error('No signature provider available');

            case 15:
              _context15.next = 17;
              return this.getTransactionAbis(transaction);

            case 17:
              abis = _context15.sent;

              if (requiredKeys) {
                _context15.next = 25;
                break;
              }

              _context15.next = 21;
              return this.signatureProvider.getAvailableKeys();

            case 21:
              availableKeys = _context15.sent;
              _context15.next = 24;
              return this.authorityProvider.getRequiredKeys({
                transaction: transaction,
                availableKeys: availableKeys
              });

            case 24:
              requiredKeys = _context15.sent;

            case 25:
              _context15.next = 27;
              return this.signatureProvider.sign({
                chainId: info.chain_id,
                requiredKeys: requiredKeys,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: undefined,
                abis: abis
              });

            case 27:
              signResponse = _context15.sent;
              signatures = signResponse.signatures;

            case 29:
              _context15.next = 31;
              return this.rpc.send_transaction({
                signatures: signatures,
                compression: 0,
                serializedTransaction: serializedTransaction
              });

            case 31:
              response = _context15.sent;
              returnBuffer = new SerialBuffer({
                array: hexToUint8Array(response.processed.action_traces[0][1].return_value)
              });

              if (!_short) {
                _context15.next = 37;
                break;
              }

              return _context15.abrupt("return", deserializeAnyvarShort(returnBuffer));

            case 37:
              return _context15.abrupt("return", deserializeAnyvar(returnBuffer));

            case 38:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function query(_x22, _x23, _x24, _x25) {
      return _query2.apply(this, arguments);
    }

    return query;
  }()
  /** Broadcast a signed transaction */
  ;

  _proto.pushSignedTransaction =
  /*#__PURE__*/
  function () {
    var _pushSignedTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(_ref7, readOnlyTrx, returnFailureTraces) {
      var signatures, serializedTransaction, serializedContextFreeData;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              signatures = _ref7.signatures, serializedTransaction = _ref7.serializedTransaction, serializedContextFreeData = _ref7.serializedContextFreeData;

              if (readOnlyTrx === void 0) {
                readOnlyTrx = false;
              }

              if (returnFailureTraces === void 0) {
                returnFailureTraces = false;
              }

              if (!readOnlyTrx) {
                _context16.next = 5;
                break;
              }

              return _context16.abrupt("return", this.rpc.push_ro_transaction({
                signatures: signatures,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData
              }, returnFailureTraces));

            case 5:
              return _context16.abrupt("return", this.rpc.push_transaction({
                signatures: signatures,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData
              }));

            case 6:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function pushSignedTransaction(_x26, _x27, _x28) {
      return _pushSignedTransaction.apply(this, arguments);
    }

    return pushSignedTransaction;
  }();

  _proto.pushCompressedSignedTransaction = /*#__PURE__*/function () {
    var _pushCompressedSignedTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(_ref8, readOnlyTrx, returnFailureTraces) {
      var signatures, serializedTransaction, serializedContextFreeData, compressedSerializedTransaction, compressedSerializedContextFreeData;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              signatures = _ref8.signatures, serializedTransaction = _ref8.serializedTransaction, serializedContextFreeData = _ref8.serializedContextFreeData;

              if (readOnlyTrx === void 0) {
                readOnlyTrx = false;
              }

              if (returnFailureTraces === void 0) {
                returnFailureTraces = false;
              }

              compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);
              compressedSerializedContextFreeData = this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));

              if (!readOnlyTrx) {
                _context17.next = 7;
                break;
              }

              return _context17.abrupt("return", this.rpc.push_ro_transaction({
                signatures: signatures,
                compression: 1,
                serializedTransaction: compressedSerializedTransaction,
                serializedContextFreeData: compressedSerializedContextFreeData
              }, returnFailureTraces));

            case 7:
              return _context17.abrupt("return", this.rpc.push_transaction({
                signatures: signatures,
                compression: 1,
                serializedTransaction: compressedSerializedTransaction,
                serializedContextFreeData: compressedSerializedContextFreeData
              }));

            case 8:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function pushCompressedSignedTransaction(_x29, _x30, _x31) {
      return _pushCompressedSignedTransaction.apply(this, arguments);
    }

    return pushCompressedSignedTransaction;
  }();

  _proto.generateTapos = /*#__PURE__*/function () {
    var _generateTapos = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(info, transaction, blocksBehind, useLastIrreversible, expireSeconds) {
      var block, taposBlockNumber, refBlock;
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (blocksBehind === void 0) {
                blocksBehind = 3;
              }

              if (info) {
                _context18.next = 5;
                break;
              }

              _context18.next = 4;
              return this.rpc.get_info();

            case 4:
              info = _context18.sent;

            case 5:
              if (!useLastIrreversible) {
                _context18.next = 10;
                break;
              }

              _context18.next = 8;
              return this.tryRefBlockFromGetInfo(info);

            case 8:
              block = _context18.sent;
              return _context18.abrupt("return", Object.assign({}, transactionHeader(block, expireSeconds), transaction));

            case 10:
              taposBlockNumber = info.head_block_num - blocksBehind;

              if (!(taposBlockNumber <= info.last_irreversible_block_num)) {
                _context18.next = 17;
                break;
              }

              _context18.next = 14;
              return this.tryGetBlockInfo(taposBlockNumber);

            case 14:
              _context18.t0 = _context18.sent;
              _context18.next = 20;
              break;

            case 17:
              _context18.next = 19;
              return this.tryGetBlockHeaderState(taposBlockNumber);

            case 19:
              _context18.t0 = _context18.sent;

            case 20:
              refBlock = _context18.t0;
              return _context18.abrupt("return", Object.assign({}, transactionHeader(refBlock, expireSeconds), transaction));

            case 22:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function generateTapos(_x32, _x33, _x34, _x35, _x36) {
      return _generateTapos.apply(this, arguments);
    }

    return generateTapos;
  }() // eventually break out into TransactionValidator class
  ;

  _proto.hasRequiredTaposFields = function hasRequiredTaposFields(_ref9) {
    var expiration = _ref9.expiration,
        ref_block_num = _ref9.ref_block_num,
        ref_block_prefix = _ref9.ref_block_prefix;
    return !!(expiration && typeof ref_block_num === 'number' && typeof ref_block_prefix === 'number');
  };

  _proto.tryGetBlockHeaderState = /*#__PURE__*/function () {
    var _tryGetBlockHeaderState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(taposBlockNumber) {
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              _context19.prev = 0;
              _context19.next = 3;
              return this.rpc.get_block_header_state(taposBlockNumber);

            case 3:
              return _context19.abrupt("return", _context19.sent);

            case 6:
              _context19.prev = 6;
              _context19.t0 = _context19["catch"](0);
              _context19.next = 10;
              return this.tryGetBlockInfo(taposBlockNumber);

            case 10:
              return _context19.abrupt("return", _context19.sent);

            case 11:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this, [[0, 6]]);
    }));

    function tryGetBlockHeaderState(_x37) {
      return _tryGetBlockHeaderState.apply(this, arguments);
    }

    return tryGetBlockHeaderState;
  }();

  _proto.tryGetBlockInfo = /*#__PURE__*/function () {
    var _tryGetBlockInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(blockNumber) {
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              _context20.prev = 0;
              _context20.next = 3;
              return this.rpc.get_block_info(blockNumber);

            case 3:
              return _context20.abrupt("return", _context20.sent);

            case 6:
              _context20.prev = 6;
              _context20.t0 = _context20["catch"](0);
              _context20.next = 10;
              return this.rpc.get_block(blockNumber);

            case 10:
              return _context20.abrupt("return", _context20.sent);

            case 11:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this, [[0, 6]]);
    }));

    function tryGetBlockInfo(_x38) {
      return _tryGetBlockInfo.apply(this, arguments);
    }

    return tryGetBlockInfo;
  }();

  _proto.tryRefBlockFromGetInfo = /*#__PURE__*/function () {
    var _tryRefBlockFromGetInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(info) {
      var block;
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              if (!(info.hasOwnProperty('last_irreversible_block_id') && info.hasOwnProperty('last_irreversible_block_num') && info.hasOwnProperty('last_irreversible_block_time'))) {
                _context21.next = 4;
                break;
              }

              return _context21.abrupt("return", {
                block_num: info.last_irreversible_block_num,
                id: info.last_irreversible_block_id,
                timestamp: info.last_irreversible_block_time
              });

            case 4:
              _context21.next = 6;
              return this.tryGetBlockInfo(info.last_irreversible_block_num);

            case 6:
              block = _context21.sent;
              return _context21.abrupt("return", {
                block_num: block.block_num,
                id: block.id,
                timestamp: block.timestamp
              });

            case 8:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function tryRefBlockFromGetInfo(_x39) {
      return _tryRefBlockFromGetInfo.apply(this, arguments);
    }

    return tryRefBlockFromGetInfo;
  }();

  _proto["with"] = function _with(accountName) {
    return new ActionBuilder(this, accountName);
  };

  _proto.buildTransaction = function buildTransaction(cb) {
    var tx = new TransactionBuilder(this);

    if (cb) {
      return cb(tx);
    }

    return tx;
  };

  _proto.getAccountKeys = /*#__PURE__*/function () {
    var _getAccountKeys = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(actor, permission) {
      var _yield$this$rpc$get_a, permissions, relevantPermission;

      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _context22.prev = 0;
              _context22.next = 3;
              return this.rpc.get_account(actor);

            case 3:
              _yield$this$rpc$get_a = _context22.sent;
              permissions = _yield$this$rpc$get_a.permissions;
              relevantPermission = permissions.find(function (_ref10) {
                var perm_name = _ref10.perm_name;
                return perm_name === permission;
              });

              if (!relevantPermission) {
                _context22.next = 8;
                break;
              }

              return _context22.abrupt("return", relevantPermission.required_auth.keys.map(function (_ref11) {
                var key = _ref11.key;
                return PublicKey.fromString(key).toString();
              }));

            case 8:
              _context22.next = 13;
              break;

            case 10:
              _context22.prev = 10;
              _context22.t0 = _context22["catch"](0);
              console.log(_context22.t0);

            case 13:
              return _context22.abrupt("return", []);

            case 14:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this, [[0, 10]]);
    }));

    function getAccountKeys(_x40, _x41) {
      return _getAccountKeys.apply(this, arguments);
    }

    return getAccountKeys;
  }();

  _proto.sha256Digest = /*#__PURE__*/function () {
    var _sha256Digest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(array) {
      var buffer;
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              buffer = array instanceof Uint8Array ? array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength) : array;
              _context23.t0 = Uint8Array;
              _context23.next = 4;
              return this.getCrypto().subtle.digest('SHA-256', buffer);

            case 4:
              _context23.t1 = _context23.sent;
              return _context23.abrupt("return", new _context23.t0(_context23.t1));

            case 6:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function sha256Digest(_x42) {
      return _sha256Digest.apply(this, arguments);
    }

    return sha256Digest;
  }();

  _proto.matchRsaKeyToSignature = /*#__PURE__*/function () {
    var _matchRsaKeyToSignature = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(_ref12) {
      var actor, transaction, _transaction$actions$, signature, nonce, trx, creds, _iterator4, _step4, cred, rsaKey, exponentBase64, modulusBase64, clientJson, signedDigest, signBuf, serializedTransaction, actualDigest, publicKey, authData, clientJsonHash, resultingHash, verified;

      return runtime_1.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              actor = _ref12.actor, transaction = _ref12.transaction;
              // 0. Destructure
              _transaction$actions$ = transaction.actions[0].data, signature = _transaction$actions$.signature, nonce = _transaction$actions$.nonce, trx = _transaction$actions$.trx; // 1. Get user creds

              _context24.next = 4;
              return this.rpc.fetchCredentials(actor);

            case 4:
              creds = _context24.sent;
              // 2. Filter RSA
              creds = creds.filter(function (cred) {
                return cred.key.key[0] === 'rsa_public_key';
              }); // 3. For each cred

              _iterator4 = _createForOfIteratorHelperLoose(creds);

            case 7:
              if ((_step4 = _iterator4()).done) {
                _context24.next = 36;
                break;
              }

              cred = _step4.value;
              // Create key 
              rsaKey = cred.key.key[1]; // Create crypto key

              exponentBase64 = b64tob64u(Buffer.from(rsaKey.exponent, 'hex').toString('base64'));
              modulusBase64 = b64tob64u(Buffer.from(rsaKey.modulus, 'hex').toString('base64')); // Check challenge

              clientJson = JSON.parse(signature.client_json);
              signedDigest = new Uint8Array(base64url.toBuffer(clientJson.challenge).buffer); // Create TX Digest

              signBuf = new SerialBuffer();
              serializedTransaction = this.serializeTransaction(trx);
              signBuf.pushArray(serializedTransaction);
              signBuf.pushNumberAsUint64(nonce);
              _context24.next = 20;
              return this.sha256Digest(signBuf.asUint8Array().slice());

            case 20:
              actualDigest = _context24.sent;

              if (!(arrayToHex(signedDigest) !== arrayToHex(actualDigest))) {
                _context24.next = 23;
                break;
              }

              return _context24.abrupt("continue", 34);

            case 23:
              _context24.next = 25;
              return this.getCrypto().subtle.importKey('jwk', {
                //this is an example jwk key, other key types are Uint8Array objects
                kty: 'RSA',
                e: exponentBase64,
                n: modulusBase64,
                alg: 'RS256',
                ext: false
              }, {
                name: 'RSASSA-PKCS1-v1_5',
                hash: {
                  name: 'SHA-256'
                }
              }, false, ['verify']);

            case 25:
              publicKey = _context24.sent;
              authData = hexToUint8Array(signature.auth_data);
              clientJsonHash = hexToUint8Array(sha256(signature.client_json));
              resultingHash = new Uint8Array([].concat(authData, clientJsonHash));
              _context24.next = 31;
              return this.getCrypto().subtle.verify('RSASSA-PKCS1-v1_5', publicKey, hexToUint8Array(signature.signature), resultingHash);

            case 31:
              verified = _context24.sent;

              if (!verified) {
                _context24.next = 34;
                break;
              }

              return _context24.abrupt("return", true);

            case 34:
              _context24.next = 7;
              break;

            case 36:
              return _context24.abrupt("return", false);

            case 37:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function matchRsaKeyToSignature(_x43) {
      return _matchRsaKeyToSignature.apply(this, arguments);
    }

    return matchRsaKeyToSignature;
  }();

  _proto.matchEthKeyToSignature = /*#__PURE__*/function () {
    var _matchEthKeyToSignature = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25(_ref13) {
      var actor, transaction, _transaction$actions$2, signature, nonce, trx, creds, _iterator5, _step5, cred, ethKey, signBuf, serializedTransaction, actualDigestArray, actualDigest, ethSignature, signedWithKey;

      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              actor = _ref13.actor, transaction = _ref13.transaction;
              // 0. Destructure
              _transaction$actions$2 = transaction.actions[0].data, signature = _transaction$actions$2.signature, nonce = _transaction$actions$2.nonce, trx = _transaction$actions$2.trx; // 1. Get user creds

              _context25.next = 4;
              return this.rpc.fetchCredentials(actor);

            case 4:
              creds = _context25.sent;
              // 2. Filter RSA
              creds = creds.filter(function (cred) {
                return cred.key.key[0] === 'eth_public_key';
              }); // 3. For each cred

              _iterator5 = _createForOfIteratorHelperLoose(creds);

            case 7:
              if ((_step5 = _iterator5()).done) {
                _context25.next = 24;
                break;
              }

              cred = _step5.value;
              // Create key
              ethKey = '0x' + cred.key.key[1]; // Create TX Digest

              signBuf = new SerialBuffer();
              serializedTransaction = this.serializeTransaction(trx);
              signBuf.pushArray(serializedTransaction);
              signBuf.pushNumberAsUint64(nonce);
              _context25.next = 16;
              return this.sha256Digest(signBuf.asUint8Array().slice());

            case 16:
              actualDigestArray = _context25.sent;
              actualDigest = arrayToHex(actualDigestArray); // Create signature

              ethSignature = '0x' + signature.signature; // Verify

              signedWithKey = this.getRecoverPersonalSignature()({
                data: actualDigest,
                sig: ethSignature
              });

              if (!(signedWithKey === ethKey)) {
                _context25.next = 22;
                break;
              }

              return _context25.abrupt("return", true);

            case 22:
              _context25.next = 7;
              break;

            case 24:
              return _context25.abrupt("return", false);

            case 25:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function matchEthKeyToSignature(_x44) {
      return _matchEthKeyToSignature.apply(this, arguments);
    }

    return matchEthKeyToSignature;
  }();

  _proto.matchWaKeyToSignature = /*#__PURE__*/function () {
    var _matchWaKeyToSignature = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee26(_ref14) {
      var signature, key, digest, fullSignature, sigData, r1Signature, authenticatorData, clientDataJSON, whatItReallySigned, recoveredR1Key, waPublicKey, actualR1KeyBuffer, actualR1Key;
      return runtime_1.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              signature = _ref14.signature, key = _ref14.key, digest = _ref14.digest;
              _context26.prev = 1;
              // Decode WA Signature data
              fullSignature = stringToSignature(signature);
              sigData = new SerialBuffer({
                array: fullSignature.data
              }); // Create R1

              r1Signature = new Signature({
                type: KeyType.r1,
                data: sigData.getUint8Array(65)
              }, new ec('p256')); // Recreate the data the browser actually signed

              authenticatorData = sigData.getBytes().slice();
              clientDataJSON = sigData.getBytes().slice();
              whatItReallySigned = new SerialBuffer();
              whatItReallySigned.pushArray(authenticatorData);
              _context26.t0 = whatItReallySigned;
              _context26.next = 12;
              return this.sha256Digest(clientDataJSON);

            case 12:
              _context26.t1 = _context26.sent;

              _context26.t0.pushArray.call(_context26.t0, _context26.t1);

              // Recover public key
              recoveredR1Key = r1Signature.recover(whatItReallySigned.asUint8Array()); // Create actual R1 Pub Key

              waPublicKey = PublicKey.fromString(key);
              actualR1KeyBuffer = new SerialBuffer({
                array: waPublicKey.key.data.slice(0, 33)
              });
              actualR1Key = publicKeyToString({
                type: KeyType.r1,
                data: actualR1KeyBuffer.asUint8Array()
              });
              return _context26.abrupt("return", recoveredR1Key.toString() === actualR1Key && r1Signature.verify(digest, recoveredR1Key, false));

            case 21:
              _context26.prev = 21;
              _context26.t2 = _context26["catch"](1);
              return _context26.abrupt("return", false);

            case 24:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26, this, [[1, 21]]);
    }));

    function matchWaKeyToSignature(_x45) {
      return _matchWaKeyToSignature.apply(this, arguments);
    }

    return matchWaKeyToSignature;
  }();

  _proto.checkIfKeysMatchTransaction = /*#__PURE__*/function () {
    var _checkIfKeysMatchTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee27(_ref15) {
      var _this5 = this;

      var actor, permission, transaction, signatures, chainId, webauthTransaction, _iterator6, _step6, action, _iterator7, _step7, authorization, typeOfKey, _iterator8, _step8, _action, _iterator9, _step9, _authorization, info, serializedTransaction, serializedContextFreeData, signature, signatureType, digest, keys, verified;

      return runtime_1.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              actor = _ref15.actor, permission = _ref15.permission, transaction = _ref15.transaction, signatures = _ref15.signatures, chainId = _ref15.chainId;
              // Copy by value
              transaction = JSON.parse(JSON.stringify(transaction));
              signatures = JSON.parse(JSON.stringify(signatures)); // RSA / ETH WA

              if (!(transaction.actions.length === 1 && transaction.actions[0].account === 'webauthn' && transaction.actions[0].name === 'exec' && permission === 'active')) {
                _context27.next = 33;
                break;
              }

              // Destructure
              webauthTransaction = transaction.actions[0].data.trx;
              console.dir(webauthTransaction, {
                depth: null
              });

              if (!(webauthTransaction.actions.length !== 1)) {
                _context27.next = 8;
                break;
              }

              return _context27.abrupt("return", false);

            case 8:
              _iterator6 = _createForOfIteratorHelperLoose(webauthTransaction.actions);

            case 9:
              if ((_step6 = _iterator6()).done) {
                _context27.next = 20;
                break;
              }

              action = _step6.value;
              _iterator7 = _createForOfIteratorHelperLoose(action.authorization);

            case 12:
              if ((_step7 = _iterator7()).done) {
                _context27.next = 18;
                break;
              }

              authorization = _step7.value;

              if (!(authorization.actor !== actor || authorization.permission !== permission)) {
                _context27.next = 16;
                break;
              }

              return _context27.abrupt("return", false);

            case 16:
              _context27.next = 12;
              break;

            case 18:
              _context27.next = 9;
              break;

            case 20:
              typeOfKey = transaction.actions[0].data.key.key[0];

              if (!(typeOfKey === 'eth_public_key')) {
                _context27.next = 25;
                break;
              }

              return _context27.abrupt("return", this.matchEthKeyToSignature({
                transaction: transaction,
                actor: actor
              }));

            case 25:
              if (!(typeOfKey === 'rsa_public_key')) {
                _context27.next = 29;
                break;
              }

              return _context27.abrupt("return", this.matchRsaKeyToSignature({
                transaction: transaction,
                actor: actor
              }));

            case 29:
              console.log("Key type " + typeOfKey + " not supported");
              return _context27.abrupt("return", false);

            case 31:
              _context27.next = 66;
              break;

            case 33:
              _iterator8 = _createForOfIteratorHelperLoose(transaction.actions);

            case 34:
              if ((_step8 = _iterator8()).done) {
                _context27.next = 45;
                break;
              }

              _action = _step8.value;
              _iterator9 = _createForOfIteratorHelperLoose(_action.authorization);

            case 37:
              if ((_step9 = _iterator9()).done) {
                _context27.next = 43;
                break;
              }

              _authorization = _step9.value;

              if (!(_authorization.actor !== actor || _authorization.permission !== permission)) {
                _context27.next = 41;
                break;
              }

              return _context27.abrupt("return", false);

            case 41:
              _context27.next = 37;
              break;

            case 43:
              _context27.next = 34;
              break;

            case 45:
              if (chainId) {
                _context27.next = 50;
                break;
              }

              _context27.next = 48;
              return this.rpc.get_info();

            case 48:
              info = _context27.sent;
              chainId = info.chain_id;

            case 50:
              _context27.next = 52;
              return this.serializeActions(transaction.context_free_actions || []);

            case 52:
              transaction.context_free_actions = _context27.sent;
              _context27.next = 55;
              return this.serializeActions(transaction.actions);

            case 55:
              transaction.actions = _context27.sent;
              serializedTransaction = this.serializeTransaction(transaction);
              serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
              signature = Signature.fromString(signatures[0]);
              signatureType = signature.getType();
              digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData); // Check keys

              _context27.next = 63;
              return this.getAccountKeys(actor, permission);

            case 63:
              keys = _context27.sent;
              verified = keys.some(function (key) {
                var publicKey = PublicKey.fromString(key);

                if (signatureType === KeyType.wa) {
                  return _this5.matchWaKeyToSignature({
                    signature: signature.toString(),
                    key: publicKey.toString(),
                    digest: digest
                  });
                } else if ([KeyType.k1, KeyType.r1].includes(signatureType)) {
                  return signature.verify(digest, publicKey, false);
                } else {
                  console.log("Key type " + signatureType + " not supported");
                  return false;
                }
              });
              return _context27.abrupt("return", verified);

            case 66:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee27, this);
    }));

    function checkIfKeysMatchTransaction(_x46) {
      return _checkIfKeysMatchTransaction.apply(this, arguments);
    }

    return checkIfKeysMatchTransaction;
  }();

  return Api;
}(); // Api

var TransactionBuilder = /*#__PURE__*/function () {
  function TransactionBuilder(api) {
    this.api = void 0;
    this.actions = [];
    this.contextFreeGroups = [];
    this.api = api;
  }

  var _proto2 = TransactionBuilder.prototype;

  _proto2["with"] = function _with(accountName) {
    var actionBuilder = new ActionBuilder(this.api, accountName);
    this.actions.push(actionBuilder);
    return actionBuilder;
  };

  _proto2.associateContextFree = function associateContextFree(contextFreeGroup) {
    this.contextFreeGroups.push(contextFreeGroup);
    return this;
  };

  _proto2.send = /*#__PURE__*/function () {
    var _send = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee29(config) {
      var contextFreeDataSet, contextFreeActions, actions;
      return runtime_1.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              contextFreeDataSet = [];
              contextFreeActions = [];
              actions = this.actions.map(function (actionBuilder) {
                return actionBuilder.serializedData;
              });
              _context29.next = 5;
              return Promise.all(this.contextFreeGroups.map( /*#__PURE__*/function () {
                var _ref16 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee28(contextFreeCallback) {
                  var _contextFreeCallback, action, contextFreeAction, contextFreeData;

                  return runtime_1.wrap(function _callee28$(_context28) {
                    while (1) {
                      switch (_context28.prev = _context28.next) {
                        case 0:
                          _contextFreeCallback = contextFreeCallback({
                            cfd: contextFreeDataSet.length,
                            cfa: contextFreeActions.length
                          }), action = _contextFreeCallback.action, contextFreeAction = _contextFreeCallback.contextFreeAction, contextFreeData = _contextFreeCallback.contextFreeData;

                          if (action) {
                            actions.push(action);
                          }

                          if (contextFreeAction) {
                            contextFreeActions.push(contextFreeAction);
                          }

                          if (contextFreeData) {
                            contextFreeDataSet.push(contextFreeData);
                          }

                        case 4:
                        case "end":
                          return _context28.stop();
                      }
                    }
                  }, _callee28);
                }));

                return function (_x48) {
                  return _ref16.apply(this, arguments);
                };
              }()));

            case 5:
              this.contextFreeGroups = [];
              this.actions = [];
              _context29.next = 9;
              return this.api.transact({
                context_free_data: contextFreeDataSet,
                context_free_actions: contextFreeActions,
                actions: actions
              }, config);

            case 9:
              return _context29.abrupt("return", _context29.sent);

            case 10:
            case "end":
              return _context29.stop();
          }
        }
      }, _callee29, this);
    }));

    function send(_x47) {
      return _send.apply(this, arguments);
    }

    return send;
  }();

  return TransactionBuilder;
}();
var ActionBuilder = /*#__PURE__*/function () {
  function ActionBuilder(api, accountName) {
    this.api = void 0;
    this.accountName = void 0;
    this.serializedData = void 0;
    this.api = api;
    this.accountName = accountName;
  }

  var _proto3 = ActionBuilder.prototype;

  _proto3.as = function as(actorName) {
    if (actorName === void 0) {
      actorName = [];
    }

    var authorization = [];

    if (actorName && typeof actorName === 'string') {
      authorization = [{
        actor: actorName,
        permission: 'active'
      }];
    } else {
      authorization = actorName;
    }

    return new ActionSerializer(this, this.api, this.accountName, authorization);
  };

  return ActionBuilder;
}();

var ActionSerializer = function ActionSerializer(parent, api, accountName, authorization) {
  var _this6 = this;

  var jsonAbi = api.cachedAbis.get(accountName);

  if (!jsonAbi) {
    throw new Error('ABI must be cached before using ActionBuilder, run api.getAbi()');
  }

  var types = getTypesFromAbi(createInitialTypes(), jsonAbi.abi);
  var actions = new Map();

  for (var _iterator10 = _createForOfIteratorHelperLoose(jsonAbi.abi.actions), _step10; !(_step10 = _iterator10()).done;) {
    var _step10$value = _step10.value,
        name = _step10$value.name,
        type = _step10$value.type;
    actions.set(name, getType(types, type));
  }

  actions.forEach(function (type, name) {
    var _Object$assign;

    Object.assign(_this6, (_Object$assign = {}, _Object$assign[name] = function () {
      var data = {};

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.forEach(function (arg, index) {
        var field = type.fields[index];
        data[field.name] = arg;
      });
      var serializedData = serializeAction({
        types: types,
        actions: actions
      }, accountName, name, authorization, data);
      parent.serializedData = serializedData;
      return serializedData;
    }, _Object$assign));
  });
};

/**
 * @module Javascript-API
 */

var ApiInterfaces = {
  __proto__: null
};

/**
 * @module RPC-Error
 */

/** Holds detailed error information */
var RpcError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RpcError, _Error);

  /** Detailed error information */
  function RpcError(json) {
    var _this;

    if (json && json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
      _this = _Error.call(this, json.error.details[0].message) || this;
      _this.json = void 0;
      _this.details = void 0;
      _this.details = json.error.details;
    } else if (json && json.processed && json.processed.except && json.processed.except.message) {
      _this = _Error.call(this, json.processed.except.message) || this;
      _this.json = void 0;
      _this.details = void 0;
      _this.details = json.processed.except;
    } else if (json && json.result && json.result.except && json.result.except.message) {
      _this = _Error.call(this, json.result.except.message) || this;
      _this.json = void 0;
      _this.details = void 0;
      _this.details = json.result.except;
    } else if (json) {
      _this = _Error.call(this, json.message) || this;
      _this.json = void 0;
      _this.details = void 0;
    } else {
      _this = _Error.call(this, json) || this;
      _this.json = void 0;
      _this.details = void 0;
    }

    Object.setPrototypeOf(_assertThisInitialized(_this), RpcError.prototype);
    _this.json = json;
    return _assertThisInitialized(_this);
  }

  return RpcError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/**
 * Checks blockchain for a list of kycproviders, and sorts through the ones that are blacklisted.
 * @returns An array of strings with valid kyc provider names.
 */
function getValidKycProviders() {
  return _getValidKycProviders.apply(this, arguments);
}
/**
 * Takes an account or a list of accounts and checks to make sure that they are light-verified
 * @param account This could be an array of user rows from the usersinfo table on the blockchain, or a singular string for an account name
 * @returns An object of the user data as pulled from the usersinfo table on the blockchain with an additional key, isLightKYCVerified (boolean)
 */

function _getValidKycProviders() {
  _getValidKycProviders = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
    var _yield$this$get_table, rows;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return this.get_table_rows({
              code: 'eosio.proton',
              table: 'kycproviders',
              scope: 'eosio.proton'
            });

          case 3:
            _yield$this$get_table = _context.sent;
            rows = _yield$this$get_table.rows;
            this.validKycProviders = rows.reduce(function (acc, provider) {
              if (!provider.blisted) {
                acc.push(provider.kyc_provider);
              }

              return acc;
            }, []);
            _context.next = 11;
            break;

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            throw new Error('Unable to get KYC Providers.');

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0, 8]]);
  }));
  return _getValidKycProviders.apply(this, arguments);
}

function isLightKYCVerified(_x) {
  return _isLightKYCVerified.apply(this, arguments);
}

function _isLightKYCVerified() {
  _isLightKYCVerified = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(account) {
    var _this = this;

    var lightKyc, users, _yield$this$get_table2, rows, resultsWithKycStatus;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            lightKyc = ["firstname", "lastname", "birthdate", "address"];

            if (!(account.length === 0)) {
              _context2.next = 3;
              break;
            }

            throw new Error('Please enter an account.');

          case 3:
            if (!(this.validKycProviders.length === 0)) {
              _context2.next = 6;
              break;
            }

            _context2.next = 6;
            return this.getValidKycProviders();

          case 6:
            users = [];

            if (!Array.isArray(account)) {
              _context2.next = 11;
              break;
            }

            users = account;
            _context2.next = 23;
            break;

          case 11:
            if (!(typeof account === 'string')) {
              _context2.next = 23;
              break;
            }

            _context2.prev = 12;
            _context2.next = 15;
            return this.get_table_rows({
              code: 'eosio.proton',
              table: 'usersinfo',
              scope: 'eosio.proton',
              lower_bound: account,
              upper_bound: account
            });

          case 15:
            _yield$this$get_table2 = _context2.sent;
            rows = _yield$this$get_table2.rows;
            users = rows;
            _context2.next = 23;
            break;

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](12);
            throw new Error('Account not found!');

          case 23:
            resultsWithKycStatus = users.map(function (user) {
              var levelsResult = user.kyc.reduce(function (acc, kyc) {
                if (_this.validKycProviders.indexOf(kyc.kyc_provider) >= 0) {
                  var result = kyc.kyc_level.split(',').map(function (kycItem) {
                    return kycItem.split(':')[1];
                  });
                  acc = result.concat(acc);
                }

                return acc;
              }, []);
              user.isLightKYCVerified = lightKyc.every(function (lightKycField) {
                return levelsResult.includes(lightKycField);
              });
              return user;
            });
            return _context2.abrupt("return", resultsWithKycStatus);

          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[12, 20]]);
  }));
  return _isLightKYCVerified.apply(this, arguments);
}
function fetchCredentials(_x2) {
  return _fetchCredentials.apply(this, arguments);
}

function _fetchCredentials() {
  _fetchCredentials = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(actor) {
    var _yield$this$get_table3, credentials;

    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.get_table_rows({
              code: 'webauthn',
              scope: 'webauthn',
              table: 'credentials',
              lower_bound: actor,
              upper_bound: actor,
              key_type: 'name',
              index_position: 2
            });

          case 2:
            _yield$this$get_table3 = _context3.sent;
            credentials = _yield$this$get_table3.rows;
            return _context3.abrupt("return", credentials);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _fetchCredentials.apply(this, arguments);
}

var arrayToHex$1 = function arrayToHex(data) {
  var result = '';

  for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done;) {
    var x = _step.value;
    result += ('00' + x.toString(16)).slice(-2);
  }

  return result;
};
/** Make RPC calls */


var JsonRpc = /*#__PURE__*/function () {
  /**
   * @param args
   *`fetch`:
   * browsers: leave `null` or `undefined`
   * node: provide an implementation
   */
  function JsonRpc(endpoints) {
    this.endpoints = void 0;
    this.maxRetries = 3;
    this.currentEndpoint = void 0;
    this.validKycProviders = [];
    this.isLightKYCVerified = isLightKYCVerified;
    this.getValidKycProviders = getValidKycProviders;
    this.fetchCredentials = fetchCredentials;
    endpoints = Array.isArray(endpoints) ? endpoints : [endpoints];
    this.endpoints = endpoints.map(function (endpoint) {
      return endpoint.replace(/\/$/, '');
    });
    this.currentEndpoint = '';
    this.nextEndpoint();
  }

  var _proto = JsonRpc.prototype;

  _proto.nextEndpoint = function nextEndpoint() {
    if (this.endpoints.length) {
      if (this.currentEndpoint) {
        var removed = this.endpoints.shift();
        this.endpoints = this.endpoints.concat(removed || []);
      }

      this.currentEndpoint = this.endpoints[0];
    }
  }
  /** Post `body` to `endpoint + path`. Throws detailed error information in `RpcError` when available. */
  ;

  _proto.fetch =
  /*#__PURE__*/
  function () {
    var _fetch2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(path, body, currentRetries) {
      var response, json, headTime, ct, secondsBehind;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (currentRetries === void 0) {
                currentRetries = 0;
              }

              _context.prev = 1;
              _context.next = 4;
              return _fetch(this.currentEndpoint + path, {
                body: JSON.stringify(body),
                method: 'POST'
              });

            case 4:
              response = _context.sent;
              _context.next = 7;
              return response.json();

            case 7:
              json = _context.sent;

              if (!(json.processed && json.processed.except)) {
                _context.next = 12;
                break;
              }

              throw new RpcError(json);

            case 12:
              if (!(json.result && json.result.except)) {
                _context.next = 14;
                break;
              }

              throw new RpcError(json);

            case 14:
              _context.next = 27;
              break;

            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](1);
              console.log({
                currentEndpoint: this.currentEndpoint,
                endpoints: this.endpoints,
                currentRetries: currentRetries,
                error: _context.t0
              });

              if (!(this.endpoints.length > 1)) {
                _context.next = 27;
                break;
              }

              this.nextEndpoint();

              if (!(currentRetries < this.maxRetries)) {
                _context.next = 25;
                break;
              }

              return _context.abrupt("return", this.fetch(path, body, ++currentRetries));

            case 25:
              _context.t0.isFetchError = true;
              throw new RpcError(_context.t0);

            case 27:
              if (response && response.ok) {
                _context.next = 29;
                break;
              }

              throw new RpcError(json);

            case 29:
              if (!(json && json.head_block_time)) {
                _context.next = 37;
                break;
              }

              headTime = new Date(json.head_block_time + 'Z').getTime();
              ct = new Date().getTime();
              secondsBehind = (ct - headTime) / 1000;

              if (!(secondsBehind > 30 && this.endpoints.length > 1)) {
                _context.next = 37;
                break;
              }

              this.nextEndpoint();

              if (!(currentRetries < this.maxRetries)) {
                _context.next = 37;
                break;
              }

              return _context.abrupt("return", this.fetch(path, body, ++currentRetries));

            case 37:
              return _context.abrupt("return", json);

            case 38:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 16]]);
    }));

    function fetch(_x, _x2, _x3) {
      return _fetch2.apply(this, arguments);
    }

    return fetch;
  }()
  /** Get from endpoint  */
  ;

  _proto.get =
  /*#__PURE__*/
  function () {
    var _get = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(path) {
      var res, data;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _fetch(path);

            case 2:
              res = _context2.sent;

              if (!(res.status >= 400)) {
                _context2.next = 5;
                break;
              }

              throw new Error("Bad response from server " + res.status);

            case 5:
              _context2.next = 7;
              return res.json();

            case 7:
              data = _context2.sent;
              return _context2.abrupt("return", data);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function get(_x4) {
      return _get.apply(this, arguments);
    }

    return get;
  }();

  _proto.abi_bin_to_json = /*#__PURE__*/function () {
    var _abi_bin_to_json = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(code, action, binargs) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.fetch('/v1/chain/abi_bin_to_json', {
                code: code,
                action: action,
                binargs: binargs
              });

            case 2:
              return _context3.abrupt("return", _context3.sent);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function abi_bin_to_json(_x5, _x6, _x7) {
      return _abi_bin_to_json.apply(this, arguments);
    }

    return abi_bin_to_json;
  }();

  _proto.abi_json_to_bin = /*#__PURE__*/function () {
    var _abi_json_to_bin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(code, action, args) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.fetch('/v1/chain/abi_json_to_bin', {
                code: code,
                action: action,
                args: args
              });

            case 2:
              return _context4.abrupt("return", _context4.sent);

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function abi_json_to_bin(_x8, _x9, _x10) {
      return _abi_json_to_bin.apply(this, arguments);
    }

    return abi_json_to_bin;
  }()
  /** Raw call to `/v1/chain/get_abi` */
  ;

  _proto.get_abi =
  /*#__PURE__*/
  function () {
    var _get_abi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(accountName) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.fetch('/v1/chain/get_abi', {
                account_name: accountName
              });

            case 2:
              return _context5.abrupt("return", _context5.sent);

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function get_abi(_x11) {
      return _get_abi.apply(this, arguments);
    }

    return get_abi;
  }()
  /** Raw call to `/v1/chain/get_account` */
  ;

  _proto.get_account =
  /*#__PURE__*/
  function () {
    var _get_account = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(accountName) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.fetch('/v1/chain/get_account', {
                account_name: accountName
              });

            case 2:
              return _context6.abrupt("return", _context6.sent);

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function get_account(_x12) {
      return _get_account.apply(this, arguments);
    }

    return get_account;
  }()
  /** Raw call to `/v1/chain/get_accounts_by_authorizers` */
  ;

  _proto.get_accounts_by_authorizers =
  /*#__PURE__*/
  function () {
    var _get_accounts_by_authorizers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(accounts, keys) {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.fetch('/v1/chain/get_accounts_by_authorizers', {
                accounts: accounts,
                keys: keys
              });

            case 2:
              return _context7.abrupt("return", _context7.sent);

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function get_accounts_by_authorizers(_x13, _x14) {
      return _get_accounts_by_authorizers.apply(this, arguments);
    }

    return get_accounts_by_authorizers;
  }()
  /** Raw call to `get_activated_protocol_features` */
  ;

  _proto.get_activated_protocol_features =
  /*#__PURE__*/
  function () {
    var _get_activated_protocol_features = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(_temp) {
      var _ref, limit, search_by_block_num, reverse, lower_bound, upper_bound;

      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _ref = _temp === void 0 ? {
                limit: 50,
                search_by_block_num: false,
                reverse: false
              } : _temp, limit = _ref.limit, search_by_block_num = _ref.search_by_block_num, reverse = _ref.reverse, lower_bound = _ref.lower_bound, upper_bound = _ref.upper_bound;
              _context8.next = 3;
              return this.fetch('/v1/chain/get_activated_protocol_features', {
                lower_bound: lower_bound,
                upper_bound: upper_bound,
                limit: limit,
                search_by_block_num: search_by_block_num,
                reverse: reverse
              });

            case 3:
              return _context8.abrupt("return", _context8.sent);

            case 4:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function get_activated_protocol_features(_x15) {
      return _get_activated_protocol_features.apply(this, arguments);
    }

    return get_activated_protocol_features;
  }()
  /** Raw call to `/v1/chain/get_block_header_state` */
  ;

  _proto.get_block_header_state =
  /*#__PURE__*/
  function () {
    var _get_block_header_state = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(blockNumOrId) {
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.fetch('/v1/chain/get_block_header_state', {
                block_num_or_id: blockNumOrId
              });

            case 2:
              return _context9.abrupt("return", _context9.sent);

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function get_block_header_state(_x16) {
      return _get_block_header_state.apply(this, arguments);
    }

    return get_block_header_state;
  }()
  /** Raw call to `/v1/chain/get_block_info` */
  ;

  _proto.get_block_info =
  /*#__PURE__*/
  function () {
    var _get_block_info = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(blockNum) {
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.fetch('/v1/chain/get_block_info', {
                block_num: blockNum
              });

            case 2:
              return _context10.abrupt("return", _context10.sent);

            case 3:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function get_block_info(_x17) {
      return _get_block_info.apply(this, arguments);
    }

    return get_block_info;
  }()
  /** Raw call to `/v1/chain/get_block` */
  ;

  _proto.get_block =
  /*#__PURE__*/
  function () {
    var _get_block = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(blockNumOrId) {
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.fetch('/v1/chain/get_block', {
                block_num_or_id: blockNumOrId
              });

            case 2:
              return _context11.abrupt("return", _context11.sent);

            case 3:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function get_block(_x18) {
      return _get_block.apply(this, arguments);
    }

    return get_block;
  }()
  /** Raw call to `/v1/chain/get_code` */
  ;

  _proto.get_code =
  /*#__PURE__*/
  function () {
    var _get_code = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(accountName) {
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.fetch('/v1/chain/get_code', {
                account_name: accountName,
                code_as_wasm: true
              });

            case 2:
              return _context12.abrupt("return", _context12.sent);

            case 3:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function get_code(_x19) {
      return _get_code.apply(this, arguments);
    }

    return get_code;
  }()
  /** Raw call to `/v1/chain/get_code_hash` */
  ;

  _proto.get_code_hash =
  /*#__PURE__*/
  function () {
    var _get_code_hash = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(accountName) {
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return this.fetch('/v1/chain/get_code_hash', {
                account_name: accountName
              });

            case 2:
              return _context13.abrupt("return", _context13.sent);

            case 3:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function get_code_hash(_x20) {
      return _get_code_hash.apply(this, arguments);
    }

    return get_code_hash;
  }()
  /** Raw call to `/v1/chain/get_currency_balance` */
  ;

  _proto.get_currency_balance =
  /*#__PURE__*/
  function () {
    var _get_currency_balance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(code, account, symbol) {
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.fetch('/v1/chain/get_currency_balance', {
                code: code,
                account: account,
                symbol: symbol
              });

            case 2:
              return _context14.abrupt("return", _context14.sent);

            case 3:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function get_currency_balance(_x21, _x22, _x23) {
      return _get_currency_balance.apply(this, arguments);
    }

    return get_currency_balance;
  }()
  /** Raw call to `/v1/chain/get_currency_stats` */
  ;

  _proto.get_currency_stats =
  /*#__PURE__*/
  function () {
    var _get_currency_stats = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(code, symbol) {
      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return this.fetch('/v1/chain/get_currency_stats', {
                code: code,
                symbol: symbol
              });

            case 2:
              return _context15.abrupt("return", _context15.sent);

            case 3:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function get_currency_stats(_x24, _x25) {
      return _get_currency_stats.apply(this, arguments);
    }

    return get_currency_stats;
  }()
  /** Raw call to `/v1/chain/get_info` */
  ;

  _proto.get_info =
  /*#__PURE__*/
  function () {
    var _get_info = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16() {
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return this.fetch('/v1/chain/get_info', {});

            case 2:
              return _context16.abrupt("return", _context16.sent);

            case 3:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function get_info() {
      return _get_info.apply(this, arguments);
    }

    return get_info;
  }()
  /** Raw call to `/v1/chain/get_producer_schedule` */
  ;

  _proto.get_producer_schedule =
  /*#__PURE__*/
  function () {
    var _get_producer_schedule = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17() {
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return this.fetch('/v1/chain/get_producer_schedule', {});

            case 2:
              return _context17.abrupt("return", _context17.sent);

            case 3:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function get_producer_schedule() {
      return _get_producer_schedule.apply(this, arguments);
    }

    return get_producer_schedule;
  }()
  /** Raw call to `/v1/chain/get_producers` */
  ;

  _proto.get_producers =
  /*#__PURE__*/
  function () {
    var _get_producers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(json, lowerBound, limit) {
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (json === void 0) {
                json = true;
              }

              if (lowerBound === void 0) {
                lowerBound = '';
              }

              if (limit === void 0) {
                limit = 50;
              }

              _context18.next = 5;
              return this.fetch('/v1/chain/get_producers', {
                json: json,
                lower_bound: lowerBound,
                limit: limit
              });

            case 5:
              return _context18.abrupt("return", _context18.sent);

            case 6:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function get_producers(_x26, _x27, _x28) {
      return _get_producers.apply(this, arguments);
    }

    return get_producers;
  }()
  /** Raw call to `/v1/chain/get_raw_code_and_abi` */
  ;

  _proto.get_raw_code_and_abi =
  /*#__PURE__*/
  function () {
    var _get_raw_code_and_abi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(accountName) {
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return this.fetch('/v1/chain/get_raw_code_and_abi', {
                account_name: accountName
              });

            case 2:
              return _context19.abrupt("return", _context19.sent);

            case 3:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function get_raw_code_and_abi(_x29) {
      return _get_raw_code_and_abi.apply(this, arguments);
    }

    return get_raw_code_and_abi;
  }()
  /** calls `/v1/chain/get_raw_code_and_abi` and pulls out unneeded raw wasm code */
  ;

  _proto.getRawAbi =
  /*#__PURE__*/
  function () {
    var _getRawAbi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(accountName) {
      var rawAbi, abi;
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.get_raw_abi(accountName);

            case 2:
              rawAbi = _context20.sent;
              abi = base64ToBinary(rawAbi.abi);
              return _context20.abrupt("return", {
                accountName: rawAbi.account_name,
                abi: abi
              });

            case 5:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function getRawAbi(_x30) {
      return _getRawAbi.apply(this, arguments);
    }

    return getRawAbi;
  }()
  /** Raw call to `/v1/chain/get_raw_abi` */
  ;

  _proto.get_raw_abi =
  /*#__PURE__*/
  function () {
    var _get_raw_abi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(accountName) {
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return this.fetch('/v1/chain/get_raw_abi', {
                account_name: accountName
              });

            case 2:
              return _context21.abrupt("return", _context21.sent);

            case 3:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function get_raw_abi(_x31) {
      return _get_raw_abi.apply(this, arguments);
    }

    return get_raw_abi;
  }()
  /** Raw call to `/v1/chain/get_scheduled_transactions` */
  ;

  _proto.get_scheduled_transactions =
  /*#__PURE__*/
  function () {
    var _get_scheduled_transactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(json, lowerBound, limit) {
      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              if (json === void 0) {
                json = true;
              }

              if (lowerBound === void 0) {
                lowerBound = '';
              }

              if (limit === void 0) {
                limit = 50;
              }

              _context22.next = 5;
              return this.fetch('/v1/chain/get_scheduled_transactions', {
                json: json,
                lower_bound: lowerBound,
                limit: limit
              });

            case 5:
              return _context22.abrupt("return", _context22.sent);

            case 6:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function get_scheduled_transactions(_x32, _x33, _x34) {
      return _get_scheduled_transactions.apply(this, arguments);
    }

    return get_scheduled_transactions;
  }()
  /** Raw call to `/v1/chain/get_table_rows` */
  ;

  _proto.get_table_rows =
  /*#__PURE__*/
  function () {
    var _get_table_rows = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(_ref2) {
      var _ref2$json, json, code, scope, table, _ref2$lower_bound, lower_bound, _ref2$upper_bound, upper_bound, _ref2$index_position, index_position, _ref2$key_type, key_type, _ref2$limit, limit, _ref2$reverse, reverse, _ref2$show_payer, show_payer;

      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _ref2$json = _ref2.json, json = _ref2$json === void 0 ? true : _ref2$json, code = _ref2.code, scope = _ref2.scope, table = _ref2.table, _ref2$lower_bound = _ref2.lower_bound, lower_bound = _ref2$lower_bound === void 0 ? '' : _ref2$lower_bound, _ref2$upper_bound = _ref2.upper_bound, upper_bound = _ref2$upper_bound === void 0 ? '' : _ref2$upper_bound, _ref2$index_position = _ref2.index_position, index_position = _ref2$index_position === void 0 ? 1 : _ref2$index_position, _ref2$key_type = _ref2.key_type, key_type = _ref2$key_type === void 0 ? '' : _ref2$key_type, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 10 : _ref2$limit, _ref2$reverse = _ref2.reverse, reverse = _ref2$reverse === void 0 ? false : _ref2$reverse, _ref2$show_payer = _ref2.show_payer, show_payer = _ref2$show_payer === void 0 ? false : _ref2$show_payer;
              _context23.next = 3;
              return this.fetch('/v1/chain/get_table_rows', {
                json: json,
                code: code,
                scope: scope,
                table: table,
                lower_bound: lower_bound,
                upper_bound: upper_bound,
                index_position: index_position,
                key_type: key_type,
                limit: limit,
                reverse: reverse,
                show_payer: show_payer
              });

            case 3:
              return _context23.abrupt("return", _context23.sent);

            case 4:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function get_table_rows(_x35) {
      return _get_table_rows.apply(this, arguments);
    }

    return get_table_rows;
  }()
  /** Raw call to `/v1/chain/get_kv_table_rows` */
  ;

  _proto.get_kv_table_rows =
  /*#__PURE__*/
  function () {
    var _get_kv_table_rows = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(_ref3) {
      var _ref3$json, json, code, table, index_name, _ref3$encode_type, encode_type, index_value, lower_bound, upper_bound, _ref3$limit, limit, _ref3$reverse, reverse, _ref3$show_payer, show_payer;

      return runtime_1.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _ref3$json = _ref3.json, json = _ref3$json === void 0 ? true : _ref3$json, code = _ref3.code, table = _ref3.table, index_name = _ref3.index_name, _ref3$encode_type = _ref3.encode_type, encode_type = _ref3$encode_type === void 0 ? 'bytes' : _ref3$encode_type, index_value = _ref3.index_value, lower_bound = _ref3.lower_bound, upper_bound = _ref3.upper_bound, _ref3$limit = _ref3.limit, limit = _ref3$limit === void 0 ? 10 : _ref3$limit, _ref3$reverse = _ref3.reverse, reverse = _ref3$reverse === void 0 ? false : _ref3$reverse, _ref3$show_payer = _ref3.show_payer, show_payer = _ref3$show_payer === void 0 ? false : _ref3$show_payer;
              _context24.next = 3;
              return this.fetch('/v1/chain/get_kv_table_rows', {
                json: json,
                code: code,
                table: table,
                index_name: index_name,
                encode_type: encode_type,
                index_value: index_value,
                lower_bound: lower_bound,
                upper_bound: upper_bound,
                limit: limit,
                reverse: reverse,
                show_payer: show_payer
              });

            case 3:
              return _context24.abrupt("return", _context24.sent);

            case 4:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function get_kv_table_rows(_x36) {
      return _get_kv_table_rows.apply(this, arguments);
    }

    return get_kv_table_rows;
  }()
  /** Raw call to `/v1/chain/get_table_by_scope` */
  ;

  _proto.get_table_by_scope =
  /*#__PURE__*/
  function () {
    var _get_table_by_scope = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25(_ref4) {
      var code, table, _ref4$lower_bound, lower_bound, _ref4$upper_bound, upper_bound, _ref4$limit, limit;

      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              code = _ref4.code, table = _ref4.table, _ref4$lower_bound = _ref4.lower_bound, lower_bound = _ref4$lower_bound === void 0 ? '' : _ref4$lower_bound, _ref4$upper_bound = _ref4.upper_bound, upper_bound = _ref4$upper_bound === void 0 ? '' : _ref4$upper_bound, _ref4$limit = _ref4.limit, limit = _ref4$limit === void 0 ? 10 : _ref4$limit;
              _context25.next = 3;
              return this.fetch('/v1/chain/get_table_by_scope', {
                code: code,
                table: table,
                lower_bound: lower_bound,
                upper_bound: upper_bound,
                limit: limit
              });

            case 3:
              return _context25.abrupt("return", _context25.sent);

            case 4:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function get_table_by_scope(_x37) {
      return _get_table_by_scope.apply(this, arguments);
    }

    return get_table_by_scope;
  }()
  /** Get subset of `availableKeys` needed to meet authorities in `transaction`. Implements `AuthorityProvider` */
  ;

  _proto.getRequiredKeys =
  /*#__PURE__*/
  function () {
    var _getRequiredKeys = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee26(args) {
      var requiredKeys;
      return runtime_1.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.fetch('/v1/chain/get_required_keys', {
                transaction: args.transaction,
                available_keys: args.availableKeys
              });

            case 2:
              requiredKeys = _context26.sent;
              return _context26.abrupt("return", convertLegacyPublicKeys(requiredKeys.required_keys));

            case 4:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26, this);
    }));

    function getRequiredKeys(_x38) {
      return _getRequiredKeys.apply(this, arguments);
    }

    return getRequiredKeys;
  }()
  /** Push a serialized transaction (replaced by send_transaction, but returned format has changed) */
  ;

  _proto.push_transaction =
  /*#__PURE__*/
  function () {
    var _push_transaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee27(_ref5) {
      var signatures, _ref5$compression, compression, serializedTransaction, serializedContextFreeData, expired;

      return runtime_1.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              signatures = _ref5.signatures, _ref5$compression = _ref5.compression, compression = _ref5$compression === void 0 ? 0 : _ref5$compression, serializedTransaction = _ref5.serializedTransaction, serializedContextFreeData = _ref5.serializedContextFreeData;
              _context27.prev = 1;
              _context27.next = 4;
              return this.fetch('/v1/chain/push_transaction', {
                signatures: signatures,
                compression: compression,
                packed_context_free_data: arrayToHex$1(serializedContextFreeData || new Uint8Array(0)),
                packed_trx: arrayToHex$1(serializedTransaction)
              });

            case 4:
              return _context27.abrupt("return", _context27.sent);

            case 7:
              _context27.prev = 7;
              _context27.t0 = _context27["catch"](1);

              if (_context27.t0 && _context27.t0.json && _context27.t0.json.error) {
                expired = _context27.t0.json.error.name === 'expired_tx_exception';

                if (expired) {
                  _context27.t0.json.error.message = 'Transaction Expired: Try Again';
                  this.nextEndpoint();
                }
              }

              throw _context27.t0;

            case 11:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee27, this, [[1, 7]]);
    }));

    function push_transaction(_x39) {
      return _push_transaction.apply(this, arguments);
    }

    return push_transaction;
  }()
  /** Raw call to `/v1/chain/push_ro_transaction */
  ;

  _proto.push_ro_transaction =
  /*#__PURE__*/
  function () {
    var _push_ro_transaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee28(_ref6, returnFailureTraces) {
      var signatures, _ref6$compression, compression, serializedTransaction;

      return runtime_1.wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              signatures = _ref6.signatures, _ref6$compression = _ref6.compression, compression = _ref6$compression === void 0 ? 0 : _ref6$compression, serializedTransaction = _ref6.serializedTransaction;

              if (returnFailureTraces === void 0) {
                returnFailureTraces = false;
              }

              _context28.next = 4;
              return this.fetch('/v1/chain/push_ro_transaction', {
                transaction: {
                  signatures: signatures,
                  compression: compression,
                  packed_context_free_data: arrayToHex$1(new Uint8Array(0)),
                  packed_trx: arrayToHex$1(serializedTransaction)
                },
                return_failure_traces: returnFailureTraces
              });

            case 4:
              return _context28.abrupt("return", _context28.sent);

            case 5:
            case "end":
              return _context28.stop();
          }
        }
      }, _callee28, this);
    }));

    function push_ro_transaction(_x40, _x41) {
      return _push_ro_transaction.apply(this, arguments);
    }

    return push_ro_transaction;
  }();

  _proto.push_transactions = /*#__PURE__*/function () {
    var _push_transactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee29(transactions) {
      var packedTrxs;
      return runtime_1.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              packedTrxs = transactions.map(function (_ref7) {
                var signatures = _ref7.signatures,
                    _ref7$compression = _ref7.compression,
                    compression = _ref7$compression === void 0 ? 0 : _ref7$compression,
                    serializedTransaction = _ref7.serializedTransaction,
                    serializedContextFreeData = _ref7.serializedContextFreeData;
                return {
                  signatures: signatures,
                  compression: compression,
                  packed_context_free_data: arrayToHex$1(serializedContextFreeData || new Uint8Array(0)),
                  packed_trx: arrayToHex$1(serializedTransaction)
                };
              });
              _context29.next = 3;
              return this.fetch('/v1/chain/push_transactions', packedTrxs);

            case 3:
              return _context29.abrupt("return", _context29.sent);

            case 4:
            case "end":
              return _context29.stop();
          }
        }
      }, _callee29, this);
    }));

    function push_transactions(_x42) {
      return _push_transactions.apply(this, arguments);
    }

    return push_transactions;
  }()
  /** Send a serialized transaction */
  ;

  _proto.send_transaction =
  /*#__PURE__*/
  function () {
    var _send_transaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee30(_ref8) {
      var signatures, _ref8$compression, compression, serializedTransaction, serializedContextFreeData;

      return runtime_1.wrap(function _callee30$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              signatures = _ref8.signatures, _ref8$compression = _ref8.compression, compression = _ref8$compression === void 0 ? 0 : _ref8$compression, serializedTransaction = _ref8.serializedTransaction, serializedContextFreeData = _ref8.serializedContextFreeData;
              _context30.next = 3;
              return this.fetch('/v1/chain/send_transaction', {
                signatures: signatures,
                compression: compression,
                packed_context_free_data: arrayToHex$1(serializedContextFreeData || new Uint8Array(0)),
                packed_trx: arrayToHex$1(serializedTransaction)
              });

            case 3:
              return _context30.abrupt("return", _context30.sent);

            case 4:
            case "end":
              return _context30.stop();
          }
        }
      }, _callee30, this);
    }));

    function send_transaction(_x43) {
      return _send_transaction.apply(this, arguments);
    }

    return send_transaction;
  }()
  /** Raw call to `/v1/db_size/get` */
  ;

  _proto.db_size_get =
  /*#__PURE__*/
  function () {
    var _db_size_get = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee31() {
      return runtime_1.wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return this.fetch('/v1/db_size/get', {});

            case 2:
              return _context31.abrupt("return", _context31.sent);

            case 3:
            case "end":
              return _context31.stop();
          }
        }
      }, _callee31, this);
    }));

    function db_size_get() {
      return _db_size_get.apply(this, arguments);
    }

    return db_size_get;
  }()
  /** Raw call to `/v1/trace_api/get_block` */
  ;

  _proto.trace_get_block =
  /*#__PURE__*/
  function () {
    var _trace_get_block = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee32(block_num) {
      return runtime_1.wrap(function _callee32$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              _context32.next = 2;
              return this.fetch('/v1/trace_api/get_block', {
                block_num: block_num
              });

            case 2:
              return _context32.abrupt("return", _context32.sent);

            case 3:
            case "end":
              return _context32.stop();
          }
        }
      }, _callee32, this);
    }));

    function trace_get_block(_x44) {
      return _trace_get_block.apply(this, arguments);
    }

    return trace_get_block;
  }()
  /** Raw call to `/v1/history/get_actions` */
  ;

  _proto.history_get_actions =
  /*#__PURE__*/
  function () {
    var _history_get_actions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee33(accountName, pos, offset) {
      return runtime_1.wrap(function _callee33$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              if (pos === void 0) {
                pos = null;
              }

              if (offset === void 0) {
                offset = null;
              }

              _context33.next = 4;
              return this.fetch('/v1/history/get_actions', {
                account_name: accountName,
                pos: pos,
                offset: offset
              });

            case 4:
              return _context33.abrupt("return", _context33.sent);

            case 5:
            case "end":
              return _context33.stop();
          }
        }
      }, _callee33, this);
    }));

    function history_get_actions(_x45, _x46, _x47) {
      return _history_get_actions.apply(this, arguments);
    }

    return history_get_actions;
  }()
  /** Raw call to `/v1/history/get_transaction` */
  ;

  _proto.history_get_transaction =
  /*#__PURE__*/
  function () {
    var _history_get_transaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee34(id, blockNumHint) {
      return runtime_1.wrap(function _callee34$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              if (blockNumHint === void 0) {
                blockNumHint = null;
              }

              _context34.next = 3;
              return this.fetch('/v1/history/get_transaction', {
                id: id,
                block_num_hint: blockNumHint
              });

            case 3:
              return _context34.abrupt("return", _context34.sent);

            case 4:
            case "end":
              return _context34.stop();
          }
        }
      }, _callee34, this);
    }));

    function history_get_transaction(_x48, _x49) {
      return _history_get_transaction.apply(this, arguments);
    }

    return history_get_transaction;
  }()
  /** Raw call to `/v1/history/get_key_accounts` */
  ;

  _proto.history_get_key_accounts =
  /*#__PURE__*/
  function () {
    var _history_get_key_accounts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee35(publicKey) {
      return runtime_1.wrap(function _callee35$(_context35) {
        while (1) {
          switch (_context35.prev = _context35.next) {
            case 0:
              _context35.next = 2;
              return this.fetch('/v1/history/get_key_accounts', {
                public_key: publicKey
              });

            case 2:
              return _context35.abrupt("return", _context35.sent);

            case 3:
            case "end":
              return _context35.stop();
          }
        }
      }, _callee35, this);
    }));

    function history_get_key_accounts(_x50) {
      return _history_get_key_accounts.apply(this, arguments);
    }

    return history_get_key_accounts;
  }()
  /** Raw call to `/v1/history/get_controlled_accounts` */
  ;

  _proto.history_get_controlled_accounts =
  /*#__PURE__*/
  function () {
    var _history_get_controlled_accounts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee36(controllingAccount) {
      return runtime_1.wrap(function _callee36$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              _context36.next = 2;
              return this.fetch('/v1/history/get_controlled_accounts', {
                controlling_account: controllingAccount
              });

            case 2:
              return _context36.abrupt("return", _context36.sent);

            case 3:
            case "end":
              return _context36.stop();
          }
        }
      }, _callee36, this);
    }));

    function history_get_controlled_accounts(_x51) {
      return _history_get_controlled_accounts.apply(this, arguments);
    }

    return history_get_controlled_accounts;
  }()
  /** FIO` */
  ;

  _proto.get_nfts_fio_address =
  /*#__PURE__*/
  function () {
    var _get_nfts_fio_address = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee37(address) {
      return runtime_1.wrap(function _callee37$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              _context37.next = 2;
              return this.fetch('/v1/chain/get_nfts_fio_address', {
                fio_address: address
              });

            case 2:
              return _context37.abrupt("return", _context37.sent);

            case 3:
            case "end":
              return _context37.stop();
          }
        }
      }, _callee37, this);
    }));

    function get_nfts_fio_address(_x52) {
      return _get_nfts_fio_address.apply(this, arguments);
    }

    return get_nfts_fio_address;
  }()
  /** Proton` */
  ;

  return JsonRpc;
}(); // JsonRpc

/**
 * @module RPC-API-Methods
 * copyright defined in eosjs/LICENSE.txt
 */

var RpcInterfaces = {
  __proto__: null
};

/** Signs transactions using WebAuthn */

var WebAuthnSignatureProvider = /*#__PURE__*/function () {
  function WebAuthnSignatureProvider() {
    this.keys = new Map();
  }

  var _proto = WebAuthnSignatureProvider.prototype;

  /** Public keys that the `SignatureProvider` holds */
  _proto.getAvailableKeys =
  /*#__PURE__*/
  function () {
    var _getAvailableKeys = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Array.from(this.keys.keys()));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getAvailableKeys() {
      return _getAvailableKeys.apply(this, arguments);
    }

    return getAvailableKeys;
  }()
  /** Sign a transaction */
  ;

  _proto.sign =
  /*#__PURE__*/
  function () {
    var _sign = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref) {
      var chainId, requiredKeys, serializedTransaction, serializedContextFreeData, signBuf, digest, signatures, _iterator, _step, key, id, assertion, e, pubKey, fixup, der, r, s, whatItReallySigned, hash, recid, sigData, sig;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              chainId = _ref.chainId, requiredKeys = _ref.requiredKeys, serializedTransaction = _ref.serializedTransaction, serializedContextFreeData = _ref.serializedContextFreeData;
              signBuf = new SerialBuffer();
              signBuf.pushArray(hexToUint8Array(chainId));
              signBuf.pushArray(serializedTransaction);

              if (!serializedContextFreeData) {
                _context2.next = 14;
                break;
              }

              _context2.t0 = signBuf;
              _context2.t1 = Uint8Array;
              _context2.next = 9;
              return crypto.subtle.digest('SHA-256', serializedContextFreeData.buffer);

            case 9:
              _context2.t2 = _context2.sent;
              _context2.t3 = new _context2.t1(_context2.t2);

              _context2.t0.pushArray.call(_context2.t0, _context2.t3);

              _context2.next = 15;
              break;

            case 14:
              signBuf.pushArray(new Uint8Array(32));

            case 15:
              _context2.t4 = Uint8Array;
              _context2.next = 18;
              return crypto.subtle.digest('SHA-256', signBuf.asUint8Array().slice().buffer);

            case 18:
              _context2.t5 = _context2.sent;
              digest = new _context2.t4(_context2.t5);
              signatures = [];
              _iterator = _createForOfIteratorHelperLoose(requiredKeys);

            case 22:
              if ((_step = _iterator()).done) {
                _context2.next = 67;
                break;
              }

              key = _step.value;
              id = hexToUint8Array(this.keys.get(key));
              _context2.next = 27;
              return navigator.credentials.get({
                publicKey: {
                  timeout: 60000,
                  allowCredentials: [{
                    id: id,
                    type: 'public-key'
                  }],
                  challenge: digest.buffer
                }
              });

            case 27:
              assertion = _context2.sent;
              e = new ec('p256'); // https://github.com/indutny/elliptic/pull/232

              pubKey = e.keyFromPublic(stringToPublicKey(key).data.subarray(0, 33)).getPublic();

              fixup = function fixup(x) {
                var a = Array.from(x);

                while (a.length < 32) {
                  a.unshift(0);
                }

                while (a.length > 32) {
                  if (a.shift() !== 0) {
                    throw new Error('Signature has an r or s that is too big');
                  }
                }

                return new Uint8Array(a);
              };

              der = new SerialBuffer({
                array: new Uint8Array(assertion.response.signature)
              });

              if (!(der.get() !== 0x30)) {
                _context2.next = 34;
                break;
              }

              throw new Error('Signature missing DER prefix');

            case 34:
              if (!(der.get() !== der.array.length - 2)) {
                _context2.next = 36;
                break;
              }

              throw new Error('Signature has bad length');

            case 36:
              if (!(der.get() !== 0x02)) {
                _context2.next = 38;
                break;
              }

              throw new Error('Signature has bad r marker');

            case 38:
              r = fixup(der.getUint8Array(der.get()));

              if (!(der.get() !== 0x02)) {
                _context2.next = 41;
                break;
              }

              throw new Error('Signature has bad s marker');

            case 41:
              s = fixup(der.getUint8Array(der.get()));
              whatItReallySigned = new SerialBuffer();
              whatItReallySigned.pushArray(new Uint8Array(assertion.response.authenticatorData));
              _context2.t6 = whatItReallySigned;
              _context2.t7 = Uint8Array;
              _context2.next = 48;
              return crypto.subtle.digest('SHA-256', assertion.response.clientDataJSON);

            case 48:
              _context2.t8 = _context2.sent;
              _context2.t9 = new _context2.t7(_context2.t8);

              _context2.t6.pushArray.call(_context2.t6, _context2.t9);

              _context2.t10 = Uint8Array;
              _context2.next = 54;
              return crypto.subtle.digest('SHA-256', whatItReallySigned.asUint8Array().slice());

            case 54:
              _context2.t11 = _context2.sent;
              hash = new _context2.t10(_context2.t11);
              recid = e.getKeyRecoveryParam(hash, new Uint8Array(assertion.response.signature), pubKey);
              sigData = new SerialBuffer();
              sigData.push(recid + 27 + 4);
              sigData.pushArray(r);
              sigData.pushArray(s);
              sigData.pushBytes(new Uint8Array(assertion.response.authenticatorData));
              sigData.pushBytes(new Uint8Array(assertion.response.clientDataJSON));
              sig = signatureToString({
                type: KeyType.wa,
                data: sigData.asUint8Array().slice()
              });
              signatures.push(sig);

            case 65:
              _context2.next = 22;
              break;

            case 67:
              return _context2.abrupt("return", {
                signatures: signatures,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData
              });

            case 68:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function sign(_x) {
      return _sign.apply(this, arguments);
    }

    return sign;
  }();

  return WebAuthnSignatureProvider;
}();

var index = {
  Api: Api,
  ApiInterfaces: ApiInterfaces,
  JsonRpc: JsonRpc,
  Numeric: Numeric,
  RpcInterfaces: RpcInterfaces,
  RpcError: RpcError,
  Serialize: Serialize,
  JsSignatureProvider: JsSignatureProvider,
  Key: Key,
  sha256: sha256,
  WebAuthnSignatureProvider: WebAuthnSignatureProvider
};

export default index;
export { Api, ApiInterfaces, JsSignatureProvider, JsonRpc, Key, Numeric, RpcError, RpcInterfaces, Serialize, WebAuthnSignatureProvider, digestFromSerializedData, sha256 };
//# sourceMappingURL=js.esm.js.map
